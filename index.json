[{"content":"本文介绍 _slb 的代码规范。关于我的代码规范，她非常地正经、非常地合理。\n基本参考了 _rqy 的风格。\n概述 不使用 #include \u0026lt;bits/stdc++.h\u0026gt;，头文件顺序不做要求。\n可以使用 using namespace std;。\n尽量不使用 #define，多使用 typedef，const。\n一行长度尽量不超过 $120$ 字符或者不超过屏幕 $80\\%$ 的宽度。要易于阅读。\n缩进 每个代码块使用四个空格缩进，包括流程控制语句、namespace 下等。\n空格及换行 大部分时候使用大括号换行风格，例：\nif (orz) { // do something\t} else { // do something } 偶尔会使用大括号不换行的风格，例：\nif (orz) { // do something } else { // do something } 加空格地方：\n二目、三目运算符两侧； ,，; 的右边（前提是不处于行末）； 流程控制关键字与其后面的括号之间； do-while 中的 while 与其左面的大括号之间； 当整组大括号都在一行时，左大括号前打一个空格； 常成员函数的 const 两侧。 不加空格地方：\n小括号、中括号与其内部表达式等之间；\n函数名与左括号之间；\n单目运算符前后；\n.，::，-\u0026gt; 的两侧；\noperator 与重载的运算符之间。\n表达式过长可以分多行——缩进的关键是对齐。\n很短的函数可以写到一行。\n空行 所有#include \u0026lt;foobar\u0026gt;与using foo::bar;之间不应空行，之后应空一行。\n一系列常量定义的上下应有空行。\n函数/结构体定义两侧可以有空行（一系列短小到可以写到一行的函数，如min, max，之间可以不空行）。\n一系列全局变量定义的上下应有空行。\n语句之间可根据其意义酌情空行。\n任何位置不能出现连续的两个（或以上）空行。\n函数 main 函数返回值最好是 int。\n传自定义结构体/类的时候尽量传引用并加 const。\n单个函数不应过长。\n命名 并没有什么特殊的命名方法，一般使用下划线。\n大写字母一般较少使用。\n一些正式的数据结构的开头字母会大写，而单纯的模块化并不会大写开头字母。\n其他 不进行压行，一行最多一个语句。\n如果语义连续，可以酌情使用逗号。\n三目运算符合适就用。尽量做到易于阅读。\nif，while，for 等流程控制语句，即使后面只有单个语句，也不能放在一行。\n尽量少利用不是非常显然的返回值（如逗号）来简化代码（如 return p.push_back(x), void() 等）。\n关于指针与数组，当用指针写起来没啥太大问题时，可能更偏向指针，当用指针容易出问题时，偏向数组（这条实际上比较看习惯）。\n代码结构 注：此部分内容可能会经常调整，此处写的未必是正在用的代码结构。\n有一个 namespace IO，但不会经常使用，大部分用 cin。\nnamespace solve 里的代码是有用的，其他均为不变的模板。\nexample #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; typedef long long ll; typedef unsigned long long ull; bool MEM1; namespace IO { const int mxsiz = 1 \u0026lt;\u0026lt; 20; char inbuf[mxsiz], *p1, *p2; char outbuf[mxsiz], *op = outbuf; struct endio { endio(){}; ~endio() { fwrite(outbuf, 1, op - outbuf, stdout); } } useless_var; inline char gc() { return p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = inbuf) + fread(inbuf, 1, mxsiz, stdin), p1 == p2) ? EOF : *p1++; } inline int read() { int x = 0, f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x * f; } template \u0026lt;typename T\u0026gt; inline void read(T \u0026amp;x) { x = 0; int f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; x *= f; } inline bool ischar(char x) { return x \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;z\u0026#39;; } inline char readchar() { char ch = gc(); while (!ischar(ch)) ch = gc(); return ch; } inline void push(char ch) { if (op - outbuf == mxsiz) fwrite(outbuf, 1, mxsiz, stdout), op = outbuf; *op++ = ch; } template \u0026lt;typename T\u0026gt; inline void work_wt(T x) { if (x \u0026gt; 9) work_wt(x / 10); push(x % 10 + \u0026#39;0\u0026#39;); } template \u0026lt;typename T\u0026gt; inline void write(T x) { if (x \u0026lt; 0) x = -x, push(\u0026#39;-\u0026#39;); work_wt(x); } inline void writestr(char *s) { int n = strlen(s); for (int i = 0; i \u0026lt; n; i++) push(s[i]); } inline void endln() { push(\u0026#39;\\n\u0026#39;); } inline void space() { push(\u0026#39; \u0026#39;); } template \u0026lt;typename T\u0026gt; inline void writeln(T x) { write(x), endln(); } } using namespace IO; namespace solve { const int maxn = 2e6 + 10; typedef pair\u0026lt;int, int\u0026gt; pii; int father[maxn], mx[maxn]; int ch[maxn][26]; int tot, lst, dfn[maxn], n, pos[maxn], cnt_dfn; int arcdfn[maxn]; ll sum[maxn / 2]; char s[maxn / 2]; struct SAM { SAM() { lst = tot = 1; } } SAM__; void insert(int c, int id) { int p = ++tot, f = lst; lst = p, mx[p] = mx[f] + 1, pos[p] = id; while (f \u0026amp;\u0026amp; !ch[f][c]) ch[f][c] = p, f = father[f]; if (!f) father[p] = 1; else { int q = ch[f][c]; if (mx[q] == mx[f] + 1) father[p] = q; else { int nq = ++tot; memcpy(ch[nq], ch[q], sizeof(ch[q])); father[nq] = father[q], mx[nq] = mx[f] + 1; father[p] = father[q] = nq; while (f \u0026amp;\u0026amp; ch[f][c] == q) ch[f][c] = nq, f = father[f]; } } } struct edge { int nxt, y, w; bool operator\u0026lt;(const edge \u0026amp;b) const { return w \u0026lt; b.w; } } e[maxn]; int hd[maxn]; int cnt[maxn], topo[maxn]; struct tmpp { int a, b, c; } alle[maxn]; struct md { int time; pii opt; } change[maxn * 2]; int totch; int tote, ee; void add(int x, int y, int w) { alle[++tote] = {x, y, w}; } void addall() { sort(alle + 1, alle + 1 + tote, [\u0026amp;](const tmpp \u0026amp;a, const tmpp \u0026amp;b) { return a.c \u0026gt; b.c; }); for (int i = 1; i \u0026lt;= tote; i++) { ee++; int x = alle[i].a, y = alle[i].b, w = alle[i].c; e[ee] = {hd[x], y, w}, hd[x] = ee; } } void build() { for (int i = 1; i \u0026lt;= tot; i++) cnt[mx[i]]++; for (int i = 1; i \u0026lt;= n; i++) cnt[i] += cnt[i - 1]; for (int i = tot; i \u0026gt;= 1; i--) topo[cnt[mx[i]]--] = i; for (int i = tot; i \u0026gt;= 1; i--) { int x = topo[i]; sum[mx[father[x]] + 1]++, sum[mx[x] + 1]--; pos[father[x]] = max(pos[x], pos[father[x]]); } for (int i = 2; i \u0026lt;= tot; i++) { totch++; change[totch] = {mx[father[i]] + 1, pii(i, 1)}; totch++; change[totch] = {mx[i] + 1, pii(i, -1)}; } } void build2() { for (int i = 2; i \u0026lt;= tot; i++) add(father[i], i, s[pos[i] - mx[father[i]]] - \u0026#39;a\u0026#39;); addall(); sort(change + 1, change + 1 + totch, [\u0026amp;](const md \u0026amp;a, const md \u0026amp;b) { return a.time \u0026lt; b.time; }); } void dfs2(int x) { dfn[x] = ++cnt_dfn, arcdfn[cnt_dfn] = x; for (int p = hd[x]; p; p = e[p].nxt) dfs2(e[p].y); } struct Segtree { static const int maxn = solve::maxn \u0026lt;\u0026lt; 2; int sum[maxn]; inline int ls(int x) { return x * 2; } inline int rs(int x) { return x * 2 + 1; } void push_up(int k) { sum[k] = sum[ls(k)] + sum[rs(k)]; } void modify(int l, int r, int x, int v, int k) { if (l == r) { sum[k] += v; return; } int mid = (l + r) / 2; if (x \u0026lt;= mid) modify(l, mid, x, v, ls(k)); else modify(mid + 1, r, x, v, rs(k)); push_up(k); } int query(int l, int r, int x, int k) { if (l == r) return l; int mid = (l + r) / 2; if (sum[ls(k)] \u0026gt;= x) return query(l, mid, x, ls(k)); else return query(mid + 1, r, x - sum[ls(k)], rs(k)); } } t; struct Q { ll k; int id; int res1, res2; bool operator\u0026lt;(const Q \u0026amp;b) const { return k \u0026lt; b.k; } } q[maxn]; int m; int main() { scanf(\u0026#34;%s\u0026#34;, s + 1); n = strlen(s + 1); reverse(s + 1, s + 1 + n); for (int i = 1; i \u0026lt;= n; i++) insert(s[i] - \u0026#39;a\u0026#39;, i); build(), build2(), dfs2(1); for (int i = 1; i \u0026lt;= n; i++) sum[i] += sum[i - 1]; for (int i = 1; i \u0026lt;= n; i++) sum[i] += sum[i - 1]; sum[0] = 0; m = read(); for (int i = 1; i \u0026lt;= m; i++) read(q[i].k), q[i].id = i; sort(q + 1, q + 1 + m); int now = 1; for (int i = 1; i \u0026lt;= m; i++) { int len = lower_bound(sum + 1, sum + 1 + n, q[i].k) - sum; if (len \u0026gt; n) { q[i].res1 = -1, q[i].res2 = -1; continue; } int k = q[i].k - sum[len - 1]; // cerr \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; now \u0026lt;\u0026lt; endl; while (change[now].time \u0026lt;= len) { t.modify(1, tot, dfn[change[now].opt.first], change[now].opt.second, 1); now++; } int uu = t.query(1, tot, k, 1); uu = arcdfn[uu]; int tmpl = pos[uu] - len + 1; int tmpr = pos[uu]; q[i].res1 = n - tmpr + 1; q[i].res2 = n - tmpl + 1; } sort(q + 1, q + 1 + m, [\u0026amp;](const Q \u0026amp;a, const Q \u0026amp;b) { return a.id \u0026lt; b.id; }); for (int i = 1; i \u0026lt;= m; i++) write(q[i].res1), space(), writeln(q[i].res2); return 0; } } bool MEM2; int main() { #ifdef local cerr \u0026lt;\u0026lt; \u0026#34;memory : \u0026#34; \u0026lt;\u0026lt; abs(\u0026amp;MEM1 - \u0026amp;MEM2) / 1024. / 1024 \u0026lt;\u0026lt; \u0026#34; mb\u0026#34; \u0026lt;\u0026lt; endl; #endif int cases = 1; while (cases--) solve::main(); #ifdef local cerr \u0026lt;\u0026lt; \u0026#34;time : \u0026#34; \u0026lt;\u0026lt; 1000.0 * clock() / CLOCKS_PER_SEC \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; #endif return 0; } 注：此为 CF gym103409J。\n","permalink":"https://luoyisu.github.io/posts/code-style/","summary":"\u003cp\u003e本文介绍 _slb 的代码规范。关于我的代码规范，她非常地正经、非常地合理。\u003c/p\u003e\n\u003cp\u003e基本参考了 \u003ca href=\"https://rqy.moe/uncategorized/rqy-s-Code-Style-for-OI/\"\u003e_rqy\u003c/a\u003e 的风格。\u003c/p\u003e","title":"_slb's Code Style"},{"content":"各种容斥。\n本人水平有限，若有错误请务必提出。\n知识 容斥原理 对于集合 $A_1,A_2,A_3,\\dots,A_n$，\n$$ \\left| \\bigcup_{i = 1}^n A_i \\right| = \\sum_{\\varnothing \\neq S \\subseteq \\{1,2,\\dots,n\\}} (-1)^{|S| - 1} \\left| \\bigcap_{i \\in S} A_i \\right| $$\n使用二项式定理计算一个元素在右边式子的出现次数可以证明上面公式。\n推论： 对于一个全集 $U$ 的子集 $A_1,A_2,A_3,\\dots,A_n$，\n$$ \\left| \\bigcap_{i = 1}^n \\overline A_i \\right| = \\sum_{S \\subseteq \\{1,2,\\dots,n\\}} (-1)^{|S|} \\left| \\bigcap_{i\\in S} A_i \\right| $$\n这里 $\\cap_{i \\in \\varnothing} A_i=U$。\n证明：补集的交等于全集减去并集，并集使用第一个公式计算。\n第一个公式：或转化为全部；\n第二个公式：全都不转化为全部。\nmin-max 容斥 $$ \\max_{i = 1}^n a_i = \\sum_{\\varnothing \\neq S \\subseteq \\{1,2,\\dots,n\\}} (-1)^{|S| - 1} \\min_{i \\in S} a_i $$\n一个大概的证明：把 $x$ 看成 $(-\\infty,x)$，则 $A \\cup B = \\max\\{a,b\\}$，$A \\cap B = \\min\\{a,b\\}$\n看起来很蠢，但重要的是这个式子对期望也成立。\n对两个数的质因数质数进行 min-max 容斥可得：\n$$ \\underset{i\\in S}{\\operatorname{lcm}}{x_i}=\\prod_{T\\subseteq S}{\\left(\\gcd_{j\\in T}{x_j} \\right)^{(-1)^{|T|-1}}} $$\n二项式反演 先给出两个最常用的形式：\n$$ g(k) = \\sum_{i = 0}^k \\binom{k}{i} f(i) \\Leftrightarrow f(k) = \\sum_{i = 0}^k (-1)^{k - i} \\binom{k}{i} g(i) $$\n$$ g(k) = \\sum_{i = k}^n \\binom{i}{k} f(i) \\Leftrightarrow f(k) = \\sum_{i = k}^n (-1)^{i - k} \\binom{i}{k} g(i) $$\n先来证明第一个形式。\n证明当然可以用代数推导，这里给一个用上面容斥原理的方法。\n假设全集 $U$ 中有 $n$ 个集合，其中任意若干个元素的并集、交集的大小仅与进行运算的集合个数有关，设 $g(x)$ 是任意 $x$ 个集合的交集，$f(x)$ 是任意 $x$ 个集合的并集，对所有集合的交集和所有集合补集的交集（并集）分别使用上面容斥原理的第二个公式可得：\n$$ g(n) = \\sum_{i = 0}^n (-1)^i \\binom{n}{i} f(i) \\Leftrightarrow f(n) = \\sum_{i = 0}^b (-1)^i \\binom{n}{i} g(i) $$\n设 $h(x) = (-1)^n g(x)$ 稍加整理即可得到上面的第一个形式。\n后一个形式也可以用代数推导。\n下面是反演两个形式对应的组合意义：\n第一个形式：可以将“恰好 $k$ 个”转化为“除了 $k$ 个都不”，或者说“至多 $k$ 个”满足，即选取一些地方可以满足也可以不满足，其余地方一定不满足。\n第二个形式：可以将“恰好 $k$ 个”转化为“选取 $k$ 个”，或者说“至少 $k$ 个”满足，即选取一些地方一定满足，其他无所谓。\n实际运用中第二个形式较为常见。组合意义可以帮助理解二项式反演（或者说可以当成一个证明？）\n例题 loj3119 CTS2019 随机立方体 链接\n首先把恰好 $k$ 个用二项式反演变为选取 $k$ 个。很显然任意两个极大点都不会共面，那么选取 $k$ 个点的方案数就是 $n^{\\underline k}m^{\\underline k}l^{\\underline k}$。\n设有 $i$ 个极大值，被限制住的点数是 $f_i=nml-(n-i)(m-i)(l-i)$。\n选取一些点被极大值限制的方案数是 $\\binom{nml}{f_i}$ 剩下的点可以随便排，就是再乘一个 $(n-k)(m-k)(l-k)!$ 都是显然的。\n然后考虑有限制内部怎么算，设 $i$ 个极大值的方案数是 $g_i$，我们从小到大加入极大值，可以写出递推式：$g_i=g_{i - 1} \\times \\dfrac{(f_i - 1)!}{f_{i - 1}!}$，算一下可以解出来 $g_i=f_i!\\prod_{j = 1}^i \\dfrac{1}{f_j}$。\n这里还有一个巧妙的计算方法：考虑树的拓扑序，一个有 $n$ 个点的有根树的拓扑序怎么求呢？其充要条件是：对于每个 $i$，$i$ 子树中的点都出现在其后面，子树之间是独立的，故总方案数为：$n!\\prod_{i = 1}^n \\dfrac{1}{siz_i}$。回到原题，我们发现把一个点连向需要比其大的点就可以转化为一个树上的拓扑序模型，可以直接得到答案。\n以上都乘起来，再除以总方案数，得到 $n^{\\underline k}m^{\\underline k}l^{\\underline k}\\prod_{j = 1}^i \\dfrac{1}{f_j}$，最后再反演一下即可。\n复杂度线性或者带一个快速幂的 $\\log$\n","permalink":"https://luoyisu.github.io/posts/inclusion-exclusion-principle/","summary":"\u003cp\u003e各种容斥。\u003c/p\u003e\n\u003cp\u003e本人水平有限，若有错误请务必提出。\u003c/p\u003e","title":"容斥"},{"content":"还是比去年要难的。\n种花 Description 给一个 $n\\times m$ 的 01 矩阵，问其中有多少个由 0 组成的 C 形状和 F 形状。\n$n,m\\leq1000$\nSolution 从上向下扫，记录每一列 $\\Gamma$ 形状的数量和二阶 $\\Gamma$ 形状（其实就是 F）的数量即可，利用行后缀 0 数量统计即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; namespace solve { const int maxn = 1010; typedef long long ll; const int mod = 998244353; int a[maxn][maxn], n, m, c, f; void main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; c \u0026gt;\u0026gt; f; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { char ch; cin \u0026gt;\u0026gt; ch; a[i][j] = ch - \u0026#39;0\u0026#39;; } static ll C[maxn], suf[maxn], sum[maxn]; memset(C, 0, sizeof(C)), memset(suf, 0, sizeof(suf)), memset(sum, 0, sizeof(sum)); ll resc = 0, resf = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = m; j \u0026gt;= 1; j--) { if (a[i][j] == 1) { C[j] = suf[j] = sum[j] = 0; continue; } (resc += 1ll * C[j] * suf[j + 1] % mod) %= mod; (resf += sum[j]) %= mod; (sum[j] += C[j] * 1ll * suf[j + 1] % mod) %= mod; if (suf[j]) C[j] += suf[j] - 1; suf[j] = suf[j + 1] + 1; } } cout \u0026lt;\u0026lt; resc * c % mod \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; resf * f % mod \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { // freopen(\u0026#34;plant.in\u0026#34;, \u0026#34;r\u0026#34;, stdin), freopen(\u0026#34;plant.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int T, id; cin \u0026gt;\u0026gt; T \u0026gt;\u0026gt; id; while (T--) solve::main(); } 喵了个喵 Description 有一个长度为 $m$ 的卡牌队列，共有 $k$ 种不同图案的卡牌，你有 $n$ 个栈。有两种操作。\n选择一个栈，将牌堆顶上的卡牌放入栈的顶部。如果这么操作后，这个栈最上方的两张牌有相同的图案，则会自动将这两张牌消去。\n选择两个不同的栈，如果这两个栈栈底的卡牌有相同的图案，则可以将这两张牌消去，原来在栈底上方的卡牌会成为新的栈底。如果不同，则什么也不会做。\n$m\\leq 2\\times 10^6,n\\leq300, k=2n-1,1\\leq a_i\\leq k$。\n有一个部分分是 $k=2n-2$。\nSolution 一眼看起来非常神秘，完全不可做，题目保证了 $k=2n-2$ 或 $k=2n-1$，只能从此入手。\n首先当一个栈顶的牌和要放的牌一样时，显然一定要消掉。\n当 $k=2n-2$，一个显然的做法是留出一个空栈，其他的栈都放两张不同的牌，这样再来一张牌肯定能消掉一张牌，就赢了。\n当 $k=2n-1$，可以尝试让一个栈里面有 $3$ 种牌，然后对于这一堆，要保证最下面的牌在后面的队列里先出现。\n考虑到我们可能被迫会往剩下的那个空栈放牌，我们要保证在出现这种情况后，被盖在下面的牌不会寄，这就对当若干个栈里只有一张牌的时候，新牌放哪个栈里有要求。\n当没有一个合法的两牌栈的时候，我们优先把这张牌放到出现最晚的牌上面。这样就能满足我们的要求了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cassert\u0026gt; using namespace std; namespace solve { const int maxn = 2e6 + 10; vector\u0026lt;int\u0026gt; s[maxn]; int n, m, KKK, a[maxn], nxt[maxn], lst[maxn], match[maxn], pos[maxn]; void main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; KKK; for (int i = 1; i \u0026lt;= KKK; i++) match[i] = pos[i] = lst[i] = 0; for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = m; i \u0026gt;= 1; i--) nxt[i] = lst[a[i]], lst[a[i]] = i; for (int i = 1; i \u0026lt;= n; i++) s[i].clear(); vector\u0026lt;array\u0026lt;int, 3\u0026gt;\u0026gt; ans; for (int i = 1; i \u0026lt;= m; i++) { if (pos[a[i]]) { int x = pos[a[i]]; pos[a[i]] = 0; if (s[x].back() == a[i]) ans.push_back({0, x, 0}), s[x].pop_back(); else { int p = 0; for (int i = 1; i \u0026lt;= n; i++) if (s[i].size() == 0) { p = i; break; } ans.push_back({0, p, 0}), ans.push_back({1, x, p}); assert(s[x][0] == a[i]); s[x].erase(s[x].begin()); } } else { int p = 0; auto find1 = [\u0026amp;]() { for (int j = 1; j \u0026lt;= n; j++) if (s[j].size() == 2 \u0026amp;\u0026amp; match[s[j][0]] \u0026lt; match[s[j][1]]) return j; return 0; }; auto find2 = [\u0026amp;]() { int mx = 0, res = 0; for (int j = 1; j \u0026lt;= n; j++) if (s[j].size() == 1 \u0026amp;\u0026amp; match[s[j][0]] \u0026gt; mx) mx = match[s[j][0]], res = j; return res; }; auto find3 = [\u0026amp;]() { for (int j = 1; j \u0026lt;= n; j++) if (s[j].size() == 0) return j; assert(0); return 0; }; p = find1(); if (!p) p = find2(); if (!p) p = find3(); pos[a[i]] = p, s[p].push_back(a[i]), ans.push_back({0, p, 0}); match[a[i]] = nxt[i]; } } cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; for (const auto \u0026amp;o : ans) if (o[0] == 0) cout \u0026lt;\u0026lt; \u0026#34;1 \u0026#34; \u0026lt;\u0026lt; o[1] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#34;2 \u0026#34; \u0026lt;\u0026lt; o[1] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; o[2] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { // freopen(\u0026#34;meow.in\u0026#34;, \u0026#34;r\u0026#34;, stdin), freopen(\u0026#34;meow.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) solve::main(); } 建造军营 Description 有一个 $n$ 个点，$m$ 个边的无向图，A 国要选择至少一个城市建造军营。B 国可以摧毁一条道路。\n现在 A 国可以保护任意条道路，被保护的道路不会被 B 国摧毁。A 国希望制定一个建造军营和看守道路的方案，使得 B 国袭击的无论是 A 国的哪条道路，都不会造成某两座军营无法互相到达。求可能的建造军营和看守道路的方案数共有多少。\n$n\\leq5\\times10^5,m\\leq10^6$。\nSolution 对于一个边双，摧毁是没用的，启发我们边双缩点成一个树。\n然后考虑树形dp，每种方案在若干个要建兵营的点的边双处贡献答案。计算的时候保护一次边答案就记得除以 $2$，最后再乘上 $2^m$ 即可得到最终答案。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;cassert\u0026gt; using namespace std; namespace solve { const int maxn = 1e6 + 10; const int mod = 1e9 + 7; const int inv2 = (mod + 1) / 2; typedef long long ll; ll mi[maxn]; vector\u0026lt;int\u0026gt; e[maxn], e2[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } int dfn[maxn], low[maxn], stk[maxn], top, cnt; int scc[maxn], tot, siz[maxn]; int n, m; void tarjan(int x, int fa) { stk[++top] = x, dfn[x] = low[x] = ++cnt; for (int v : e[x]) if (v != fa) { if (!dfn[v]) tarjan(v, x); low[x] = min(low[x], low[v]); } if (low[x] == dfn[x]) { tot++; int now = 0; while (now != x) { now = stk[top--]; siz[tot]++, scc[now] = tot; } } } ll ans = 0; ll f[maxn]; void dfs(int x, int fa) { (ans += f[x] = mi[siz[x]] - 1) %= mod; for (int v : e2[x]) if (v != fa) { dfs(v, x); (ans += f[x] * f[v] % mod * inv2 % mod) %= mod; (f[x] += f[v] * (f[x] + 1) % mod * inv2 % mod) %= mod; } } void main() { mi[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) mi[i] = mi[i - 1] * 2 % mod; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0, x, y; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, add(x, y); tarjan(1, 0); for (int i = 1; i \u0026lt;= n; i++) for (int v : e[i]) if (scc[i] != scc[v]) e2[scc[i]].push_back(scc[v]); dfs(1, 0); cout \u0026lt;\u0026lt; ans * mi[m] % mod \u0026lt;\u0026lt; endl; } } int main() { // freopen(\u0026#34;barrack.in\u0026#34;, \u0026#34;r\u0026#34;, stdin), freopen(\u0026#34;barrack.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve::main(); } 比赛 Description 给出两个长度为 $n$ 的序列 $a, b$，$q$ 次询问，每次询问给出 $l,r$，求出\n$$ \\sum_{p = l}^r \\sum_{q = p}^r \\bigl(\\max\\nolimits_{i=p}^q a_i\\bigr)\\bigl(\\max\\nolimits_{i=p}^q b_i\\bigr). $$\n$n,q\\leq2.5\\times10^5$。\nSolution 和其他题解说的一样，这道题可以离线询问，把询问挂在右端点上，进行扫描线。这部分别的题解都说了，我就简单说一下。\n扫描右端点（记为 $pos$）的同时，用线段树各自维护每个位置到当前右端点中 $a,b$ 的最大值 $x_i,y_i$，用单调栈可以得出每次新数影响的区间，对应线段树的区间赋值操作。接着我们需要把 $[1,pos]$ 的答案都加上 $x_i\\times y_i$。\n整理一下需要支持的操作：\n序列 $x$ 区间赋值；\n序列 $y$ 区间赋值；\n区间答案加上 $x_iy_i$；\n查询区间答案和。\n三操作提示我们记录区间 $\\sum x_iy_i$，而为了维护区间 $x_i,y_i$，我们需要维护 $\\sum x_i,\\sum y_i$ 和区间长度 $len$。\n直接做可能不太方便，我们可以用矩阵方便地描述转移：\n答案矩阵是\n$$ \\begin{bmatrix} ans \\\\ \\sum xy \\\\ \\sum x \\\\ \\sum y \\\\ len \\end{bmatrix} $$\n赋值 $x$，赋值 $y$，区间加 $xy$ 都可以用矩阵表示： $$ \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; x \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; x \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; y \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; y \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$\n直接用线段树维护矩阵，复杂度 $O(5^3q\\log n)$，进行一些普通的常数优化后在 loj 上可以卡着时限通过，但洛谷显然不行。\n注意到矩阵很稀疏，打一个表可以发现很多地方永远会是 $0$，因此可以把矩阵乘法展开，手动乘，常数会下降很多。\nCode 在洛谷上最大点跑 1.55s，不算太慢。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cassert\u0026gt; using namespace std; bool MEM1; namespace IO { const int mxsiz = 1 \u0026lt;\u0026lt; 14; char inbuf[mxsiz], *p1, *p2; char outbuf[mxsiz], *op = outbuf; inline void flush() { fwrite(outbuf, 1, op - outbuf, stdout), op = outbuf; } struct endio { endio(){}; ~endio() { flush(); } } useless_var; inline char gc() { if (p1 == p2) p1 = inbuf, p2 = p1 + fread(inbuf, 1, mxsiz, stdin); return p1 == p2 ? EOF : *p1++; } inline int read() { int x = 0, f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x * f; } template \u0026lt;typename T\u0026gt; inline void read(T \u0026amp;x) { x = 0; int f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; x *= f; } template \u0026lt;typename T, typename... Args\u0026gt; inline void read(T \u0026amp;x, Args \u0026amp;...args) { read(x), read(args...); } inline void read(char \u0026amp;ch) { ch = gc(); while (!isgraph(ch)) ch = gc(); } inline void push(char ch) { if (op - outbuf == mxsiz) fwrite(outbuf, 1, mxsiz, stdout), op = outbuf; *op++ = ch; } template \u0026lt;typename... Args\u0026gt; inline void push(char ch, Args... args) { push(ch), push(args...); } inline void endln() { push(\u0026#39;\\n\u0026#39;); } inline void space() { push(\u0026#39; \u0026#39;); } template \u0026lt;typename T\u0026gt; inline void work_wt(T x) { if (x \u0026gt; 9) work_wt(x / 10); push(x % 10 + \u0026#39;0\u0026#39;); } template \u0026lt;typename T\u0026gt; inline void write(T x) { if (x \u0026lt; 0) x = -x, push(\u0026#39;-\u0026#39;); work_wt(x); } inline void write(char ch) { push(ch); } inline void write(const char *s) { int n = strlen(s); for (int i = 0; i \u0026lt; n; i++) push(s[i]); } template \u0026lt;typename T, typename... Args\u0026gt; inline void write(T x, Args... args) { write(x), write(args...); } template \u0026lt;typename T\u0026gt; inline void write_with_space(T x) { write(x), space(); } template \u0026lt;typename T, typename... Args\u0026gt; inline void write_with_space(T x, Args... args) { write_with_space(x), write_with_space(args...); } template \u0026lt;typename... Args\u0026gt; inline void writeln(Args... x) { write_with_space(x...), endln(); } }; using IO::endln; using IO::gc; using IO::read; using IO::space; using IO::write; using IO::write_with_space; using IO::writeln; namespace solve { typedef unsigned long long ull; const int maxn = 2.5e5 + 10; const vector\u0026lt;int\u0026gt; qwq[5] = { {0, 1, 2, 3, 4}, {1, 2, 3, 4}, {2, 4}, {3, 4}, {4}}; struct matrix { ull a[5][5]; int n, m; const ull *operator[](int x) const { return a[x]; } matrix operator+(const matrix \u0026amp;b) const { matrix res; for (int i = 0; i \u0026lt; 5; i++) for (int j = 0; j \u0026lt; 1; j++) res.a[i][j] = a[i][j] + b[i][j]; return res; } matrix operator*(const matrix \u0026amp;b) const { matrix res; res.clear(); /* 11111 01111 00101 00011 00001 */ // for (int i = 0; i \u0026lt; 5; i++) // for (int k : qwq[i]) // for (int j : qwq[k]) // res.a[i][j] += a[i][k] * b[k][j]; res.a[0][0] = a[0][0] * b[0][0]; res.a[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1]; res.a[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2]; res.a[0][3] = a[0][0] * b[0][3] + a[0][1] * b[1][3] + a[0][3] * b[3][3]; res.a[0][4] = a[0][0] * b[0][4] + a[0][1] * b[1][4] + a[0][2] * b[2][4] + a[0][3] * b[3][4] + a[0][4] * b[4][4]; res.a[1][1] = a[1][1] * b[1][1]; res.a[1][2] = a[1][1] * b[1][2] + a[1][2] * b[2][2] + a[1][3] * b[3][2]; res.a[1][3] = a[1][1] * b[1][3] + a[1][3] * b[3][3]; res.a[1][4] = a[1][1] * b[1][4] + a[1][2] * b[2][4] + a[1][3] * b[3][4] + a[1][4] * b[4][4]; res.a[2][2] = a[2][2] * b[2][2]; res.a[2][4] = a[2][2] * b[2][4] + a[2][4] * b[4][4]; res.a[3][3] = a[3][3] * b[3][3]; res.a[3][4] = a[3][3] * b[3][4] + a[3][4] * b[4][4]; res.a[4][4] = a[4][4] * b[4][4]; return res; } matrix operator\u0026amp;(const matrix \u0026amp;b) const { matrix res; res.clear(); for (int i = 0; i \u0026lt; 5; i++) for (int k = 0; k \u0026lt; 5; k++) for (int j = 0; j \u0026lt; 1; j++) res.a[i][j] += a[i][k] * b[k][j]; return res; } void init() { memset(a, 0, sizeof(a)); a[0][0] = a[1][1] = a[2][2] = a[3][3] = a[4][4] = 1; } void clear() { memset(a, 0, sizeof(a)); } } lzy[maxn \u0026lt;\u0026lt; 2], sum[maxn \u0026lt;\u0026lt; 2]; bool vis[maxn \u0026lt;\u0026lt; 2]; matrix opt3 = { {{1, 1, 0, 0, 0}, {0, 1, 0, 0, 0}, {0, 0, 1, 0, 0}, {0, 0, 0, 1, 0}, {0, 0, 0, 0, 1}}, 5, 5}; inline matrix opt1(ull x) { return { {{1, 0, 0, 0, 0}, {0, 0, 0, x, 0}, {0, 0, 0, 0, x}, {0, 0, 0, 1, 0}, {0, 0, 0, 0, 1}}, 5, 5}; } inline matrix opt2(ull x) { return { {{1, 0, 0, 0, 0}, {0, 0, x, 0, 0}, {0, 0, 1, 0, 0}, {0, 0, 0, 0, x}, {0, 0, 0, 0, 1}}, 5, 5}; } ull a[maxn], b[maxn]; int n, m; struct Q { int l, r, id; } q[maxn]; inline int ls(int x) { return x * 2; } inline int rs(int x) { return x * 2 + 1; } inline void push_up(int x) { sum[x] = sum[ls(x)] + sum[rs(x)]; } inline void push_tag(int k, const matrix \u0026amp;x) { sum[k] = x \u0026amp; sum[k]; lzy[k] = x * lzy[k]; vis[k] = 1; } inline void push_down(int k) { if (!vis[k]) return; push_tag(ls(k), lzy[k]), push_tag(rs(k), lzy[k]); vis[k] = 0, lzy[k].init(); } void build(int l, int r, int k) { lzy[k].init(), lzy[k].n = lzy[k].m = 5; sum[k].n = 5, sum[k].m = 1; if (l == r) { sum[k].a[4][0] = 1, sum[k].a[3][0] = b[l], sum[k].a[2][0] = a[l], sum[k].a[1][0] = b[l] * a[l]; return; } int mid = (l + r) / 2; build(l, mid, ls(k)), build(mid + 1, r, rs(k)); push_up(k); } void modify(int l, int r, int x, int y, const matrix \u0026amp;v, int k) { if (l \u0026gt;= x \u0026amp;\u0026amp; r \u0026lt;= y) { push_tag(k, v); return; } push_down(k); int mid = (l + r) / 2; if (x \u0026lt;= mid) modify(l, mid, x, y, v, ls(k)); if (y \u0026gt; mid) modify(mid + 1, r, x, y, v, rs(k)); push_up(k); } ull query(int l, int r, int x, int y, int k) { if (l \u0026gt;= x \u0026amp;\u0026amp; r \u0026lt;= y) return sum[k][0][0]; push_down(k); int mid = (l + r) / 2; ull res = 0; if (x \u0026lt;= mid) res += query(l, mid, x, y, ls(k)); if (y \u0026gt; mid) res += query(mid + 1, r, x, y, rs(k)); return res; } ull ans[maxn]; void main() { read(n); for (int i = 1; i \u0026lt;= n; i++) read(a[i]); for (int i = 1; i \u0026lt;= n; i++) read(b[i]); read(m); for (int i = 1; i \u0026lt;= m; i++) read(q[i].l, q[i].r), q[i].id = i; sort(q + 1, q + 1 + m, [\u0026amp;](const Q \u0026amp;x, const Q \u0026amp;y) { return x.r != y.r ? x.r \u0026lt; y.r : x.l \u0026lt; y.l; }); int pos = 1; static int stk1[maxn], stk2[maxn], top1 = 0, top2 = 0; build(1, n, 1); for (int i = 1; i \u0026lt;= n; i++) { while (top1 \u0026amp;\u0026amp; a[stk1[top1]] \u0026lt; a[i]) top1--; while (top2 \u0026amp;\u0026amp; b[stk2[top2]] \u0026lt; b[i]) top2--; modify(1, n, stk1[top1] + 1, i, opt1(a[i]), 1); modify(1, n, stk2[top2] + 1, i, opt2(b[i]), 1); modify(1, n, 1, i, opt3, 1); stk1[++top1] = i, stk2[++top2] = i; while (pos \u0026lt;= m \u0026amp;\u0026amp; q[pos].r == i) ans[q[pos].id] = query(1, n, q[pos].l, i, 1), pos++; } for (int i = 1; i \u0026lt;= m; i++) write(ans[i]), endln(); } } bool MEM2; int main() { ios::sync_with_stdio(false), cin.tie(0); int id; read(id); solve::main(); } ","permalink":"https://luoyisu.github.io/posts/noip2022-solutions/","summary":"\u003cp\u003e还是比去年要难的。\u003c/p\u003e","title":"NOIP2022 Solutions"},{"content":"有人让我写，那我就写一下。\n一点题外话 本来打算把vp过程录个屏发到b站上的，但发现视频里有个人信息，就做罢了。\n要是还有下次用虚拟机打吧。\n”赛时“ 周日下午想着打一下吧，就开始娱乐了。\n其实之前已经有一些剧透了，所以就是个娱乐局，打的ioi赛制，在infoj上交的。\n看T1，想了10多分钟，好像对每一列记录一个 $\\Gamma$ 形状的数量，和二阶 $\\Gamma$ 形状（其实就是F）的数量就好了，利用行后缀转移，写了会就搞定了，交了一发过了。\n然后看T2，我听说这个题挺难的。\n想了一会也没啥头绪，只猜出来一个性质。然后觉得数据范围的 $k=2n-1$ 必有玄机，但还是没搞出来啥。\n又想了一会，感觉 $k=2n-2$ 好像很有玄机啊，想了几分钟会做了，每个栈都放两个就好了，然后就试图同样用空一列的思路做 $k=2n-1$，这下顺着想就做出来了，好像保证当前栈中元素没有多于 $3$ 个的，来一个新的时候就优先放已经有两个元素的栈（这两个元素要保证下面的在后面的队列里先出现，事实上，我们希望尽量多（或者说存在）两个元素的栈满足这个性质），因为如果有一个栈能放三个，就转成上一种情况，赢了。找不到就找一个下一个元素出现最晚的只有一个元素的栈放，这样出现早的不容易被盖住，如果还找不到就找一个空的放。（有很多地方是蒙的，进行感性理解）\n然后写了一会过了样例（用assert测试的），交了一发过了。\n然后T3，显然边双，然后树形dp。之前已经被剧透在虚树根处统计答案了，就 $f_i$ 表示 $i$ 为根子树各种选的方案数。考虑在最后乘上 $2^m$，转移 $f$ 和答案的时候每选一条边就要除以一个 $2$，硬转移，也就过了。\n不剩多少时间了（半个多小时？），想了想 T4 $O(qn)$ 怎么做，想了一会明白了 $O(qn\\log n)$ 的做法，就是枚举一个端点，线段树维护各个左端点的极值，然后更改哪些部分可以用单调栈找出来。没想清楚就开始狂写了，最后也没过（悲），还不清楚那里写挂了，应该不是区间赋值的简单线段树吧（\n最后 $100+100+100+0=300$，显然不是正式考试中会出现的分数。\n总结 真的很娱乐，考场上不一定会死磕前三题，能得多少分确实不好说。\n","permalink":"https://luoyisu.github.io/posts/noip2022/","summary":"\u003cp\u003e有人让我写，那我就写一下。\u003c/p\u003e","title":"NOIP2022 VP"},{"content":"换到了hugo。新博客框架，新开始。\n","permalink":"https://luoyisu.github.io/posts/hello-hugo-world/","summary":"换到了hugo。新博客框架，新开始。","title":"Hello Hugo World"},{"content":"初级字符串算法合集，预计内容包括：哈希、trie、kmp、manacher、z函数。\n缓慢填坑。\n哈希 哈希的分析 哈希实际上就是指把一个什么东西映射到一个比较小的值域上，设哈希函数为 $f(x)$，如果 $x=y$ 那么一定有 $f(x)=f(y)$，反之不一定成立。\n字符串哈希一般使用多项式哈希，选定一个底数 $b$ 和一个模数 $p$，$f(s)=\\sum_{i=1}^{len}s_i\\times b^{len-i}\\pmod p$\n底数一般选择大于值域的任意数，可以认为 $f(s),f(t)$ 冲突的概率大概为 $\\dfrac{len-1}{p}$。\n计算总哈希冲突概率是很简单的，如果发现冲突概率不低，可以对两个质数分别取模，相当于值域扩大到两者之积，大大减少冲突概率。\n因为取模常数较大，如果条件允许，也可以使用自然溢出，不取模。\n子串哈希 类似前缀和的思想，不难得到：$f(l\u0026hellip;r)=f(r)-f(l-1)\\times b^{r-l+1}$，可以做到 $O(1)$ 回答子串哈希。\n代码 使用自然溢出。\nfor (int i = 1; i \u0026lt;= n; i++) hash[i] = hash[i - 1] * base + s[i]; ull gethash(int l, int r) { return hash[r] - hash[l - 1] * mi[r - l + 1]; } 应用 很多和字符串相关的东西都依赖于判断相等，经常可以二分+哈希在单个 $\\log$ 的时间内解决。\ntrie 基本知识不说了，很简单。\n异或问题经常可以用到 01trie。\n各种 trie 都是支持合并的，类似线段树合并。\n01trie可以维护不少有关异或的信息。\n从低位到高位插入到trie中，通过维护一个点到其父亲这条边上被经过了几次可以轻松得到子树异或和，删除也可以这么做，还可以做到全局+/-1，以+1为例，只需要交换两个儿子，然后向0的那个儿子接着递归做即可。\nkmp（前缀函数） 前缀函数 $nxt_i$ 定义为前缀 $i$ 最长的相等的前后缀长度。\n求法就根据移动到下一个字符的时候，前缀函数要么不变、要么减小、要么增加 $1$，然后就往前跳求就可以了，因为总的增加是 $O(n)$，复杂度也就是 $O(n)$。\n代码 下标从 $1$ 开始。\nvoid get_nxt() { for (int i = 2, j = 0; i \u0026lt;= m; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j + 1]) j = nxt[j]; if ([i] == sj + 1]) j++; nxt[i] = j; } } 应用 主要应用还是这个定义。\n这里说一个方法：把字符串拼起来，可以正着拼、倒着拼、一个一个拼、中间加特殊字符等等，各种地方都能用的到。\n应用——字符串匹配 讲一个无脑的方法，假如要求 $t$ 在 $s$ 中的匹配，那么可以把 $s$ 和 $t$ 拼起来，构造一个 $str=t+\\#+s$，然后求前缀函数，$\\#$ 后面前缀函数等于 $|t|$ 就是一个匹配。\n最长周期 border：对字符串 $s$ 和 $0\u0026lt;r\u0026lt; |s|$，若 $s$ 长度为 $r$ 的前缀和长度为 $r$ 的后缀相等，就称 $s$ 长度为 $r$ 的前缀是 $s$ 的 border。\n由 $s$ 有长度为 $r$ 的 border 可以推导出 $|s| - r$ 是 $s$ 的周期。\n故最长周期长度是 $|s| - nxt_n$\nmanacher 如果要求回文串，可以求 $d_i$ 表示以 $i$ 为中心，最长的回文半径。\n显然二分+哈希可以做到 $O(n\\log n)$ 求解，但 manacher 算法让我们可以在线性时间内快速求出 $d$。\n具体方法就是：维护当前右端点最靠右的回文串 $[l,r]$，对于一个新的点 $i$， 如果 $i\\leq r$，那么把 $d_i$ 直接设置成 $\\min\\{r-i+1,d_{l+r-i}\\}$，这样显然是正确的，而每次这么处理完之后，都暴力扩展 $d_i$ 并更新 $l,r$。复杂度是对的，$r$ 从不减小。\n奇数回文串有中心，偶数没有，在相邻两个字符间加一个其他字符，就能让偶数也有中心。\n代码 for (int i = 1, r = 0, l = 0; i \u0026lt;= n; i++) { if (i \u0026lt;= r) d[i] = min(r - i + 1, d[l + r - i]); while (s[i - d[i]] == s[i + d[i]]) d[i]++; if (d[i] + i - 1 \u0026gt;= r) r = d[i] + i - 1, l = i - d[i] + 1; } z函数","permalink":"https://luoyisu.github.io/posts/string-algorithm-primary/","summary":"\u003cp\u003e初级字符串算法合集，预计内容包括：哈希、trie、kmp、manacher、z函数。\u003c/p\u003e\n\u003cp\u003e缓慢填坑。\u003c/p\u003e","title":"初级字符串算法合集"},{"content":"希望比去年强。\n初赛 之前啥都没看，中午还在写数学作业，直接就开考了。\n然后发现自己啥都不会了，随便蒙了蒙就润了。\n考完发现自己前面选择题似乎错了几个，后面那个负数取模不会啊，感觉三个选择题都错了。\n那个基数排序的判断题我理解错题意了好像也错了。\n太摆了，不过辽宁有分就行，润了。\n出分了，88，比我想的高不少，很离谱啊。。。\n第二轮 被迫去沈阳考试，很烦，不过去了也就去了。\n前几天在酒店也没干啥，打了场模拟挂了好多好多分。\n然后就考了，也没啥可说的，被第一题降智了几分钟，第二题倒是看了一眼就会了。\n第三题一直在想图论，充要条件没想明白，没想到哈希。\n第四题一眼dp，又一眼可以用矩阵刻画的dp，再看一下是树，那就动态dp啊，然后发现是静态的，但是我完全想不起来倍增这个东西，也写不出来树剖了。\n写了第三题的 $40$ 分，打算等写完第四题的 $52$ 分暴力回来写第三题的 $20$ 分，然后再去写第三题的 $k=2$。\n然后因为水平太低第四题的 $n^2$ 一直调不过去，最后终于调过去了也没时间写别的了，$100+100+40+44=288$ 遗憾离场，没啥水平。\n后来测了一下前两题的民间数据，没挂，那还不错。\n再测了一下，好像在哪里我都是 $308$，第四题我的做法是 $qd$ 的，可以过数据随机，小图灵说我是全省第三，infoj说是第二。\n发布获奖名单后 发现自己虽然分不咋高，但还是混到了全省 rank2，令人感慨。\n沈阳的几位老哥还是很有实力的！我们学校的也很有实力！但还是看看远方的noip吧家人们（\n","permalink":"https://luoyisu.github.io/posts/csp-s2022/","summary":"\u003cp\u003e希望比去年强。\u003c/p\u003e","title":"CSP-S2022"},{"content":"一个很简单的“禁术”。\nRMQ 设序列长度为 $n$。\n对序列分块，每块长度 $\\log_2n$，块数 $n/\\log_2n$，记录每块最大值，用 st 表预处理出块件最大值，这一步复杂度为 $O(n)$。\n预处理出每一块前后缀最大值，这样当询问的两个端点不在同一个块内，就可以 $O(1)$ 回答了。\n现在要处理询问端点在一个块内的情况。\n对于一个块的所有前缀，维护一个递减的单调栈，并记录哪些元素在单调栈里（用一个整数状压存储）。\n这样 $[l,r]$ 的最大值位置就是前缀 $r$ 的单调栈中第一个在原数组中下标大于等于 $l$ 的位置，即第 $l$ 位后第一个 $1$。\nCode 使用了常数略大的写法，为了卡常可以在预处理的时候把多个循环合并为一个。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; bool MEM1; namespace solve { const int maxn = 2e7 + 3; int len; int f[25][maxn / 24 + 7]; int pre[maxn], suf[maxn], id[maxn], idn, s[maxn]; int pos[maxn], lg[maxn]; int n, a[maxn], q; void init() { len = __lg(n); lg[0] = -1; id[0] = -1; static int stk[30], top; for (int i = 1; i \u0026lt;= n; i++) { lg[i] = lg[i \u0026gt;\u0026gt; 1] + 1; id[i] = (i - 1) / len + 1; if (id[i] == id[i - 1]) pos[i] = pos[i - 1] + 1; else pos[i] = 0; f[0][id[i]] = max(f[0][id[i]], a[i]); } idn = id[n]; for (int i = 1; i \u0026lt;= lg[idn]; i++) for (int j = 1; j + (1 \u0026lt;\u0026lt; i) - 1 \u0026lt;= idn; j++) f[i][j] = max(f[i - 1][j], f[i - 1][j + (1 \u0026lt;\u0026lt; (i - 1))]); for (int i = 1; i \u0026lt;= n; i++) if (id[i] != id[i - 1]) pre[i] = a[i]; else pre[i] = max(pre[i - 1], a[i]); for (int i = n; i \u0026gt;= 1; i--) if (id[i] != id[i + 1]) suf[i] = a[i]; else suf[i] = max(suf[i + 1], a[i]); for (int i = 1; i \u0026lt;= n; i++) { if (id[i] != id[i - 1]) top = 0; else s[i] = s[i - 1]; while (top \u0026amp;\u0026amp; a[stk[top]] \u0026lt;= a[i]) s[i] ^= 1 \u0026lt;\u0026lt; pos[stk[top--]]; s[i] |= 1 \u0026lt;\u0026lt; pos[stk[++top] = i]; } } inline int query(int l, int r) { int idl = id[l], idr = id[r]; if (idl != idr) { int ans = max(suf[l], pre[r]); if (idr - idl \u0026gt; 1) { int d = lg[idr - idl - 1]; ans = max(ans, max(f[d][idl + 1], f[d][idr - (1 \u0026lt;\u0026lt; d)])); } return ans; } else return a[l + __builtin_ctz(s[r] \u0026gt;\u0026gt; pos[l])]; } void main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; init(); while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; query(l, r) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } bool MEM2; int main() { ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve::main(); } ","permalink":"https://luoyisu.github.io/posts/linear-rmq/","summary":"\u003cp\u003e一个很简单的“禁术”。\u003c/p\u003e","title":"基于状压的 O(n)-O(1) rmq"},{"content":"D类选手，因为一些原因打铁了。\n只写一些和比赛关系比较大的事情，乱七八糟的就不写了。\n赛前 对自己的定位是有点水平的D类选手，挂一些分也能到ag线（后来证明定位还算准？）。\n模拟赛经常当一题战士，不过不怎么挂分来着，感觉优势很大。\nbefore day1 打牌、tetr、没干啥有意义的事情。\nday1 —— 最黑暗的一天 上午 感觉状态还不错。\n然后看到题，发现 T3 是个交互、而且题面巨长、T2 是个计数、T1 看起来就是传统的送分 ds。\n还是看看 T1，过了一会编了个线段树合并做法，发现可能拿不到 100，但是稍微特判一些性质 80 是很稳的，直接开始写了。\n写起来有点自闭，先写了个不带删除的版本，测了测发现似乎真的过不去 100，打算优化一下，但是离谱的事情发生了：我用一份暴力代码把我的线段树合并覆盖掉了，只能重新写代码。。。然后飞快又写了一份，离大谱的是我又犯了同样的错误覆盖了代码。只能又写了一份。。\n然后试图把删除加上去，重打代码的时候想到了一个非常好写的启发式合并 deque 的做法，感觉非常牛逼，就给写上去了。\n我用了 vector 和 deque，我知道这俩玩意占用空间巨大（尤其是 deque），于是我留了近 400MB 给他们用。\n因为浪费了太多时间，没时间优化也没时间对拍了，我决定扔掉 T1 去看后面的题。\n然后发现 T2 如果会判合法就能获得 40 分，但是我想了很久很久还是不会，很尴尬啊。。。\n然后去看了 T3，认真读完题之后发现这个题真的不怎么可做，链看上去是一个比较容易拿到的 10 分，我编了一个线段树做法，然后发现限制很严格，线段树寄了。\n然后回去想 T2，想了想还是不会啊，搜索也不怎么想写了。。。\n最后 10 分钟忽然想到 T3 的链可以直接分块做，但是没有 rush 出来，只能遗憾离场，分数大概是 $[80,100]+0+0$，应该也没有非常差。\n交流了一圈，发现大家都不会后两题，T2 只有范神拿到了 40，那好像还可以。\n下午 —— 心肺骤停 快乐查分，然后发现我 T1 爆零了，全部 wrong answer，很离谱啊！！！\n测了一下数据，是对的，打算申诉来着，然后发现这似乎是个共性问题。\n然后发现是 MLE 了，被显示成 wrong answer，然后发现是 std::deque 即使是空的也会申请大概 0.6k 内存，然后我就寄了，这下真爆零了。。。。。\n心肺骤停啊，沉默不语，非常自闭，本来至少 80 的。。。这下不是真要打铁了？？？？？\n只能等 day2 了，没办法，好好考吧。\nthe day after day1, before day2 摸鱼，调整心情。\nday2 —— 以为翻了，但还是寄了 上午 直接看 T1，树哈希？这我会啊，模拟赛前几天刚考。\n然后编了个做法，没细想，过了样例，感觉复杂度挺对的就快速跑路了，今天打算激进一点，让期望得分尽可能高。\n看了眼 T3，感觉非常不可做。\n看 T2，想了想，对着性质 A 编了一会做法。一开始想的是把每个点的限制放到最左面，然后枚举分界点前面填 0、后面填 1，发现过不去样例。思考了一下把两个结论都换掉了，变成从后往前贪心填让逆序对增加最小的数，然后过了样例，我也没仔细想，拼了个搜索上去，接着优化了一下复杂度，现在 T2 能得到 48 分。\n去看 T3，想了一下没啥思路，限制很奇怪，写了个搜索，能得到 17~23 分。想了一下 $k=3$ 的部分，感觉只填 2 就可以，但感觉不是非常对，而且只有 6 分，就没写，跑路了。\n回去想 T2，B 性质是没有限制，想了一下是不是也可以从后到前贪心填，但想了一下感觉有点像对的，又有点不对，也没什么时间验证了。\n然后就一直自闭到结束，期望 $100+48+17=165$，ag 应该是寄了，但 cu 还是很有希望的。\n下午 —— 心肺骤停*2 发现 T1 挂成 76，T3 爆零。\nT1 挂我不是非常意外，毕竟猜的结论我没证明，应该枚举全排列匹配的。\nT3 就不是很懂了，看了一下，错的点都输出了 0，看来是搜挂了。。。\n这下变成 124 了，不知道是 fe 还是 cu。。。\n交流了一下，发现我 T2 猜的结论是对的。。。就是把限制放在最左面然后从后向前贪心填。。。那我不是自大闭。。\nday？ 打铁了，乐。\n总结 遇到结论不会证明可以敲代码验证，但我总是缺少这么做的时间，得提高思考速度和手速。\n然后不懂的东西还是少用，学什么东西深入一点，还来得及。\n大赛对我似乎确实是有降智的debuff，但还是看开点，感觉这场 noi 已经发挥不错了，虽然挂的分比得的分多，但总的来说还可以，被 deque 阴了一手没办法。\n下个赛季再战吧，别进不去省队然后耻辱退役。\n","permalink":"https://luoyisu.github.io/posts/noi2022/","summary":"\u003cp\u003eD类选手，因为一些原因打铁了。\u003c/p\u003e\n\u003cp\u003e只写一些和比赛关系比较大的事情，乱七八糟的就不写了。\u003c/p\u003e","title":"NOI2022 游记"},{"content":"填完了。\nT1 food Description 有 $n$ 个食物，每个食物有 $a_i,b_i$ 两个参数。你的初始质量为 $1$，可以以任意顺序吃这些食物，吃掉一个食物之后，你的质量可以加 $b_i$，或者乘上 $a_i$，最大化质量。\nSolution 首先肯定是先加后乘；\n然后 $a=1$ 肯定加。\n然后剩下的食物里，加只会进行一次，因为如果加多次，调整为只加最大的，剩下的乘是不劣的。\n假设加上 $a=1$ 的质量为 $now$，那么把一个数从乘变成加会让全都乘的答案 $ans$ 变为 $ans\\times\\dfrac{b+now}{a\\times now}$，扫一遍找到右边比例的最大值就好了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; namespace solve { const int maxn = 1e6 + 10; const int mod = 1e9 + 7; typedef long long ll; ll now = 1; struct node { int a, b; inline double f() { return (b + now) / (long double)1. / ((long double)a * now); } } a[maxn]; int vis[maxn]; int n; void main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i].a; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i].b; for (int i = 1; i \u0026lt;= n; i++) if (a[i].a == 1) now += a[i].b, vis[i] = 1; double d = 1; int pos = -1; for (int i = 1; i \u0026lt;= n; i++) { if (vis[i]) continue; if (a[i].f() \u0026gt;= d) pos = i, d = a[i].f(); } if (pos == -1) { now %= mod; for (int i = 1; i \u0026lt;= n; i++) if (!vis[i]) now *= a[i].a, now %= mod; cout \u0026lt;\u0026lt; now \u0026lt;\u0026lt; endl; } else { now += a[pos].b, now %= mod; for (int i = 1; i \u0026lt;= n; i++) if (!vis[i] \u0026amp;\u0026amp; i != pos) now *= a[i].a, now %= mod; cout \u0026lt;\u0026lt; now \u0026lt;\u0026lt; endl; } } } int main() { ios::sync_with_stdio(false); solve::main(); } T2 problem Description 给定长度为 $3 n$、值域为 $[0, 3]$ 的整数序列 $S = s_1 s_2 \\cdots s_{3 n}$。你需要首先将 $S$ 中的每个 $0$ 替换为 $[1, 3]$ 中的任意一个整数，得到序列 $T = t_1 t_2 \\cdots t_{3 n}$，然后给出 $n$ 个长度为 $3$ 的整数序列 ${\\{ a_{i, 1}, a_{i, 2}, a_{i, 3} \\}}_{1 \\le i \\le n}$，使得\n$\\forall 1 \\le i \\le n$，$1 \\le a_{i, 1} \u0026lt; a_{i, 2} \u0026lt; a_{i, 3} \\le 3 n$； $\\forall (i_1, j_1) \\ne (i_2, j_2)$，$a_{i_1, j_1} \\ne a_{i_2, j_2}$； $\\forall 1 \\le i \\le n$，$\\{ t_{a_{i, 1}}, t_{a_{i, 2}}, t_{a_{i, 3}} \\}$ 是 $\\{ 1, 2, 3 \\}$ 的一个排列且逆序对数为奇数。 认为两个方案本质不同当且仅当序列 $T$ 不同或存在 $a_{i, j}$（$1 \\le i \\le n$，$1 \\le j \\le 3$）不同，求以上操作的本质不同的方案数，对 $({10}^9 + 7)$ 取模。\n$n\\leq19$。\nSolution 逆序对数是奇数，也就是说只有 $(1,3,2),(2,1,3),(3,2,1)$ 三种情况。\n题目的要求相当于我们把 $3n$ 个数分到 $n$ 个三元组里，不难想到一个 dp：\n$g(i,a,b,c,d,e,f)$ 表示当前 $T$ 填了前 $i$ 位，当前为 $(1),(2),(3)$ 的三元组分别有 $a,b,c$ 个；当前为 $(1,3),(2,1),(3,2)$ 的三元组分别有 $d,e,f$ 个的方案数。\n这里我们不考虑 $n$ 个三元组的顺序，方案数为 $g(3n,0,0,0,0,0,0)$，再乘上 $n!$ 即可。\n转移的时候就枚举这这一位填什么，分到哪个三元组里，乘一个系数转移就好了。\n复杂度看似是 $O(n^7)$，但是我们只考虑能转移到最终状态的状态进行转移，比如说 $g(i,n,2,0,0,0,0)$ 这种状态显然就没有意义。多考虑一些类似的状态，状态数会减少很多，可以很快地通过本题。\n如果你采用只存合法状态进行转移的方式，我估计会非常快（\nCode 注意空间需要滚动数组。\n这里放一份当前最优解的代码，是一位拒绝透露姓名的神仙在我代码的基础上进行了一波常数优化得到的（\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; constexpr int mod = 1000000007; typedef long long ll; namespace solve { const int maxn = 59; const int maxm = 20; #define upd(x, y) ((x) = (((x) + (y)) % (mod))) int g[2][maxm][maxm][maxm][maxm][maxm][maxm]; char str[maxn]; int n; void main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; (str + 1); g[0][0][0][0][0][0][0] = 1; int cur = 1; for (int i = 1; i \u0026lt;= n * 3; i++) { auto\u0026amp;\u0026amp; res(n * 3 - i + 1); for (int a = 0; 2 * a \u0026lt;= res \u0026amp;\u0026amp; a \u0026lt;= i; a++) for (int b = 0; 2 * a + 2 * b \u0026lt;= res \u0026amp;\u0026amp; a + b \u0026lt;= i; b++) for (int c = 0; 2 * a + 2 * b + 2 * c \u0026lt;= res \u0026amp;\u0026amp; a + b + c \u0026lt;= i; c++) for (int d = 0; 2 * a + 2 * b + 2 * c + d \u0026lt;= res \u0026amp;\u0026amp; a + b + c + 2 * d \u0026lt;= i; d++) for (int e = 0; 2 * a + 2 * b + 2 * c + d + e \u0026lt;= res \u0026amp;\u0026amp; a + b + c + 2 * d + 2 * e \u0026lt;= i; e++) for (int f = 0; 2 * a + 2 * b + 2 * c + d + e + f \u0026lt;= res \u0026amp;\u0026amp; a + b + c + 2 * d + 2 * e + 2 * f \u0026lt;= i; f++) if (g[cur ^ 1][a][b][c][d][e][f]) { int\u0026amp;\u0026amp; tmp(2 * a + 2 * b + 2 * c + d + e + f), fxj(a + b + c + d + e + f); auto const\u0026amp; now = str[i]; ll const\u0026amp; lst = g[cur ^ 1][a][b][c][d][e][f]; if (now == \u0026#39;1\u0026#39; || now == \u0026#39;0\u0026#39;) { if (a \u0026lt; n \u0026amp;\u0026amp; tmp + 2 \u0026lt;= res - 1 \u0026amp;\u0026amp; fxj \u0026lt; n) upd(g[cur][a + 1][b][c][d][e][f], lst); if (c \u0026gt; 0 \u0026amp;\u0026amp; f \u0026lt; n) upd(g[cur][a][b][c - 1][d][e][f + 1], lst * c); if (e \u0026gt; 0) upd(g[cur][a][b][c][d][e - 1][f], lst * e); } if (now == \u0026#39;2\u0026#39; || now == \u0026#39;0\u0026#39;) { if (c \u0026lt; n \u0026amp;\u0026amp; tmp + 2 \u0026lt;= res - 1 \u0026amp;\u0026amp; fxj \u0026lt; n) upd(g[cur][a][b][c + 1][d][e][f], lst); if (b \u0026gt; 0 \u0026amp;\u0026amp; e \u0026lt; n) upd(g[cur][a][b - 1][c][d][e + 1][f], lst * b); if (d \u0026gt; 0) upd(g[cur][a][b][c][d - 1][e][f], lst * d); } if (now == \u0026#39;3\u0026#39; || now == \u0026#39;0\u0026#39;) { if (b \u0026lt; n \u0026amp;\u0026amp; tmp + 2 \u0026lt;= res - 1 \u0026amp;\u0026amp; fxj \u0026lt; n) upd(g[cur][a][b + 1][c][d][e][f], lst); if (a \u0026gt; 0 \u0026amp;\u0026amp; d \u0026lt; n) upd(g[cur][a - 1][b][c][d + 1][e][f], lst * a); if (f \u0026gt; 0) upd(g[cur][a][b][c][d][e][f - 1], lst * f); } g[cur ^ 1][a][b][c][d][e][f] = 0; } cur ^= 1; } ll ans = g[cur ^ 1][0][0][0][0][0][0]; for (ll i = 1; i \u0026lt;= n; ++i) ans = ans * i % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; int res = 3 * n; for (int a = 0; a \u0026lt;= n \u0026amp;\u0026amp; 2 * a \u0026lt;= res; a++) for (int b = 0; a + b \u0026lt;= n \u0026amp;\u0026amp; 2 * a + 2 * b \u0026lt;= res; b++) for (int c = 0; a + b + c \u0026lt;= n \u0026amp;\u0026amp; 2 * a + 2 * b + 2 * c \u0026lt;= res; c++) for (int d = 0; a + b + c + d \u0026lt;= n \u0026amp;\u0026amp; 2 * a + 2 * b + 2 * c + d \u0026lt;= res; d++) for (int e = 0; a + b + c + d + e \u0026lt;= n \u0026amp;\u0026amp; 2 * a + 2 * b + 2 * c + d + e \u0026lt;= res; e++) for (int f = 0; a + b + c + d + e + f \u0026lt;= n \u0026amp;\u0026amp; 2 * a + 2 * b + 2 * c + d + e + f \u0026lt;= res; f++) g[1][a][b][c][d][e][f] = g[0][a][b][c][d][e][f] = 0; } } int main() { ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) solve::main(); } T3 box Description 有 $n$ 个不同的盒子排成一排。在初始状态下，第 $i$ 个盒子放有 $a_i$ 个货物，总货物数量为 $S = \\sum_{i = 1}^{n} a_i$。对于非负整数数组 $(b_1, b_2, \\ldots, b_n)$ 满足 $\\sum_{i = 1}^{n} b_i = S$，考察以下问题：\n你想让第 $i$ 个盒子中拥有恰好 $b_i$ 个货物，为此你可以做如下操作若干次：对两个相邻的盒子，把其中一个盒子的恰好一个货物移动至另一个。对 $i, i + 1$（$1 \\le i \u0026lt; n$）号盒子做一次操作的代价为 $w_i$。你需要保证在操作中不存在盒子中的货物数量是负数。\n在以上问题下，定义从初始状态达到第 $i$ 个盒子拥有恰好 $b_i$ 个货物的状态的最小代价为 $\\operatorname{val}(b_1, b_2, \\ldots, b_n)$，你需要求出对所有满足 $\\sum_{i = 1}^{n} b_i = S$ 的非负整数数组 $(b_1, b_2, \\ldots, b_n)$，$\\operatorname{val}(b_1, b_2, \\ldots, b_n)$ 的和。输出这个答案对 $998244353$ 取模后的结果。\nSolution 不会的数学题，越学越认识到自己垃圾的数学水平\u0026hellip;\n感觉是一篇详细的题解。\n我们对每条边算出其对答案的贡献，设 $s_i=\\sum_{j=1}^ia_j,S=s_n$，枚举 $j=\\sum_{k=1}^ib_k$，那么方案数为前 $i$ 个盒子里放 $j$ 个货物的方案数乘上后 $n-i$ 个盒子里放 $S-j$ 个货物的方案数，这里盒子可以为空，用插板法搞一下就可以得出答案的式子： $$ ans=\\sum_{i=1}^n w_i\\sum_{j=0}^S|j-s_i|\\binom{i+j-1}{i-1}\\binom{n-i+S-j-1}{n-i-1} $$ 我们主要关心第二个求和式子。\n绝对值显然不好搞，给拆掉，然后把少加的部分补进去。 $$ \\begin{aligned} \u0026amp;\\sum_{j=0}^S|j-s_i|\\binom{i+j-1}{i-1}\\binom{n-i+S-j-1}{n-i-1}\\\\ =\u0026amp;\\sum_{j=0}^{S}(j-s_i)\\binom{i+j-1}{i-1}\\binom{n-i+S-j-1}{n-i-1}+2\\sum_{j=0}^{s_i}(s_i-j)\\binom{i+j-1}{i-1}\\binom{n-i+S-j-1}{n-i-1} \\end{aligned} $$ 这里 $j=s_i$ 的项为了方便在两边都算进去了，反正是 $0$ 不影响。\n前面和后面的形式是相同的，后一个显然更强一些（因为有循环上界的限制），我们先考虑后一个式子。把后一个求和式子拆开，我们关心的是： $$ s_i\\sum_{j=0}^{s_i}\\binom{i+j-1}{i-1}\\binom{n-i+S-j-1}{n-i-1}-\\sum_{j=0}^{s_i}j\\binom{i+j-1}{i-1}\\binom{n-i+S-j-1}{n-i-1} $$ 想要把这两个式子统一起来，后一个求和式子的 $j$ 要想办法换成一个常数移到外面来，有 $$ j\\binom{i+j-1}{i-1}=j\\times\\frac{(i+j-1)!}{(i-1)!j!}=i\\times\\frac{(i+j-1)!}{i!(j-1)!}=i\\binom{i+j-1}{i} $$ 这样后面的式子就变成 $$ i\\sum_{j=0}^{s_i}\\binom{i+j-1}{i}\\binom{n-i+S-j-1}{n-i-1} $$ 已经基本统一了，但是具体的加一/减一上还需要稍微凑一下，为了方便我们设 $$ f(n,s,i,k)=\\sum_{j=0}^k\\binom{i+j-1}{i-1}\\binom{n-i+s-j-1}{n-i-1} $$ 观察一下，想让 $\\dbinom{i+j-1}{i}$ 对上 $\\dbinom{i+j-1}{i-1}$ 这一项，$i$ 需要对应 $i-1$，那组合数上面的 $j$ 就得对应 $j+1$，因此我们对刚刚后面的式子进行一个小调整，枚举原来的 $j-1$，这样就变为： $$ i\\sum_{j=0}^{s_i-1}\\binom{i+j}{i}\\binom{n-i+S-j}{n-i-1} $$ 这样就能一一凑上了，上式等于 $i\\times f(n+1,s-1,i+1,k-1)$。\n把 $f$ 带回最开始的式子，对于每个 $i$，我们要求出： $$ i\\times f(n+1,S-1,i+1,S-1)-s_i\\times f(n,S,i,S)+2\\times f(n,S,i,s_i)-2i\\times f(n+1,S-1,i+1,s_i-1) $$ 注意到 $i$ 和 $s_i$ 都是不降的，那么问题就变为：已知 $f(n,s,i,k)$，要快速求出 $f(n,s,i+1,k),f(n,s,i,k+1)$。\n$f(n,s,i,k+1)$ 直接根据 $f$ 的定义求就好了，难的是 $i$ 的增加。\n我是推不动，这里回到组合意义就很神仙，考虑 $f$ 的组合意义，是总共有 $n$ 个盒子，$s$ 个货物要放到这些盒子里，前 $i$ 个盒子最多放 $k$ 个货物的方案数。怎么理解呢？就是枚举前 $i$ 个盒子放几个货物，同样插板法。\n我们需要一个枚举盒子的组合意义，换个思路，等价于第 $k+1$ 个货物所在的盒子大于 $i$。枚举这个盒子 $j$，方案数为前 $j$ 个盒子放 $k$ 个货物的方案数乘上后 $n-j+1$ 个盒子放 $S-k-1$ 个货物的方案数，同样插板法，式子就是： $$ f(n,s,i,k)=\\sum_{j=i+1}^n\\binom{j+k-1}{j-1}\\binom{n-j+s-k-1}{n-j} $$ 这个就可以随着 $i$ 的变化 $O(1)$ 维护了。\n把四个 $f$ 分别维护，就做完了，好耶！\nCode namespace solve { const int maxn = 3e6 + 10; const int mod = 998244353; typedef long long ll; ll qpow(ll a, ll x, ll p) { ll res = 1; for (; x; x \u0026gt;\u0026gt;= 1, a = a * a % p) if (x \u0026amp; 1) res = res * a % p; return res; } ll fac[maxn], ifac[maxn]; int n; void init(int n = 3e6) { fac[0] = 1; for (int i = 1; i \u0026lt;= n; i++) fac[i] = fac[i - 1] * i % mod; ifac[n] = qpow(fac[n], mod - 2, mod); for (int i = n - 1; i \u0026gt;= 0; i--) ifac[i] = ifac[i + 1] * (i + 1) % mod; } inline ll C(int n, int m) { return m \u0026gt; n || m \u0026lt; 0 || n \u0026lt; 0 ? 0 : fac[n] * ifac[m] % mod * ifac[n - m] % mod; } int sum[maxn], w[maxn]; int S; inline ll f(int n, int S, int i, int k) { ll res = 0; for (int j = 0; j \u0026lt;= k; j++) (res += C(i + j - 1, i - 1) * C(n - i + S - j - 1, n - i - 1) % mod) %= mod; return res; } struct func { int n, s, i, k; ll res; void init(int n_, int s_, int i_, int k_) { n = n_, s = s_, i = i_, k = k_; res = 0; for (int j = 0; j \u0026lt;= k; j++) res += C(i + j - 1, i - 1) * C(n - i + s - j - 1, n - i - 1) % mod; res %= mod; } void movek(int nk) { if (nk \u0026lt;= k) return; for (int j = k + 1; j \u0026lt;= nk; j++) res += C(i + j - 1, i - 1) * C(n - i + s - j - 1, n - i - 1) % mod; res %= mod; k = nk; } void movei(int ni) { if (ni \u0026lt;= i) return; for (int j = i + 1; j \u0026lt;= ni; j++) res -= C(j + k - 1, j - 1) * C(n - j + s - k - 1, n - j) % mod; res %= mod; i = ni; } } f1, f2, f3, f4; void main() { n = read(); for (int i = 1; i \u0026lt;= n; i++) sum[i] = sum[i - 1] + read(); for (int i = 1; i \u0026lt; n; i++) w[i] = read(); ll ans = 0; S = sum[n]; f1.init(n + 1, S - 1, 1, S - 1), f2.init(n, S, 1, S); f3.init(n, S, 1, 0), f4.init(n + 1, S - 1, 1, -1); for (int i = 1; i \u0026lt; n; i++) { ll res = 0; f3.movek(sum[i]), f4.movek(sum[i] - 1); f1.movei(i + 1), f2.movei(i), f3.movei(i), f4.movei(i + 1); res += i * f1.res % mod; res -= sum[i] * f2.res % mod; res += 2 * sum[i] * f3.res % mod; res -= 2 * i * f4.res % mod; res %= mod; ans += w[i] * res % mod, ans %= mod; } cout \u0026lt;\u0026lt; (ans + mod) % mod \u0026lt;\u0026lt; endl; } } int main() { int T; cin \u0026gt;\u0026gt; T; solve::init(); while (T--) solve::main(); } T4 string Description 给定一个英文小写字母构成的字符串 $S$，你需要找到一个尽可能长的字符串序列 $(T_0, T_1, \\ldots, T_l)$，满足：\n$T_0$ 是 $S$ 的子串； $\\forall 1 \\le i \\le l$，$\\lvert T_i \\rvert - \\lvert T_{i - 1} \\rvert = 1$； $\\forall 1 \\le i \\le l$，存在 $S$ 的一个长度为 $\\lvert T_i \\rvert + 1$ 的子串 $S_i\u0026rsquo;$，使得 $S_i\u0026rsquo;$ 的长度为 $\\lvert T_{i - 1} \\rvert$ 的前缀为 $T_{i - 1}$，长度为 $\\lvert T_i \\rvert$ 的后缀为 $T_i$。 输出这样的字符串序列的长度的最大值（即 $l$ 的最大值）。\nSolution 一个思路很清奇的题目，乍一看以为和19年省选的那个字符串问题差不多，其实完全没关系。\n观察一下这个字符串序列，逆向去想一下，可以这么构造：$[i,j]\\rightarrow[i-1,j-2]\\rightarrow[i-2,j-4]\u0026hellip;$ 一直这样下去直到长度为 $0$ 或者到头了。那么答案就有一个显然的下界 $\\lfloor n/2\\rfloor$。\n然后上面这个构造的瓶颈在于走到头就没得走了，我们需要考虑什么时候可以往后跳回去。\n然后就是比较重要的性质了：一个串可以往回跳的充要条件是出现了至少两次。\n假设出现位置是 $[i_1,j_1],i_2,j_2$，那么我们从 $[i_2,j_2]$ 开始，按照上述的构造方法构造，当左端点到 $i_1$ 时，我们跳回到 $i_2$ 即可。\n反过来的话就是如果只出现一次，那么这个串对应的 $S_i\u0026rsquo;$ 是唯一的，别的跳不回来。\n这样就很简单了，如果可以往回跳那么我们从 $[i_2,j_2]$ 开始一路跳就可以跳到长度为 $0$。\n对于一个出现至少两次的串 $[l,r]$，若选择它作为跳的开始，答案为 $r-l+1+\\lfloor(n-r)/2\\rfloor$。\n我们求出以每个下标为右端点的最长的出现至少两次的串，取个 max。\n这个事情用 SAM 搞一搞就可以做，就对于每个节点记录最靠左的位置和 siz 就好了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; namespace solve { const int maxn = 2e6 + 10; int n; struct SAM { int mx[maxn], siz[maxn], ch[maxn][26], father[maxn], pos[maxn]; int lst, tot; int ans; void insert(int c, int id) { int p = ++tot, f = lst; siz[p] = 1, mx[p] = mx[f] + 1, lst = p, pos[p] = id; while (f \u0026amp;\u0026amp; !ch[f][c]) ch[f][c] = p, f = father[f]; if (!f) father[p] = 1; else { int q = ch[f][c]; if (mx[q] == mx[f] + 1) father[p] = q; else { int nq = ++tot; memcpy(ch[nq], ch[q], sizeof(ch[q])), father[nq] = father[q], mx[nq] = mx[f] + 1; pos[nq] = n + 1; father[p] = father[q] = nq; while (f \u0026amp;\u0026amp; ch[f][c] == q) ch[f][c] = nq, f = father[f]; } } } vector\u0026lt;int\u0026gt; e[maxn]; void build() { for (int i = 2; i \u0026lt;= tot; i++) e[father[i]].push_back(i); } void dfs(int x) { for (int v : e[x]) { dfs(v); siz[x] += siz[v], pos[x] = min(pos[x], pos[v]); } if (siz[x] \u0026gt; 1) ans = max(ans, (n - pos[x]) / 2 + mx[x]); } void clear() { for (int i = 1; i \u0026lt;= tot; i++) e[i].clear(), memset(ch[i], 0, sizeof(ch[i])); memset(father, 0, sizeof(int) * (tot + 4)); memset(mx, 0, sizeof(int) * (tot + 4)); memset(siz, 0, sizeof(int) * (tot + 4)); memset(pos, 0, sizeof(int) * (tot + 4)); lst = tot = 1; ans = 0; } SAM() { lst = tot = 1; } } sam; char s[maxn]; void main() { cin \u0026gt;\u0026gt; s; n = strlen(s); for (int i = 0; i \u0026lt; n; i++) sam.insert(s[i] - \u0026#39;a\u0026#39;, i + 1); sam.build(), sam.dfs(1); cout \u0026lt;\u0026lt; max(sam.ans, n / 2) \u0026lt;\u0026lt; endl; sam.clear(); } } int main() { ios::sync_with_stdio(false); int T; cin \u0026gt;\u0026gt; T; while (T--) solve::main(); } ","permalink":"https://luoyisu.github.io/posts/lnoi2022-solution/","summary":"\u003cp\u003e填完了。\u003c/p\u003e","title":"LNOI2022 Solutions"},{"content":"LNOI2022 单看省选成绩是第七名，算上 NOIP 就是第十名左右，翻盘失败。\nDay1 下午 直接进入考试吧，前面没啥可说的。\n看到 A，看上去是一个贪心，想了一会不会，乱写了一个贪心，过了所有样例。\n根据经验这种定位的题即使贪心错了也不会丢掉太多分，我决定就当我过了。\n这时候过了半个小时。\n看第二题，想了一会发现可以直接记录 1、2、3、13、21、32、合法 这七种三元组有几个，先不考虑顺序，最后乘上 $n!$。复杂度 $O(n^8)$，想了下感觉记录合法三元组不必要，就 $O(n^7)$ 了，可以得到 $80\\sim100$ 分。\n然后就写了一个，但是过不去样例，想了半天也不懂。。\n上了个厕所冷静一下，回来过了一会就意识到转移没加上系数。\n然后把系数加上了，但是同时多记了一维合法的个数，复杂度又变回 $O(n^8)$ 了。\n然后没细想能不能优化，稍微优化了一下常数，发现能过 $60$ 分，就先放着了。\n大概过了两个小时？\n去看第三题，想了半天还是只会 $20$，大概已经不太能冷静思考了。。后面的特殊性质大概是什么组合数吧。\n看了看第四题，往一些字符串算法上套了一下没啥结果，哈希表搞一搞能得个 $40$。\n然后写第三题，中途还挂了，我这啥代码能力啊。\n好不容易调出来了，急忙去写 T4，然后写了一半多没时间了只能遗憾离场。\n我这啥代码能力啊。。\n然后出了考场准备回家的时候忽然意识到 T2 怎么做。。其实就是一样的思路，不记录合法三元组个数，最后乘上阶乘。\n。。。。白给了 $40$ 分。。。\nT4 也白给了 $40$ 分。。\nDay1 晚 $85+50+20+0=155$，比想的略低，但也在意料之中。\n怎么说呢，T2、T4 都很遗憾。\n大概算了一下，想进队线需要得到 T4 的 $40$ 分，而想进队需要得到 $95$ 分。。\n怎么说呢，T2 这种题我现在会做也挺惊讶的，放到 NOIP 肯定是完全不会做的。。\n行吧行吧，进步是有的，但还是题做少了。\n","permalink":"https://luoyisu.github.io/posts/lnoi2022/","summary":"\u003ch1 id=\"lnoi2022\"\u003eLNOI2022\u003c/h1\u003e\n\u003cp\u003e单看省选成绩是第七名，算上 NOIP 就是第十名左右，翻盘失败。\u003c/p\u003e","title":"LNOI2022"},{"content":"不给出题目链接了，网上可以找到（推荐vjudge）。\nBZOJ4292 Rownanie Description 对于一个正整数 $n$，定义 $f(n)$ 为它十进制下每一位数字的平方的和。 现在给定三个正整数 $k$, $a$, b，请求出满足 $a\\leq n\\leq b$ 且 $k\\times f(n) = n$ 的 $n$ 的个数。\nSolution $k$ 是给定的，那么对于一个 $f(n)$，只至多一个 $n$ 是合法的。我们直接枚举 $f(n)$ 即可。\nCode namespace solve { void main() { long long k, a, b; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; long long ans = 0; for (int i = 1; i \u0026lt;= 1500; i++) { __int128_t x = __int128_t(k) * i; if (x \u0026gt;= a \u0026amp;\u0026amp; x \u0026lt;= b) { int j = 0; while (x) j += (x % 10) * (x % 10), x /= 10; if (j == i) ans++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } ","permalink":"https://luoyisu.github.io/posts/number-dp/","summary":"\u003cp\u003e不给出题目链接了，网上可以找到（推荐vjudge）。\u003c/p\u003e","title":"数位统计问题练习记录"},{"content":"Description 有一个字符串 $S$，有 $n_a$ 个 A 类串是其子串，有 $n_b$ 个 B 类串是其子串，另外有 $m$ 个支配关系，表示第 $x$ 个 A 类串支配第 $y$ 个 B 类串。\n求一个长度最大的字符串 $T$，需要满足两个条件：\n其可以分割为若干个 A 类串； 不妨设 $T=t_1+t_2+t_3+\u0026hellip;+t_k$，$t_i=A_{id_i}$，那么对于所有的 $t_i,t_{i+1}$，都存在一个 $A_{id_i}$ 支配的 B 类串，使得这个 B 类串是 $t_{i+1}$ 的前缀。 只需要输出长度的最大值即可，若可以无限长，输出 $-1$。\n$|S|,n_a,n_b,m\\leq2\\times10^5$，多组数据，每个数据点中 $|S|,n_a,n_b,m$ 的总和不会超过单组数据限制的 $10$ 倍。\nSolution 看到这个要求的东西以及这个支配关系，很容易想到尝试用图论模型描述这个题。\n对于每个 A 类串，向其支配的 B 类串连边权为 A 类串长度的边，对于每个 B 类串，连向所有以这个 B 类串为前缀的 A 类串，边权为 $0$，这样目标串就对应这个图上的一个最长路再加上终点 A 类串的长度。\n或者把 A 类串看作点权，求一个点权最大的路径。\n暴力连是 $O(n^3)$，然后可以考虑用一个后缀数据结构，发现后缀树可以比较好描述这个东西。\n我们找到每个 A 类串和 B 类串，对于支配关系直接连边，然后对于每个 B 类串，向其子树里所有 A 类串连边就好了。\n这样是 $O(n^2)$ 的。\n然后找到 A 类串和 B 类串这件事可以用倍增找：找到一个子串 $S[l:r]$，找到后缀 $l$ 在后缀树上对应的叶子结点，然后往上跳即可。这是 $O(n\\log n)$ 的。\n连边的话可以利用现成的后缀树，后缀树相当于已经帮我们连好边了。这是 $O(n)$ 的。\n然后还有个问题是后缀树上的点是压缩过的，当同一个点对应长度不同的子串的时候，我们需要把它拆开，从长度小连向长度大即可。\n需要注意的是，这么折腾完之后我们原来图上 A 连 B、B 连 A 的性质被破坏了，因此不能用上面说的点权的方法求答案，只能用边权来求。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; namespace solve { const int maxn = 1e6 + 10; typedef long long ll; int read(int \u0026amp;x) { x = 0; char ch = getchar(); for (; !isdigit(ch); ch = getchar()) ; for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x; } inline int lg(int x) { return 31 - __builtin_clz(x); } int tot = 1, ch[maxn][26], father[maxn], mx[maxn], id[maxn], lst = 1; void insert(int c, int i) { int p = ++tot, f = lst; lst = p, id[i] = p, mx[p] = mx[f] + 1; while (f \u0026amp;\u0026amp; !ch[f][c]) ch[f][c] = p, f = father[f]; if (f == 0) father[p] = 1; else { int q = ch[f][c]; if (mx[q] == mx[f] + 1) father[p] = q; else { int nq = ++tot; memcpy(ch[nq], ch[q], sizeof(ch[q])), father[nq] = father[q], mx[nq] = mx[f] + 1; father[p] = father[q] = nq; while (f \u0026amp;\u0026amp; ch[f][c] == q) ch[f][c] = nq, f = father[f]; } } } namespace dag { struct edge { int y, w; }; vector\u0026lt;edge\u0026gt; e[maxn]; int rd[maxn]; inline void add(int x, int y, int w) { e[x].push_back({y, w}), rd[y]++; } ll f[maxn]; int val[maxn]; ll dp() { queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= tot; i++) if (!rd[i]) q.push(i); while (!q.empty()) { int x = q.front(); q.pop(); for (auto k : e[x]) { int v = k.y, w = k.w; f[v] = max(f[v], f[x] + w); if (--rd[v] == 0) q.push(v); } } for (int i = 1; i \u0026lt;= tot; i++) if (rd[i]) return -1; for (int i = 1; i \u0026lt;= tot; i++) f[i] += val[i]; return *max_element(f + 1, f + 1 + tot); } } vector\u0026lt;int\u0026gt; e[maxn]; int dep[maxn], ff[maxn][20]; void build() { for (int i = 2; i \u0026lt;= tot; i++) e[father[i]].push_back(i); } void dfs1(int x, int fa) { dep[x] = dep[fa] + 1, ff[x][0] = fa; for (int i = 1; i \u0026lt;= 18; i++) ff[x][i] = ff[ff[x][i - 1]][i - 1]; for (int v : e[x]) dfs1(v, x); } vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; a[maxn]; // first : len, second : i inline int jump(int x, int len) { for (int i = lg(dep[x]); i \u0026gt;= 0; i--) if (mx[ff[x][i]] \u0026gt;= len) x = ff[x][i]; return x; } char str[maxn]; int n, m; pair\u0026lt;int, int\u0026gt; seg[maxn]; int p[maxn]; void dfs(int x, int fa) { if (fa) dag::add(fa, x, 0); sort(a[x].begin(), a[x].end()); a[x].erase(unique(a[x].begin(), a[x].end()), a[x].end()); int lst = x; for (int i = 1; i \u0026lt; (int)a[x].size(); i++) { if (a[x][i].first != a[x][i - 1].first) dag::add(lst, ++tot, 0), lst = tot; p[a[x][i].second] = lst; } for (int v : e[x]) dfs(v, lst); } void clear() { for (int i = 1; i \u0026lt;= tot; i++) dag::rd[i] = dag::f[i] = 0, dag::e[i].clear(), dag::val[i] = 0; for (int i = 1; i \u0026lt;= tot; i++) a[i].clear(), p[i] = 0, memset(ch[i], 0, sizeof(ch[i])), father[i] = id[i] = mx[i] = 0; for (int i = 1; i \u0026lt;= tot; i++) e[i].clear(), dep[i] = 0, memset(ff[i], 0, sizeof(ff[i])); lst = tot = 1; } void main() { scanf(\u0026#34;%s\u0026#34;, str + 1); int len = strlen(str + 1); for (int i = len; i \u0026gt;= 1; i--) insert(str[i] - \u0026#39;a\u0026#39;, i); build(), dfs1(1, 0); read(n); for (int i = 1; i \u0026lt;= n; i++) read(seg[i].first), read(seg[i].second); read(m); for (int i = n + 1; i \u0026lt;= n + m; i++) read(seg[i].first), read(seg[i].second); for (int i = 1; i \u0026lt;= n + m; i++) { p[i] = jump(id[seg[i].first], seg[i].second - seg[i].first + 1); a[p[i]].emplace_back(seg[i].second - seg[i].first + 1, i); } dfs(1, 0); for (int i = 1; i \u0026lt;= n; i++) dag::val[p[i]] = seg[i].second - seg[i].first + 1; int k; read(k); for (int i = 1; i \u0026lt;= k; i++) { int x, y; read(x), read(y), dag::add(p[x], p[y + n], seg[x].second - seg[x].first + 1); } cout \u0026lt;\u0026lt; dag::dp() \u0026lt;\u0026lt; endl; clear(); } } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) solve::main(); } ","permalink":"https://luoyisu.github.io/posts/loj3049/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e有一个字符串 $S$，有 $n_a$ 个 A 类串是其子串，有 $n_b$ 个 B 类串是其子串，另外有 $m$ 个支配关系，表示第 $x$ 个 A 类串支配第 $y$ 个 B 类串。\u003c/p\u003e\n\u003cp\u003e求一个长度最大的字符串 $T$，需要满足两个条件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e其可以分割为若干个 A 类串；\u003c/li\u003e\n\u003cli\u003e不妨设 $T=t_1+t_2+t_3+\u0026hellip;+t_k$，$t_i=A_{id_i}$，那么对于所有的 $t_i,t_{i+1}$，都存在一个 $A_{id_i}$ 支配的 B 类串，使得这个 B 类串是 $t_{i+1}$ 的前缀。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e只需要输出长度的最大值即可，若可以无限长，输出 $-1$。\u003c/p\u003e\n\u003cp\u003e$|S|,n_a,n_b,m\\leq2\\times10^5$，多组数据，每个数据点中 $|S|,n_a,n_b,m$ 的总和不会超过单组数据限制的 $10$ 倍。\u003c/p\u003e","title":"loj3049 「十二省联考 2019」字符串问题"},{"content":"参考：出题人 Itst 的题解。\n确实是神仙，不好想。\nDescription 有一个帖子，总共有 $n$ 个人在帖子里发过消息。这个帖子里有 $m$ 条消息，每条消息包含三个字符串 $s1,s2,s3$，$s1$ 代表发出者的名字。消息分三类：\n楼上型消息：如果 $s3$ 是 loushang，且 $s2$ 是在帖子里发过贴的人的名字，那么称该消息为楼上型消息，该消息被满足当且仅当上一条消息的发出者为 $s2$； 楼下型消息：如果 $s3$ 是 louxia，且 $s2$ 是在帖子里发过贴的人的名字，那么称该消息为楼下型消息，该消息被满足当且仅当下一条消息的发出者为 $s2$； 学术消息：不满足以上条件即为学术消息。这类消息无法被满足。 你需要对这 $m$ 条消息进行重新排列使得被满足的消息数量最大，输出这个最大值以及排列。\n保证每个人至少发过一条学术消息。\n多组数据，数据组数 $T\\leq100$，$n\\leq m\\leq77777$，$\\sum m\\leq2.5\\times10^5$。\nSolution 让我们忽略魔怔的题面，来分析这个问题吧。\n首先题目中的楼上型消息和楼下型消息很容易想到可以用边的方式去刻画，我们有了一个初步的方向：加边加边加边，跑某某某算法。\n特殊性质 BC 因为每个消息都能被满足，且没有互相满足的消息，最后的帖子一定是由若干块下面这种形式组成：\nA B loushang\rB C loushang\rC C C\rD C louxia\rA D louxia 即若干个楼上消息，一个学术消息，若干个楼下消息。\n一个简单想法是：把满足要求的消息按照楼上到楼下的方向连边，把这种形式抽象为一条链，然后搞欧拉回路之类的覆盖所有边的算法。\n比如 A B loushang，就从 $A$ 向 $B$ 连边，A B louxia，就从 $B$ 向 $A$ 连边。\n乍一看挺对，但直接连边是不能体现出经过学术消息走到楼下消息这一不可逆的过程，对于这种不可逆的边我们可以用分层图来描述：\n建立二层图 $G_1,G_2$，对于楼上型消息，我们在 $G_1$ 中连边；对于楼下型消息，我们在 $G_2$ 中连边；对于学术消息，我们把发出者从 $G_1$ 连向 $G_2$，这样一个块就是从 $G_1$ 出发经过若干条边然后走一个学术边到达 $G_2$ 再走若干条边结束。\n因为所有消息都可以被满足，我们建一个辅助点然后平衡一下度数，跑欧拉回路就好了。\n具体而言就是 $G_1$ 要是入度不够就从辅助点向它连边，$G_2$ 相反。\n特殊性质 C 现在有消息不能被满足了，也就是说 $G_1$ 中有点入度大于出度，这些入度减出度条边无法满足要求，$G_2$ 中就是反过来。\n首先我们如果把多的边全都扔掉肯定是可以构造出一组方案的，但是并不一定是最优，因为扔掉的边可以变为学术消息再次利用。变成学术消息后 $G_1$ 中对应点入度会减 $1$，$G_2$ 中对应点入度会加 $1$，这样我们扔掉了一条边，而可以满足两个需要的边。\n我们要让扔掉一些边之后能尽可能多匹配不能被满足的边。\n问题转化为：每个点有一个需求，而假如舍弃一条边，可以满足 $G_1,G_2$ 中各一个点的需求减去 $1$，要最大化满足的需求。\n然后这个问题很明显可以用最大流求解，源点向 $G_1$ 中的点连流量为该点不能满足的边的数量，$G_2$ 中的点向汇点连该点不能满足的边的数量。对于一条边 A B loushang，我们从 $G_1$ 的 $B$ 连向 $G_2$ 的 $A$，流量为 $1$，表示断掉这条边，这两个点的需求都减少 $1$；楼下消息同理。\n接下来我们把被舍弃的边看作学术消息，做特殊性质 BC 就可以了。\n无特殊性质 现在没有了特殊性质 C，不同就是一条链的中间点除了是学术消息，还可以是下面这种形式：\nA B loushang\rB A louxia 因为这部分没多少分我们可以直接猜测只需要把边简单地缩起来就可以搞定\n调整法就可以证明，把这两条消息看成一条从 $A$ 到 $B$ 的学术消息边一定是不劣的。\n简单证明一下就是如果拆开，那么把 A B loushang 的上面匹配的楼上消息以及 B A louxia 下面匹配的楼下消息都搬出来，再合到一起去，肯定是不劣的。\n然后我们就可以快乐地把这两条边看成一条学术边然后做特殊性质 C 了，好耶！\n实现的时候发现一个小问题：缩起来的边在跑欧拉路的时候记录方案略难受，我的方法是对于每组边，再建一个虚点，$A$ 向虚点连边，虚点向 $B$ 连边。\n时间复杂度为预处理 $O(m\\log m)$，最大流 $O(dinic)$，欧拉路 $O(n+m)$，加起来反正能过。\n我感觉这个二分图，流量不大，dinic应该是很快的。\nCode 不是非常好写，码量略大。\nnamespace solve { const int maxn = 3e5 + 10; const int inf = 1e9; const string louxia = \u0026#34;louxia\u0026#34;; const string loushang = \u0026#34;loushang\u0026#34;; typedef pair\u0026lt;int, int\u0026gt; pii; int n, m; unordered_map\u0026lt;string, int\u0026gt; mp; vector\u0026lt;int\u0026gt; a[maxn]; int ans[maxn]; struct message { int x, y, type; // 1 楼上 2 楼下 } all[maxn]; int cnt = 0; namespace flow { struct edge { int x, y, cap, flow; int now_flow() { return cap - flow; } }; vector\u0026lt;edge\u0026gt; edges; vector\u0026lt;int\u0026gt; e[maxn]; inline int add(int x, int y, int cap) { cnt++; edges.push_back({x, y, cap, 0}); edges.push_back({y, x, 0, 0}); int m = edges.size(); e[x].push_back(m - 2), e[y].push_back(m - 1); return m - 2; } int cur[maxn], vis[maxn], s, t, dis[maxn]; bool bfs() { fill(vis, vis + t + 1, 0); dis[s] = 0, vis[s] = 1; queue\u0026lt;int\u0026gt; q; q.push(s); while (!q.empty()) { int x = q.front(); q.pop(); for (int i : e[x]) { auto \u0026amp;k = edges[i]; if (!vis[k.y] \u0026amp;\u0026amp; k.cap - k.flow \u0026gt; 0) { dis[k.y] = dis[x] + 1; vis[k.y] = 1, q.push(k.y); } } } return vis[t]; } int dfs(int x, int lim) { if (x == t || lim == 0) return lim; int res = 0, f; for (int \u0026amp;i = cur[x]; i \u0026lt; (int)e[x].size(); i++) { auto \u0026amp;k = edges[e[x][i]]; if (dis[x] + 1 != dis[k.y] || (f = dfs(k.y, min(lim, k.cap - k.flow))) == 0) continue; res += f, lim -= f, k.flow += f, edges[e[x][i] ^ 1].flow -= f; if (lim == 0) break; } return res; } int dinic(int s_, int t_) { s = s_, t = t_; int res = 0; while (bfs()) fill(cur, cur + t + 1, 0), res += dfs(s, inf); return res; } void clear() { for (int i = 0; i \u0026lt;= t * 2; i++) e[i].clear(); edges.clear(); } } namespace euler { vector\u0026lt;pii\u0026gt; e[maxn]; int ans[maxn], tot, deg[maxn]; // cd - rd int virtual_node; inline void add(int x, int y, int id) { e[x].emplace_back(y, id); deg[x]++, deg[y]--; } void clear() { for (int i = 1; i \u0026lt;= virtual_node + 5; i++) e[i].clear(), deg[i] = 0; tot = 0; } void dfs(int x) { while (e[x].size()) { auto \u0026amp;p = e[x].back(); int v = p.first, id = p.second; e[x].pop_back(); dfs(v); if (id) ans[++tot] = id; } } } int notc[maxn]; // not satisfy C int rd[maxn], cd[maxn]; void clear() { flow::clear(); euler::clear(); mp.clear(); for (int i = 1; i \u0026lt;= n * 2 + 5; i++) rd[i] = cd[i] = 0; for (int i = 1; i \u0026lt;= m; i++) notc[i] = 0; } void main() { clear(); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; euler::virtual_node = n * 2 + 3; for (int i = 1; i \u0026lt;= n; i++) { string s; cin \u0026gt;\u0026gt; s, mp[s] = i; } int ans = 0; map\u0026lt;pii, vector\u0026lt;int\u0026gt;\u0026gt; pos; for (int i = 1; i \u0026lt;= m; i++) { string s1, s2, s3; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2 \u0026gt;\u0026gt; s3; int x = mp[s1], y = mp.count(s2) ? mp[s2] : 0, type = 0; if (s3 == loushang \u0026amp;\u0026amp; y) type = 1, ans++; else if (s3 == louxia \u0026amp;\u0026amp; y) type = 2, swap(x, y), ans++; all[i].x = x, all[i].y = y, all[i].type = type; } for (int i = 1; i \u0026lt;= m; i++) if (all[i].type == 1) pos[pii(all[i].x, all[i].y)].push_back(i); for (int i = 1; i \u0026lt;= m; i++) if (all[i].type == 2) { auto p = pii(all[i].x, all[i].y); if (!pos.count(p)) continue; auto \u0026amp;arr = pos[p]; if (!arr.empty()) { int j = arr.back(); arr.pop_back(); notc[i] = notc[j] = 1, rd[all[j].y + n]++, cd[all[j].x]++; euler::virtual_node++; euler::add(all[j].x, euler::virtual_node, j); euler::add(euler::virtual_node, all[j].y + n, i); } } for (int i = 1; i \u0026lt;= m; i++) if (!notc[i]) { if (all[i].type == 0) rd[all[i].x + n]++, cd[all[i].x]++; else if (all[i].type == 1) cd[all[i].x]++, rd[all[i].y]++; else cd[all[i].x + n]++, rd[all[i].y + n]++; } int S = n * 2 + 5, T = S + 1; for (int i = 1; i \u0026lt;= n; i++) if (rd[i] \u0026gt; cd[i]) flow::add(S, i, rd[i] - cd[i]); for (int i = n + 1; i \u0026lt;= n + n; i++) if (cd[i] \u0026gt; rd[i]) flow::add(i, T, cd[i] - rd[i]); vector\u0026lt;int\u0026gt; id(m + 10); for (int i = 1; i \u0026lt;= m; i++) if (!notc[i]) { if (all[i].type == 1) id[i] = flow::add(all[i].y, all[i].x + n, 1); else if (all[i].type == 2) id[i] = flow::add(all[i].y, all[i].x + n, 1); } ans -= flow::dinic(S, T); // 减去舍弃的边 for (int i = 1; i \u0026lt;= m; i++) { if (notc[i]) continue; if (all[i].type == 1 \u0026amp;\u0026amp; flow::edges[id[i]].now_flow() == 0) all[i].type = 0; if (all[i].type == 2 \u0026amp;\u0026amp; flow::edges[id[i]].now_flow() == 0) all[i].type = 0, swap(all[i].x, all[i].y); if (all[i].type == 0) euler::add(all[i].x, all[i].x + n, i); else if (all[i].type == 1) euler::add(all[i].x, all[i].y, i); else euler::add(all[i].x + n, all[i].y + n, i); } int aux_node = n * 2 + 1; for (int i = 1; i \u0026lt;= n; i++) { while (euler::deg[i] \u0026gt; 0) euler::add(aux_node, i, 0); while (euler::deg[i] \u0026lt; 0) euler::add(i, aux_node, 0), ans--; // 减去无法匹配的边 } for (int i = n + 1; i \u0026lt;= n + n; i++) { while (euler::deg[i] \u0026gt; 0) euler::add(aux_node, i, 0), ans--; while (euler::deg[i] \u0026lt; 0) euler::add(i, aux_node, 0); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; euler::dfs(aux_node); reverse(euler::ans + 1, euler::ans + 1 + m); for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; euler::ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } } ","permalink":"https://luoyisu.github.io/posts/loj3702/","summary":"\u003cp\u003e参考：\u003ca href=\"https://www.luogu.com.cn/blog/pengSiJin/lian-ge-xing-xuan-2022-xue-shu-she-ou-analysis\"\u003e出题人 Itst 的题解\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e确实是神仙，不好想。\u003c/p\u003e","title":"loj3702 「联合省选 2022」学术社区"},{"content":"这个提答还算小清新，不用跑很久，主要是观察数据性质。\nDescription 小 Q 最近发现了一款新游戏，游戏的目标是从一个新手修炼成为武功高强的大侠。\n对着这个游戏，小 Q 玩了很多次仍然玩不出他想要的结局，于是他费尽千辛万苦找到了游戏的剧本。令人惊讶的是，游戏的剧本并不像我们平时见到的剧本，反而很像代码。这个剧本是这样描述的：\n量：有 $2$ 种量，常数和变量。\n常数：一个整数。\n变量：初始值为 $0$ 的可变整数，不同变量用不同正整数区分。\n事件：整个剧本由若干个事件构成。所有的事件按照给定的顺序从 $1$ 开始依次编号。事件共有 $3$ 种：普通事件、选择跳转和条件跳转。\n执行位置：一个整数，表示接下来将会执行的事件编号，如果不存在这个编号的事件则停止，即游戏到了一个结局。最初的时候执行位置为 $1$。\n普通事件：一个变量增加或减少一个量的值。之后执行位置增加 $1$。\n选择跳转：两个整数。执行到这里时玩家需要在这两个整数中选择一个，之后执行位置将被修改为这个整数。\n条件跳转：两个量和两个整数。执行到这里时，若第一个量小于第二个量，则执行位置将被修改为第一个整数，否则将被修改为第二个整数。\n小 Q 认为，整个游戏是希望一个叫做“成就值”的变量（编号为 $1$）最大。\n现在给出 $10$ 个剧本，需要求出每个剧本获得最大成就值的每一步选择。\nSolution 这个题乍看上去除了 $2^x$ 的搜索没啥办法能做，去看看数据，选择跳转的次数是非常多的。\n不知道模拟退火效果怎么样，我估计可以得到一定分数，但无法 AC。\n就看看数据吧。\n前两个点可以直接搜索过去。\n第三个点挺整齐的，发现每 $170$ 行之间是独立的，在进入下一个之前会把所有变量的绝对值加到变量 $1$ 上并清空所有变量。\n那么我们对每个块内搜索就好了，最后答案就是每个块内的最大值加起来。\n第三个点的代码：\nnamespace solve { const int maxn = 40000; int var[maxn], n, m; struct number { char type; int x; inline int val() { return type == \u0026#39;c\u0026#39; ? x : var[x]; } inline void in() { type = readchar(), x = read(); } }; struct opt { char type; int s1, s2; int mul; number a, b; inline void in(int id) { type = readchar(); if (type == \u0026#39;s\u0026#39;) s1 = read(), s2 = read(); else if (type == \u0026#39;i\u0026#39;) a.in(), b.in(), s1 = read(), s2 = read(); else { s1 = id + 1; a.type = \u0026#39;v\u0026#39;, a.x = read(), mul = readchar() == \u0026#39;+\u0026#39; ? 1 : -1; b.in(); } } } a[maxn]; int choice[maxn]; int ans_choice[maxn], ans, tot; void dfs(int now, int dep, int i) { if (now \u0026gt; (i + 1) * 170) { if (var[1] \u0026gt; ans) { ans = var[1]; for (int i = 1; i \u0026lt; dep; i++) ans_choice[i] = choice[i]; tot = dep - 1; } return; } if (a[now].type == \u0026#39;s\u0026#39;) { choice[dep] = 1, dfs(a[now].s1, dep + 1, i); choice[dep] = 2, dfs(a[now].s2, dep + 1, i); } else if (a[now].type == \u0026#39;i\u0026#39;) { if (a[now].a.val() \u0026lt; a[now].b.val()) dfs(a[now].s1, dep, i); else dfs(a[now].s2, dep, i); } else { int tmp = a[now].mul * a[now].b.val(); var[a[now].a.x] += tmp; dfs(now + 1, dep, i); var[a[now].a.x] -= tmp; } } void main() { n = read(), m = read(); for (int i = 1; i \u0026lt;= n; i++) a[i].in(i); int all = 0; for (int i = 0; i \u0026lt; 200; i++) { dfs(i * 170 + 1, 1, i); for (int i = 1; i \u0026lt;= tot; i++) cout \u0026lt;\u0026lt; ans_choice[i] \u0026lt;\u0026lt; endl; all += ans; memset(var, 0, sizeof(var)), ans = 0; } cerr \u0026lt;\u0026lt; all \u0026lt;\u0026lt; endl; } } 第 456 个点可以发现都是很多下面这种形式组合起来：\ni v 2 c 10 3 4\ri c 0 c 1 8 0\rs 5 8\rv 2 - c 10\rv 1 + c 22750\ri c 0 c 1 8 0 意思就是，变量 2 有个初值，然后如果变量 2 的值大于 $x$，可以让变量 2 的值减去 $x$，同时变量 1 的值加上一个数，也可以不选。\n发现每次跳的地方都比这个地方大，也就是说这是个 DAG，我们倒着跑一个背包即可。\n第 78910 个点发现也是由 456 点那样的大块组成的，然后大块内部是类似第三个点的结构，那就大块内搜索，然后背包就好了。\n注意不能用行数分块，数据好像并不是完全均匀的，以及价值之类的要算清楚。\n直接给出 7 8 9 10 的代码：\nnamespace solve { const int maxn = 40000; int var[maxn], n, m; struct number { char type; int x; inline int val() { return type == \u0026#39;c\u0026#39; ? x : var[x]; } inline void in() { type = readchar(), x = read(); } }; struct opt { char type; int s1, s2; int mul; number a, b; inline void in(int id) { type = readchar(); if (type == \u0026#39;s\u0026#39;) s1 = read(), s2 = read(); else if (type == \u0026#39;i\u0026#39;) a.in(), b.in(), s1 = read(), s2 = read(); else { s1 = id + 1; a.type = \u0026#39;v\u0026#39;, a.x = read(), mul = readchar() == \u0026#39;+\u0026#39; ? 1 : -1; b.in(); } } } a[maxn]; int id[maxn], cnt; int val[maxn], w[maxn], nxt[maxn]; int is[3000][10010]; int f[3000][10010]; vector\u0026lt;int\u0026gt; all[maxn]; namespace dfs { int ans, ans_choice[maxn], tot; int choice[maxn]; void dfs(int now, int dep, int ed) { if (now \u0026gt; ed) { if (var[1] \u0026gt; ans) { ans = var[1]; for (int i = 1; i \u0026lt; dep; i++) ans_choice[i] = choice[i]; tot = dep - 1; } return; } if (a[now].type == \u0026#39;s\u0026#39;) { choice[dep] = 1, dfs(a[now].s1, dep + 1, ed); choice[dep] = 2, dfs(a[now].s2, dep + 1, ed); } else if (a[now].type == \u0026#39;i\u0026#39;) { if (a[now].a.val() \u0026lt; a[now].b.val()) dfs(a[now].s1, dep, ed); else dfs(a[now].s2, dep, ed); } else { int tmp = a[now].mul * a[now].b.val(); var[a[now].a.x] += tmp; dfs(now + 1, dep, ed); var[a[now].a.x] -= tmp; } } void work(int bg, int ed, int i) { memset(var, 0, sizeof(var)), ans = 0; memset(ans_choice, 0, sizeof(ans_choice)), tot = 0; memset(choice, 0, sizeof(choice)); dfs(bg, 1, ed); // cerr \u0026lt;\u0026lt; bg \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ed \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; for (int j = 1; j \u0026lt;= tot; j++) all[i].push_back(ans_choice[j]); } } vector\u0026lt;int\u0026gt; choice; void choose(int id) { for (int p : all[id]) choice.push_back(p); } void back(int i, int j) { // cerr \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; if (i \u0026gt; cnt) return; if (is[i][j]) { choice.push_back(1), choose(i + 1); back(i + 1, j - w[i + 1]); } else { if (j \u0026gt;= w[i + 1]) choice.push_back(2); back(nxt[i], j); } } int isbg[maxn]; void main() { n = read(), m = read(); for (int i = 1; i \u0026lt;= n; i++) a[i].in(i); int W = a[1].b.val(); for (int i = 1; i \u0026lt;= n - 2; i++) { if (a[i].type == \u0026#39;s\u0026#39; \u0026amp;\u0026amp; a[i + 1].type == \u0026#39;v\u0026#39; \u0026amp;\u0026amp; a[i + 2].type == \u0026#39;s\u0026#39;) { isbg[i] = 1; id[i] = ++cnt; } } id[n + 1] = cnt + 1; w[cnt + 1] = 1e9; cerr \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; for (int i = n; i \u0026gt;= 1; i--) { if (!id[i]) id[i] = id[i + 1]; } for (int i = 1; i \u0026lt;= n; i++) { if (isbg[i]) { dfs::work(i + 2, a[i].s2 - 2, id[i] + 1); val[id[i] + 1] = dfs::ans; w[id[i] + 1] = a[i - 2].b.val(); nxt[id[i]] = id[a[i].s2]; } } for (int i = 1; i \u0026lt;= cnt; i++) if (!nxt[i]) nxt[i] = cnt + 1; // for (int i = 1; i \u0026lt;= cnt; i++) // cerr \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; endl; for (int i = cnt; i \u0026gt;= 1; i--) { memcpy(f[i], f[nxt[i]], sizeof(f[i])); for (int j = W; j \u0026gt;= w[i + 1]; j--) { if (f[i + 1][j - w[i + 1]] + val[i + 1] \u0026gt; f[i][j]) { f[i][j] = f[i + 1][j - w[i + 1]] + val[i + 1]; is[i][j] = 1; } } } // for (int i = 1; i \u0026lt;= cnt + 1; i++) // cerr \u0026lt;\u0026lt; w[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; val[i] \u0026lt;\u0026lt; endl; int j = max_element(f[1], f[1] + W + 1) - f[1], res = f[1][j]; cerr \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; back(1, j); for (int p : choice) cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; } } ","permalink":"https://luoyisu.github.io/posts/uoj123/","summary":"\u003cp\u003e这个提答还算小清新，不用跑很久，主要是观察数据性质。\u003c/p\u003e","title":"uoj123 NOI2013 小Q的修炼"},{"content":"很多分类讨论的题，不对拍很容易被卡正确性。\nDescription 给一个 $n\\times m$ 的网格图，删去其中 $c$ 个点，问再删去至少几个点可以使图上存在两个点不连通。\n无法达到目的输出 $-1$。\n$n,m\\leq10^9,c\\leq10^5$。\nSolution 首先答案最大是 $2$，删除一个角落相邻的点就可以做到。\n玩一玩，答案是 $-1$ 有两种情况：$n\\times m-c\u0026lt;2$，或 $n\\times m-c=2$ 且剩下的两个点连通。\n答案是 $0$ 就是已经存在不连通的两个点。\n如果我们把 $n\\times m$ 的图建出来，那么答案是 $1$ 就是存在割点。\n剩下的答案就是 $2$ 了。\n现在问题是图太大，我们需要把这个图缩成 $O(c)$ 个点。\n很容易想到周围一大圈都没有被删掉的点的点是没用的，那我们的思路就是把被删掉的点周围的点拉出来建图。\n只把周围 $3\\times3$ 的点拉出来是不对的，考虑下面这个：\n...\r..*\r... $(2,2)$ 会成为割点，但实际上它并不是。\n所以要拉出来 $5\\times5$ 的点，并且只有在 $3\\times 3$ 范围内的割点才有效。\n然后判断原图是否连通可以用如下的办法：对建出来的图搜连通块，然后把相邻的被删掉的点看作一个整体，如果一组被删掉的点周围四连通的点不属于同一连通块，那么原图就不连通。\n最后判断有没有割点用 tarjan 就好了。\n复杂度在建图上，如果用哈希表实现，复杂度可以看作 $O(24c)$。\nCode 常数巨大，别学。\nnamespace solve { const int maxn = 1e6 + 10; typedef pair\u0026lt;int, int\u0026gt; pii; const int dx4[] = {0, 0, 1, -1}; const int dy4[] = {1, -1, 0, 0}; vector\u0026lt;int\u0026gt; e[maxn]; int n, m, c; inline bool is_in(int x, int y) { return x \u0026gt;= 1 \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; y \u0026gt;= 1 \u0026amp;\u0026amp; y \u0026lt;= m; } pii a[maxn], all[maxn]; int cnt; struct hash_map { static const int mod = maxn + -3; int hash(const pii \u0026amp;x) { return (1ll * x.first * m + x.second) % mod; } struct node { pii x; int val, nxt; } a[maxn]; int hd[mod], tot; int \u0026amp;operator[](const pii \u0026amp;x) { int pos = hash(x); for (int p = hd[pos]; p; p = a[p].nxt) { if (x == a[p].x) { return a[p].val; } } a[++tot] = {x, 0, hd[pos]}, hd[pos] = tot; return a[tot].val; } int count(const pii \u0026amp;x) { int pos = hash(x); for (int p = hd[pos]; p; p = a[p].nxt) if (x == a[p].x) return 1; return 0; } void clear() { memset(hd, 0, sizeof(hd)), tot = 0; } } mp, mp2; inline bool has(pii x) { return mp2.count(x); } inline bool has(int x, int y) { return has(pii(x, y)); } namespace no_solution { bool work() { if (1ll * n * m - c \u0026lt;= 1) return 1; if (1ll * n * m - c \u0026gt; 2) return 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) if (!has(i, j)) { for (int k = 0; k \u0026lt; 4; k++) { int nx = i + dx4[k], ny = j + dy4[k]; if (is_in(nx, ny) \u0026amp;\u0026amp; !has(nx, ny)) return 1; } return 0; } return 1; } } namespace ans_eq_zero { int father[maxn]; int find(int x) { return x == father[x] ? x : father[x] = find(father[x]); } void uni(int x, int y) { father[find(x)] = find(y); } int color[maxn], tot, ucolor[maxn]; void dfs(int x, int col) { color[x] = col; for (int v : e[x]) if (!color[v]) dfs(v, col); } bool work() { for (int i = 1; i \u0026lt;= cnt; i++) father[i] = i, color[i] = ucolor[i] = 0; for (int i = 1; i \u0026lt;= cnt; i++) if (!color[i]) tot++, dfs(i, tot); // for (int i = 1; i \u0026lt;= cnt; i++) // cout \u0026lt;\u0026lt; color[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // cout \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= c; i++) { for (int j = 0; j \u0026lt; 4; j++) { int x = a[i].first + dx4[j], y = a[i].second + dy4[j]; if (is_in(x, y) \u0026amp;\u0026amp; has(x, y)) uni(i, mp2[pii(x, y)]); } } for (int i = 1; i \u0026lt;= c; i++) { for (int j = 0; j \u0026lt; 4; j++) { int x = a[i].first + dx4[j], y = a[i].second + dy4[j]; if (is_in(x, y) \u0026amp;\u0026amp; mp.count(pii(x, y))) { int pos = mp[pii(x, y)]; if (!ucolor[find(i)]) ucolor[find(i)] = color[pos]; else if (ucolor[find(i)] != color[pos]) { // cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; return 1; } } } } return 0; } } int dfn[maxn], low[maxn], son[maxn], tot, cut, cntt; vector\u0026lt;int\u0026gt; ans; void tarjan(int x, int fa) { dfn[x] = low[x] = ++cntt, son[x] = 0, tot++; for (int v : e[x]) { if (!dfn[v]) { son[x]++; tarjan(v, x); low[x] = min(low[x], low[v]); if (fa != 0 \u0026amp;\u0026amp; low[v] \u0026gt;= dfn[x]) cut++, ans.push_back(x); } else if (v != fa) low[x] = min(low[x], dfn[v]); } if (fa == 0 \u0026amp;\u0026amp; son[x] \u0026gt;= 2) cut++, ans.push_back(x); } int ok[maxn]; void clear() { mp.clear(), mp2.clear(); for (int i = 1; i \u0026lt;= cnt; i++) dfn[i] = low[i] = son[i] = 0, e[i].clear(), ok[i] = 0; cnt = cntt = 0, tot = cut = 0; ans.clear(); } bool check() { for (int p : ans) if (ok[p]) return 1; return 0; } void main() { clear(); n = read(), m = read(), c = read(); for (int i = 1; i \u0026lt;= c; i++) a[i].first = read(), a[i].second = read(), mp2[a[i]] = i; if (no_solution::work()) { puts(\u0026#34;-1\u0026#34;); return; } for (int i = 1; i \u0026lt;= c; i++) for (int dx = -2; dx \u0026lt;= 2; dx++) for (int dy = -2; dy \u0026lt;= 2; dy++) { int x = a[i].first + dx, y = a[i].second + dy; if (!is_in(x, y) || has(x, y)) continue; if (mp.count(pii(x, y))) { ok[mp[pii(x, y)]] |= abs(dx) \u0026lt;= 1 \u0026amp;\u0026amp; abs(dy) \u0026lt;= 1; continue; } mp[pii(x, y)] = ++cnt, all[cnt] = pii(x, y); ok[cnt] = (abs(dx) \u0026lt;= 1 \u0026amp;\u0026amp; abs(dy) \u0026lt;= 1); } // for (int i = 1; i \u0026lt;= cnt; i++) // { // cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; all[i].first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; all[i].second \u0026lt;\u0026lt; endl; // } if (c == 0) { puts((n == 1 || m == 1) ? \u0026#34;1\u0026#34; : \u0026#34;2\u0026#34;); return; } for (int i = 1; i \u0026lt;= cnt; i++) { for (int j = 0; j \u0026lt; 4; j++) { int x = all[i].first + dx4[j], y = all[i].second + dy4[j]; if (is_in(x, y) \u0026amp;\u0026amp; mp.count(pii(x, y))) { int w = mp[pii(x, y)]; e[i].push_back(w); e[w].push_back(i); } } } if (ans_eq_zero::work()) { puts(\u0026#34;0\u0026#34;); return; } for (int i = 1; i \u0026lt;= cnt; i++) if (!dfn[i]) tarjan(i, 0); if ((cut \u0026amp;\u0026amp; check()) || n == 1 || m == 1) puts(\u0026#34;1\u0026#34;); else puts(\u0026#34;2\u0026#34;); } } ","permalink":"https://luoyisu.github.io/posts/loj2084/","summary":"\u003cp\u003e很多分类讨论的题，不对拍很容易被卡正确性。\u003c/p\u003e","title":"loj 2084 「NOI2016」网格"},{"content":"概述 很炸裂。\n赛时 三个传统题好耶！\n大概看了一眼三个题，还是决定按照顺序做。\nT1 一开始想的有点歪，然后脑子转的有点慢，后来过了 20min 才意识到只需要求出来每个元素加进栈时候上一个元素的位置，询问的时候看区间里的会不会被删空就好了，迅速写了一发暴力验证了正确性。\n按理来说已经该切掉了，但是我接下来进行了一波脑溢血操作——把题意转化为区间加区间小于等于 $0$ 个数。\n一开始还认为线段树能做，然后发现不对，然后开始走远——莫队？分块？？？？？\n然后还流了鼻血，浪费一点时间处理之后决定冷静思考。\n然后思考了一两分钟忽然意识到这不是问区间小于等于某数个数吗？我在想啥？？\n赶快写了一发离线树状数组，然后一发过了所有样例。。。\n这时候已经过去 1.5h 了，心态十分爆炸，感觉大家都已经过了两个题。。。\n也不想写对拍了，直接去看 T2。\n可能也冷静不下来，想到了哈希、SA等奇妙的东西，发现都不太对，只好先放着，去看 T3,。\nT3 也不太会，然后感觉我太菜了。。\n想了一下，T2 可以用 bitset 得到 $30\\sim40$ 分，于是去写了。\n然后又写了 T3 的 $10$ 分。。\nT3 还有 $10$ 分我通过一些卡常操作也草过去了。\n然后开始摆烂，主要是在想 T2，感觉应该不是很难啊。。。\n后来又去看 T3，可能是也平静下来了吧，我发现 $m=2$ 实际上非常简单，于是把卡常代码换成正常代码。\n然后意识到 $m=3$ 可以直接枚举哪个作为答案，然后二维偏序一波，但是来不及写完了。。。\n然后意识到 $m=4$ 可以转化为三维偏序，但是更来不及写完了。\n行啊。。\n赛后 看到有人说 T2 排序。。我忽然想起来排序之后比较相邻集合复杂度不是错的，那我在想啥呢？？？？？\n行啊。\n罢了罢了。\n总结 比赛时还是缺乏冷静啊，如果实力不能碾压题目心态就会受挫。\n实力和心态都很重要啊qwq\n也许应该学会逆风翻盘。\n","permalink":"https://luoyisu.github.io/posts/noi-online-2022/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e很炸裂。\u003c/p\u003e","title":"noi-online-2022"},{"content":"概述 虽说是和大工 PK，但感觉他们好像做了一会题就走了，主要是我们校内在做这些题。\n实际上水这么一篇博客的目的就是摆烂。。。\n赛前 和上次分队一样。\n赛时 10min 杜过了 D。\n17min 我过了 C。（简单排序 + dp）\n27min KH 开始交 K，但莫名 TLE。\n40min 杜过了 G。\n紧接着我开始交 K。（究极水题）然后 TLE。\n杜也来帮我看了看怎么回事，然后 KH 发现是读入太慢导致他 TLE 了，我好像也是同样的原因。\n我们都过了。\n看了眼 J，数学题，KH 说求导就好了qwq，他去写了。\n我去看了个 H，发现裸中国剩余定理，复制了个板子，1h 的时候给过了。\n紧接着 J 过了。\nKH 去看了看 I，说他会了然后开始写，但是这个题好像很难的样子qwq。\n杜大佬打了 F 的表，然后发现不怎么好写，扔给我了，他去做我之前看的 E 了。\n然后 2h 的时候他的 E WA了。。\n我的 F 也在差不多的时间 WA 了，看了很久发现忘记取模了，加上就过了。\n然后杜还在调 E，我帮他写了个暴力用于对拍。\nKH 在 2.5h 的时候开始交 I 了，然后一直 WA。。\n我这时候去做了 A，发现建个树出来就可以了，开始写写写。\n3h 的时候把 A 过了。\nKH 那边因为我们都不怎么会 I 没法帮他。。。\n我想到了一个 E 的 dp 做法，然后写了一阵子 3.5h 的时候给过了。\n然后就开始摆，KH 最后发现他 I 有地方没取模，终于在 4h 的时候给过了。\n我们就剩 B 了，然后齐心合力明白了怎么做，就是先特判，然后小数据暴力打表。\n但是因为暴力的复杂度有点高以及时间不够没能过掉，最后 11 题。\n赛后 B 也过了。\n总结 计数计数计数。\n","permalink":"https://luoyisu.github.io/posts/220326-contest-with-dut/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e虽说是和大工 PK，但感觉他们好像做了一会题就走了，主要是我们校内在做这些题。\u003c/p\u003e\n\u003cp\u003e实际上水这么一篇博客的目的就是摆烂。。。\u003c/p\u003e","title":"220326 和大连理工大学线上 PK 记"},{"content":"概述 预计 $100+100+4=204$，实际 $100+100+0=200$，和想的差不多。\n赛时 拿到 pdf，看到 T1，构造，再看两眼，画个图，哦我会了。只要构造一个长度为 $2$ 的菊花，然后剩下的再连一个链出去就好了。\n于是直接开始写，写了五分钟吧。。然后又花 30min 写+调 checker，哈哈。。。。。\n反正把所有数据都测了一遍，没问题。。\n于是看 T2，字符串题。。等会再说。\n看 T3，计数，DP，看到本质不同子序列忽然想到一个叫子序列自动机的玩意。。。不可做！（大雾）\n于是看 T2，退火没前途，二分没前途，高斯消元好像挺对的，但也没啥前途（没细想）。\n毕竟是后缀的 lcp，能用到的东西也不怎么多。开始枚举知识点！\n于是用一些后缀数据结构往上套，主要套后缀数组和后缀树。。\n然后玩了好几个数据（aab，aabaa，aaba，abaa 等）。\naab 比较有启发啊，然后在后缀树上模拟了一波好像明白了。\n就是设 $f_i$ 表示已经把这个子树上分好了的答案，我们对于每个点只考虑它与它父亲多出来的长度的贡献。\n对于直接就是原串后缀的点，贡献就是多出来的长度；如果不是原串后缀，那么就是多出来长度加上把儿子分一下。\n这个分儿子的过程，具体来说，设儿子的 $f$ 值为 $f_1,f_2,f_3\\dots f_m$，然后你需要构造 $k_1,k_2,k_3\\dots k_m$，使 $\\sum k=1$ 且 $\\max(f_ik_i)$ 最小。\n然后想一想，所有 $f_ik_i$ 都相等肯定是最优的（否则可以调整成相等使更优），然后再随便推一推，$\\max(f_ik_i)=\\dfrac{1}{\\sum_{j=1}^m\\dfrac{1}{f_j}}$。\n（我也讲不清楚了，可以看代码）\n（其实好像不是多出来长度贡献，而是一个类似区间 DP 的思想？或者说选父亲就不选儿子？）\n（实际上上述过程花了很长很长很长时间，主要是对于只考虑多出来长度这部分想了很久才勉强想清楚）\n于是写完了，又发现被卡空间了，卡了一阵子，卡完之后也不剩什么时间了，急忙开 T3。。\n我会 $O(nq)$ 暴力DP！\n写写写，怎么过不去样例啊。。。。。\n好吧好像是错的，哦好像可以改成 $O(nmq)$，也是有分的，写写写。。。\n好家伙没时间了，结果没调出来。。。那就这样吧。。\n赛后 T2 数据错了，题面 $n=10^6$，结果数据 $n=10^4$？？？\n因为数组开小 T3 白送的 $4$ 分好像也没拿到，悲剧。。。\n怎么说呢，T2 冥思苦想也不会的时候，也许应该先开 T3 打一打暴力。。。\n枚举知识点实在是过于耗费时间了。。。\n然后看了别人的代码和题解意识到我 T3 当时想的那个 $O(nq)$ 确实错了，但是 $O(nmq)$ 的做法是对的\u0026hellip;总之 DP 这个东西还是要仔细想一下，硬莽好像不是很对。\n总结 反正今天这个 T2 和 T3 真不好说。。\nT3 其实也不是特别难，如果花时间想还是能得一些分数的，正解可能想不太到，但暴力有希望能多拿几十分。\n主要是 $m\\leq200$，就让人遐想\u0026hellip;\n但是这个 T2 实在是有点让人上头，主要是要用后缀数据结构有点明显了，然后就一直想往上套。。\nstd 的分治做法也得学一学，我现在 SA 水平真的是很差。。。\n","permalink":"https://luoyisu.github.io/posts/220324-contest/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e预计 $100+100+4=204$，实际 $100+100+0=200$，和想的差不多。\u003c/p\u003e","title":"220324线上模拟赛"},{"content":"虽说是和大工 PK，但感觉他们好像做了一会题就走了，主要是我们校内在比（\n实际上水这么一篇博客的目的就是摆烂。。。\n概述 我，KH，杜大佬一队，被 KH 带飞了！！！！！\n赛前 队名叫 Civilized Code Style，因为我们的码风都非常文明！！\n赛时 看 A，好长啊不想看。。\n看 B，卧槽怎么已经有人过了？想了下，又咨询了一下 KH，就懂了，是个 0/1 分数规划，于是开始写。\n写着写着 KH 就把 G 过了，杜大佬在写 K，但似乎假了。\n我刚写完 B，结果惨遭卡常（其实也不算常数问题，二分次数太多了）。\n然后 KH 又把 L 过了，神！\n他们一阵讨论，对拍都上了也不知道哪里有问题。\n然后我终于过了 B，去看 M，感觉是个换根 DP。。\n他们好像发现 K 题意理解有误，明白怎么做之后 KH 去写了，挂了几发之后过了。\n杜大佬好像又在和 KH 商量 J，会了之后杜大佬把 J 过了，KH 去做了 D，是个我不会的奇妙概率 DP，然后一发过了。\n期间我们商量了一下 C 题，好像并没有人想做，也不是特别会。。\n然后杜大佬好像是去做 E 了。。\n我期间一直在想 M，因为不是很会换根，想找一些别的方法。\n结果别的方法还真有，就硬分类讨论，我开始艰难地敲代码。。。\n然后一个小时内都没人交题。。。\nKH 打破僵局，他一发过了 F！\n过了十几分钟我一发过了 M！\n接着 KH 去和杜大佬商量了一下 E，然后接力去做了，杜大佬会了 C，去写了，然后我去做了 I。\nI 是一个奇妙的构造题，我玩了半天好像是给玩出来了，于是去写，倒不难写，罚了一发之后加个特判就过了。。\n杜大佬好像还在调 C，KH 的 E 还在罚时。。我去帮 KH 看了看 E 题，找了个 bug 然后过了，好耶！！\n这时候也就剩不到一个小时了。\nC 我们都不大会没法帮杜大佬调，于是 KH 去看了 A，会了，但是不好写，他开始写了。。\n我不想看 H，就去看了 N，是个下棋题，我后来意识到这个题硬下就可以，但是没时间下完了qwq。\n杜大佬最后也没调出来 C，我们最终 $10/14$ 题，然后在 $10$ 题队伍中垫底，我的罚时功不可没啊！！\n我们学校的另一个队是 $9$ 题的第一名，就很神仙。\n总结 也不能完全不总结吧。。\n其实不会的还是一些小清新的 DP 题。。\n","permalink":"https://luoyisu.github.io/posts/220319-contest-with-dut/","summary":"\u003cp\u003e虽说是和大工 PK，但感觉他们好像做了一会题就走了，主要是我们校内在比（\u003c/p\u003e\n\u003cp\u003e实际上水这么一篇博客的目的就是摆烂。。。\u003c/p\u003e","title":"220319 和大连理工大学线上 PK 记"},{"content":"目前只有 Day1 的题目。\n感觉 Day1 的三道题很 CF。\n卡牌游戏 Description 有 $n$ 张卡牌，第 $i$ 张卡牌的正面有数字 $a_i$，背面有数字 $b_i$，初始时所有卡牌正面朝上。\n现在 Alice 可以将不超过 $m$ 张卡牌翻面，即由正面朝上改为背面朝上。Alice 的目标是让最终朝上的 $n$ 个数字的极差（最大值与最小值的差）尽量小。请你帮 Alice 算一算极差的最小值是多少。\n$n,m\\leq10^6,a_i,b_i\\leq10^9$。\nSolution 首先我们要确定：常数小的 $O(n\\log a_i)$ 是可以过的。\n然后二分一个答案，考虑怎么 check，我们显然需要保留一段连续的区间不翻面（换句话说，一定只翻前后缀）。\n考虑已经有左端点了，我们双指针确定右端点，这是 $O(n)$ 的，接下来不在这段区间内的卡牌显然全部需要翻面，那就变成了一个 RMQ 问题，用 ST 表解决就好了。\n时间复杂度 $O(n\\log n+n\\log a_i)$。\nCode 注意细节，然后建议去 uoj 看看 hack 数据的威力。\n被卡常可以考虑把 ST 表小的一维放前面。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; int read() { int x = 0; char ch = getchar(); for (; !isdigit(ch); ch = getchar()) ; for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x; } const int maxn = 2e6 + 10; const int inf = 2e9; int mx[22][maxn], mi[22][maxn]; int n, a[maxn], b[maxn], m; int lg[maxn]; void build() { memset(mi, 0x7f, sizeof(mi)); for (int i = 1; i \u0026lt;= n; i++) mx[0][i] = mi[0][i] = b[i]; lg[0] = -1; for (int i = 1; i \u0026lt;= n; i++) lg[i] = lg[i \u0026gt;\u0026gt; 1] + 1; for (int j = 1; j \u0026lt;= 21; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { mx[j][i] = max(mx[j - 1][i], mx[j - 1][i + (1 \u0026lt;\u0026lt; (j - 1))]); mi[j][i] = min(mi[j - 1][i], mi[j - 1][i + (1 \u0026lt;\u0026lt; (j - 1))]); } } //for (int i = 0; i \u0026lt; 4; i++, cout \u0026lt;\u0026lt; endl) // for (int j = 1; j \u0026lt;= n; j++) // cout \u0026lt;\u0026lt; mi[j][i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int query_mx(int l, int r) { if (l \u0026gt; r) return -inf; int d = r - l + 1; int g = lg[d]; return max(mx[g][l], mx[g][r - (1 \u0026lt;\u0026lt; g) + 1]); } int query_mi(int l, int r) { if (l \u0026gt; r) return inf; int d = r - l + 1; int g = lg[d]; return min(mi[g][l], mi[g][r - (1 \u0026lt;\u0026lt; g) + 1]); } bool check(int x) { int l = 1, r = 1; while (l \u0026lt;= n) { while (r \u0026lt;= n \u0026amp;\u0026amp; a[r] - a[l] \u0026lt;= x) { // cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; if (l - 1 + n - r \u0026lt;= m) if (max({a[r], query_mx(1, l - 1), query_mx(r + 1, n)}) - min({a[l], query_mi(1, l - 1), query_mi(r + 1, n)}) \u0026lt;= x) return true; r++; } if (r \u0026gt; l) r--; l++; } return false; } int main() { n = read(), m = read(); for (int i = 1; i \u0026lt;= n; i++) a[i] = read(); for (int i = 1; i \u0026lt;= n; i++) b[i] = read(); build(); //cout \u0026lt;\u0026lt; query_mi(1, n) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; query_mx(1, n) \u0026lt;\u0026lt; endl; int l = 0, r = 1e9, ans = 0; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (check(mid)) ans = mid, r = mid - 1; else l = mid + 1; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 矩阵游戏 Description 有一个 $(n-1)\\times(m-1)$ 的矩阵 $b_{i,j}$，其是由 $n\\times m$ 的矩阵 $a_{i,j}$ 生成得来的，生成方法为 $b_{i,j}=a_{i,j}+a_{i+1,j}+a_{i,j+1}+a_{i+1,j+1}$。\n现在给出矩阵 $b$，你需要构造出矩阵 $a$，且满足 $0\\leq a_{i,j}\\leq10^6$，或判断无解。\n$T$ 组数据。\n$T\\leq10,2\\leq n,m\\leq300,0\\leq b_{i,j}\\leq4\\times10^6$。\nSolution 这个构造题就很妙，首先考虑没有值域限制，那可以随便搞出来一组解。\n然后试图调整这组解，我们发现对每一行/列分别加上 $a,-a,a,-a\u0026hellip;$ 仍然能满足题目的限制，然后控制一下行和列的符号，让他们恰好相反，得到以下不等式：$0\\leq a_{i,j}\\pm x_i\\mp y_j\\leq10^6$，这样就可以差分约束了！\n具体点：\n列：\r-+-+-+\r+-+-+-\r-+-+-+\r+-+-+-\r-+-+-+\r+-+-+-\r行：\r+-+-+-\r-+-+-+\r+-+-+-\r-+-+-+\r+-+-+-\r-+-+-+ 时间复杂度 $O(nm(n+m))$。\nCode typedef long long ll; typedef unsigned long long ull; inline int read() { int x = 0; char ch = getchar(); for (; !isdigit(ch); ch = getchar()) ; for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x; } bool MEM1; namespace solve { const int maxn = 310; int n, m, b[maxn][maxn]; ll a[maxn][maxn]; struct edge { int y, w; }; vector\u0026lt;edge\u0026gt; e[maxn * maxn * 2]; inline void add(int x, int y, int w) { e[x].push_back({y, w}); } void clear() { memset(a, 0, sizeof(a)), memset(b, 0, sizeof(b)); for (int i = 1; i \u0026lt;= n + m + 1; i++) e[i].clear(); } inline int X(int i) { return i; } inline int Y(int i) { return i + n; } ll dis[maxn * maxn * 2]; int vis[maxn * maxn * 2], cnt[maxn * maxn * 2]; bool spfa() { memset(dis, 0x3f, sizeof(dis)), memset(vis, 0, sizeof(vis)), memset(cnt, 0, sizeof(cnt)); queue\u0026lt;int\u0026gt; q; q.push(n + m + 1), vis[n + m + 1] = 1, dis[n + m + 1] = 0; while (!q.empty()) { int x = q.front(); q.pop(); vis[x] = 0; for (auto k : e[x]) { int y = k.y, w = k.w; if (dis[x] + w \u0026lt; dis[y]) { dis[y] = dis[x] + w, cnt[y]++; if (cnt[y] \u0026gt; n + m + 1) return 1; if (!vis[y]) vis[y] = 1, q.push(y); } } } return 0; } void main() { n = read(), m = read(); for (int i = 1; i \u0026lt; n; i++) for (int j = 1; j \u0026lt; m; j++) b[i][j] = read(); for (int i = n - 1; i \u0026gt;= 1; i--) for (int j = m - 1; j \u0026gt;= 1; j--) a[i][j] = b[i][j] - a[i + 1][j] - a[i + 1][j + 1] - a[i][j + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if ((i + j) % 2 == 0) add(Y(j), X(i), 1e6 - a[i][j]), add(X(i), Y(j), a[i][j]); else add(X(i), Y(j), 1e6 - a[i][j]), add(Y(j), X(i), a[i][j]); } } for (int i = 1; i \u0026lt;= n; i++) add(n + m + 1, X(i), 0); for (int i = 1; i \u0026lt;= m; i++) add(n + m + 1, Y(i), 0); if (spfa()) { puts(\u0026#34;NO\u0026#34;); } else { puts(\u0026#34;YES\u0026#34;); for (int i = 1; i \u0026lt;= n; i++, puts(\u0026#34;\u0026#34;)) for (int j = 1; j \u0026lt;= m; j++) { cout \u0026lt;\u0026lt; a[i][j] + ((i + j) % 2 ? -1 : 1) * (dis[X(i)] - dis[Y(j)]) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } } } 图函数 Description 对于一张 $n$ 个点 $m$ 条边的有向图 $G$ (顶点从 $1 \\sim n$ 编号)，定义函数 $f(u, G)$ :\n初始化返回值 $cnt = 0$，图 $G′ = G$。 从 $1$ 至 $n$ 按顺序枚举顶点 $v$，如果当前的图 $G′$ 中，从 $u$ 到 $v$ 与从 $v$ 到 $u$ 的路径都存在，则将 $cnt + 1$，并在图 $G′$ 中删去顶点 $v$ 以及与它相关的边。 第 $2$ 步结束后，返回值 $cnt$ 即为函数值。 现在给定一张有向图 G,请你求出 $h(G) = f(1, G) + f(2, G) + \\dots + f(n, G)$ 的值。\n更进一步地，记删除（按输入顺序给出的）第 $1 \\sim i$ 条边后的图为 $G_i (1 \\leq i \\leq m)$，请你求出所有 $h(G_i)$ 的值。\n$2 \\leq n \\leq 1000, 1 \\leq m \\leq 2 \\times 10^5, 1 \\leq x_i, y_i \\leq n$。\nSolution 很神秘的一道题。\n我们先看一下 $f(u,G)$，首先如果 $v\u0026gt;u$ 肯定是没意义的，因为 $u$ 会被自己删除掉。\n发现点对 $(u,v)$ （$u\u0026gt;v$） 会对这个函数有贡献当且仅当存在一条不经过点标号大于 $v$ 的路径 $u\\rightarrow v$ 和 $v\\rightarrow u$。\n用反证法证明，假设路径上存在一个点 $k\u0026lt;v$，分两种情况：\n$k$ 已经被删掉，那么显然不成立。 $k$ 没被删掉，那么如果还能走回来，就会矛盾（画画图就知道了）。 这样对于 $h(G)$，我们只需要求出 $(u,v)$（$u\u0026gt;v$）的对数，其中 $(u,v)$ 满足上面条件。\n然后我们考虑删边这个事情，套路地，转化为加边。\n那么一个点对显然会对答案的前缀产生贡献，开始产生贡献的时间就是 $u$ 到 $v$ （以及 $v$ 到 $u$ ）所有路径上加入时间最晚的边的最大值，这里显然可以把边的删除时间当作一种“边权”。\n我试图用单源最短路解决这个问题，但是无果。\n回头看看满足条件的点对，即只考虑 $[v,n]$ 内点，求 $u,v$ 联通性以及互相联通的时间。\nemmm，floyd？好像从大到小枚举 $k$ 就能满足要求。\n时间复杂度 $O(n^3+m)$，注意常数优化即可通过本题。\n可能没讲清楚，看下面代码吧。\nCode #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #define min(x, y) ((x) \u0026lt; (y) ? (x) : (y)) #define max(x, y) ((x) \u0026gt; (y) ? (x) : (y)) using namespace std; namespace solve { const int maxn = 1e3 + 10; const int maxm = 2e5 + 10; const int inf = 1e6; int f[maxn][maxn], n, m; int ans[maxm]; void main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1, x, y; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, f[x][y] = i; for (int i = 1; i \u0026lt;= n; i++) f[i][i] = m + 1; for (int k = n; k \u0026gt;= 1; k--) { for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= (i \u0026lt; k ? n : k - 1); j++) // i j 至少一个小于 k f[i][j] = max(f[i][j], min(f[i][k], f[k][j])); } for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= i; j++) ans[min(f[i][j], f[j][i])]++; for (int i = m; i \u0026gt;= 1; i--) ans[i] += ans[i + 1]; for (int i = 1; i \u0026lt;= m + 1; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } } ","permalink":"https://luoyisu.github.io/posts/shengxuan-2021/","summary":"\u003cp\u003e目前只有 Day1 的题目。\u003c/p\u003e\n\u003cp\u003e感觉 Day1 的三道题很 CF。\u003c/p\u003e","title":"统一省选2021 A卷 题解"},{"content":"一个奇妙的建模题。\nDescription 给出数轴上三个棋子 $a,b,c$，你可以对棋子进行如下操作：\n将一个棋子跳到另一个棋子的另一侧，距离不变，而且不能同时跳过两个棋子。 问最少花费多少步能让三个棋子的位置变为 $x,y,z$。\n$-10^9\\leq a,b,c,x,y,z\\leq10^9$。\nSolution 看到这个题感觉非常神秘，手玩一下一个点的所有变化可以发现每个状态最多只有三种变化，如果距离两两相同就只有两种。\n然后发现其中一种变化相当于是倒退，而如果距离两两相同就没法倒退了。\n我们把距离两两相同的状态看作根，这样所有变化就变成了一棵二叉树。\n题目要求的就是两个状态在二叉树上的距离。\n再深究一下，往根的方向走会让状态的距离之和变小（例如 $a,b,c$ 变成 $b,2b-a,c$），我们有一个很显然的暴力就是对初始状态和结束状态分别走到根，然后看什么时候相交，这是 $O(n)$ 的（$n$ 是值域）。\n再观察一下变化树，发现往根的方向走一步相当于对距离执行一次辗转相减，那么我们用辗转相除就可以 $O(\\log n)$ 向上跳了。\n这样我们已经可以快速跳，并求出深度了，下一步是求 LCA，树剖之类的方法显然不好用，我们二分一下 LCA 就好了，复杂度 $O(\\log^2n)$。\nCode typedef long long ll; typedef unsigned long long ull; namespace solve { typedef array\u0026lt;ll, 3\u0026gt; arr; const int inf = 2e9; arr bg, ed; void out(const arr \u0026amp;a) { cout \u0026lt;\u0026lt; a[0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[1] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[2] \u0026lt;\u0026lt; endl; } arr jump(arr a, ll d, int \u0026amp;dep) { arr res = a; ll dis1 = a[1] - a[0], dis2 = a[2] - a[1]; // out(res); if (dis1 == dis2) return res; if (dis1 \u0026lt; dis2) { int p = min((dis2 - 1) / dis1, d); dis2 -= p * dis1, d -= p, dep += p; res[1] = res[2] - dis2, res[0] = res[1] - dis1; } else { int p = min((dis1 - 1) / dis2, d); dis1 -= p * dis2, d -= p, dep += p; res[1] = res[0] + dis1, res[2] = res[1] + dis2; } return d ? jump(res, d, dep) : res; } void main() { for (int i = 0; i \u0026lt; 3; i++) cin \u0026gt;\u0026gt; bg[i]; for (int i = 0; i \u0026lt; 3; i++) cin \u0026gt;\u0026gt; ed[i]; sort(bg.begin(), bg.end()), sort(ed.begin(), ed.end()); int dep1 = 0, dep2 = 0; arr rt1 = jump(bg, inf, dep1), rt2 = jump(ed, inf, dep2); //cout \u0026lt;\u0026lt; dep1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; dep2 \u0026lt;\u0026lt; endl; if (rt1 != rt2) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; if (dep1 \u0026lt; dep2) swap(bg, ed), swap(dep1, dep2); int dep = 0; bg = jump(bg, dep1 - dep2, dep); int l = 0, r = inf, ans = 0; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (jump(bg, mid, dep) == jump(ed, mid, dep)) r = mid - 1, ans = mid; else l = mid + 1; } cout \u0026lt;\u0026lt; dep1 - dep2 + ans * 2 \u0026lt;\u0026lt; endl; } } } ","permalink":"https://luoyisu.github.io/posts/luogu1852/","summary":"\u003cp\u003e一个奇妙的建模题。\u003c/p\u003e","title":"luogu1852 跳跳棋"},{"content":"前言 想感受一下敲公式的快感，于是有了这篇文章。\n只有一些最简单的应用。\n杜教筛 可以在低于线性的时间内筛积性函数前缀和，下文介绍原理：\n假设我们要求 $S(n)=\\sum_{i=1}^nf(i)$，其中 $f(x)$ 是个积性函数。\n然后对于任意一个积性函数 $g(x)$，都有： $$ \\begin{aligned} \\sum\\limits_{i=1}^n(fg)(i) =\u0026amp;\\sum\\limits_{i=1}^n\\sum\\limits_{d\\mid i}g(d)f(i/d)\\\\ =\u0026amp;\\sum\\limits_{d=1}^ng(d)\\sum\\limits_{d\\mid i}^nf(i/d)\\\\ =\u0026amp;\\sum\\limits_{d=1}^ng(d)S(\\lfloor n/d\\rfloor)\\\\ =\u0026amp;\\sum\\limits_{i=1}^ng(i)S(\\lfloor n/i\\rfloor) \\end{aligned} $$ 接下来有： $$ g(1)S(n)=\\sum\\limits_{i=1}^n(fg)(i)-\\sum_{i=2}^ng(i)S(\\lfloor n/i\\rfloor) $$ 需要构造合适的函数 $g(x)$ 来快速求解前一项，同时用整除分块计算后一项。\n实现方式是先筛出来这个函数的前 $n^{\\frac{2}{3}}$ 项，然后比这个数大的采用递归计算。用哈希表记忆化后的复杂度是 $O(n^{\\frac{2}{3}})$，我不会证明。\nluogu4213 sum Description 求 $\\sum_{i=1}^n\\mu(i),\\sum_{i=1}^n\\varphi(i)$，$n\u0026lt;2^{31}$。\nSolution $\\mu*1=\\epsilon$，第一个问题做完了。\n第二个虽然可以用 $id=\\varphi*1$ 做，但是用莫比乌斯反演更快一些：先求出 $\\sum_{i=1}^n\\sum_{j=1}^n[\\gcd(i,j)=1]$，简单莫反得到这个东西等于 $\\sum_{i=1}^n\\mu(i)\\lfloor n/d\\rfloor^2$，求出 $\\mu$ 的前缀和之后可以直接 $O(\\sqrt n)$ 求解。\n然后要求的答案是 $\\sum_{i=1}^n\\sum_{j=1}^i[\\gcd(i,j)=1]$，把刚刚的答案除以 $2$，再考虑一下 $i=j=1$ 就做完了。\nCode typedef long long ll; typedef unsigned long long ull; namespace solve { const int maxn = 1e7 + 10; long long pri[maxn], phi[maxn], vis[maxn], mu[maxn], tot; void init(const int n = 5e6) { mu[1] = phi[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { if (!vis[i]) pri[++tot] = i, mu[i] = -1, phi[i] = i - 1; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * pri[j] \u0026lt;= n; j++) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; phi[i * pri[j]] = phi[i] * pri[j]; break; } else { mu[i * pri[j]] = -mu[i]; phi[i * pri[j]] = phi[i] * (pri[j] - 1); } } } for (int i = 2; i \u0026lt;= n; i++) mu[i] += mu[i - 1], phi[i] += phi[i - 1]; } unordered_map\u0026lt;int, long long\u0026gt; mp; int sum_mu(int n) { if (n \u0026lt;= 5e6) return mu[n]; if (mp.count(n)) return mp[n]; long long res = 1; for (long long i = 2, j; i \u0026lt;= n; i = j + 1) { j = n / (n / i); res -= 1ll * (j - i + 1) * sum_mu(n / i); } return mp[n] = res; } long long sum_phi(int n) { if (n \u0026lt;= 5e6) return phi[n]; long long res = 0; for (long long i = 1, j; i \u0026lt;= n; i = j + 1) { j = n / (n / i); res += (sum_mu(j) - sum_mu(i - 1)) * 1ll * (n / i) * (n / i); } return (res + 1) / 2; } void main() { init(); int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; sum_phi(n) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum_mu(n) \u0026lt;\u0026lt; endl; } } } luogu3768 简单的数学题 Description 求： $$ \\sum_{i=1}^n\\sum_{j=1}^nij\\gcd(i,j) $$ 对 $p$ 取模的结果。$n\\leq10^{10}$。\nSolution 不说啥了，直接开始推。 $$ \\begin{aligned} ans =\u0026amp;\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{d=1,d|i,d|j}ijd[\\gcd(i,j)=d]\\\\ =\u0026amp;\\sum_{d=1}^nd\\sum_{i=1,d|i}^ni\\sum_{j=1,j|i}^nj[\\gcd(i,j)=d]\\\\ =\u0026amp;\\sum_{d=1}^nd^3\\sum_{i=1}^{\\lfloor n/d\\rfloor}i\\sum_{j=1}^{\\lfloor n/d\\rfloor}j[\\gcd(i,j)=1]\\\\ =\u0026amp;\\sum_{d=1}^nd^3\\sum_{i=1}^{\\lfloor n/d\\rfloor}i\\sum_{j=1}^{\\lfloor n/d\\rfloor}j\\sum_{k|i,k|j}\\mu(k)\\\\ =\u0026amp;\\sum_{d=1}^nd^3\\sum_{k=1}^{\\lfloor n/d\\rfloor}\\mu(k)\\sum_{i=1,k|i}^{\\lfloor n/d\\rfloor}i\\sum_{j=1,k|j}^{\\lfloor n/d\\rfloor}j \\end{aligned} $$ 设 $f(x)=\\dfrac{x^2(x+1)^2}{4}$。 $$ \\begin{aligned} ans=\u0026amp;\\sum_{d=1}^nd^3\\sum_{k=1}^{\\lfloor n/d\\rfloor}\\mu(k)k^2f(\\lfloor\\dfrac{n}{dk}\\rfloor) \\end{aligned} $$ 设 $T=dk$。 $$ \\begin{aligned} ans \u0026amp;=\\sum_{d=1}^nd\\sum_{T=1,d|T}^{\\lfloor n/d\\rfloor}\\mu(\\dfrac{T}{d})T^2f(\\lfloor\\dfrac{n}{T}\\rfloor)\\\\ \u0026amp;=\\sum_{T=1}^nf(\\lfloor\\dfrac{n}{T}\\rfloor)T^2\\sum_{d|T}d\\times\\mu(\\dfrac{T}{d}) \\end{aligned} $$ 由 $id*\\mu=\\varphi$，有： $$ ans=\\sum_{T=1}^nf(\\lfloor\\dfrac{n}{T}\\rfloor)T^2\\varphi(T) $$ 设 $g(x)=x^2\\varphi(x)$，我们需要求出它的前缀和，开始杜教筛。\n设 $h(x)=x^2$，那么 $(hg)(n)=n^2\\sum_{d|n}\\varphi(d)$，又由于 $\\varphi1=id$，有 $(h*g)(x)=x^3$，这玩意的前缀和很好算。\n然后就做完了。\nCode namespace solve { const int maxn = 1e7 + 10; int mod; int vis[maxn]; ll phi[maxn]; int pri[maxn], tot; ll n; void init(const int n = 1e7) { phi[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { if (!vis[i]) pri[++tot] = i, phi[i] = i - 1; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * pri[j] \u0026lt;= n; j++) { vis[i * pri[j]] = 1; if (i % pri[j]) phi[i * pri[j]] = phi[i] * phi[pri[j]]; else { phi[i * pri[j]] = phi[i] * pri[j]; break; } } } for (int i = 2; i \u0026lt;= n; i++) phi[i] = 1ll * i * i % mod * phi[i] % mod, phi[i] += phi[i - 1], phi[i] %= mod; } ll qpow(ll a, ll x, ll p) { ll res = 1; for (; x; x \u0026gt;\u0026gt;= 1, a = a * a % p) if (x \u0026amp; 1) res = res * a % p; return res; } ll S(ll x) { return x * (x + 1) / 2 % mod; } inline ll f(ll x) { return S(x % mod) * S(x % mod) % mod; } ll inv6; inline ll h(ll x) { x %= mod; return 1ll * x * (x + 1) % mod * (2 * x + 1) % mod * inv6 % mod; } unordered_map\u0026lt;ll, ll\u0026gt; mp; ll sum(ll n) { if (n \u0026lt;= 1e7) return phi[n]; if (mp.count(n)) return mp[n]; ll res = f(n); for (ll i = 2, j; i \u0026lt;= n; i = j + 1) { j = n / (n / i); res -= (h(j) - h(i - 1) + mod) % mod * sum(n / i) % mod; res %= mod; } return mp[n] = (res + mod) % mod; } void main() { cin \u0026gt;\u0026gt; mod \u0026gt;\u0026gt; n; init(); inv6 = qpow(6, mod - 2, mod); ll ans = 0; for (ll i = 1, j; i \u0026lt;= n; i = j + 1) { j = n / (n / i); ans += (sum(j) - sum(i - 1)) % mod * f(n / i) % mod; ans %= mod; } ans += mod, ans %= mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } NOI2016 循环之美 暂时不会推，先咕了。\n","permalink":"https://luoyisu.github.io/posts/du/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e想感受一下敲公式的快感，于是有了这篇文章。\u003c/p\u003e\n\u003cp\u003e只有一些最简单的应用。\u003c/p\u003e","title":"杜教筛简单学习笔记"},{"content":"概述 我和杜大佬一队，各做了 $4$ 道题，但总体来说我还是被他带飞了。\n赛前 我们总共有 $8$ 人，打算分成 $332$，我恰好就在那个 $2$ 里，感觉要被吊打了（）\n又发现其他的高一同学们也开始组队了，好害怕。。。不垫底就是胜利！\n起队名倒是很愉快，因为我们两个的码风非常优良，所以起名为 Go and learn our code style（然而事后发现其他人看不了我们的代码。。）。\n大工的队伍为什么混进来了嘉心糖（）\n赛时 分工是我看 ABCDE、杜大佬看 FGHIJK，发现还有人在一起 VP，看来这似乎是一场复现赛。\nA 题面长的要死，只看懂了自走棋，先放放再说；\nB 就是一个分类讨论题，随便写了一发发现没过样例，于是开始大力讨论所有情况，27 min 的时候交了一发，然后光荣 WA，稍微看了一下发现有个字母打错了，改了之后就 AC 了。。\n看了看榜，B 确实是水题，然后就没看出什么有用信息了。\n杜大佬先看了 G 题，写了个代码之后发现有问题，于是扔了，看有人过了 H 就去做 H 了，贡献一发罚时之后 AC 了。\n做完 B 之后我看了看 C，数学题，不明所以，D，树上不知道啥玩意，E，不知道啥玩意的计数。\n去看了 A，似乎是比较可做的一个模拟题，看了看之后发现，这 tm 不是廊桥分配加强版吗？？？？？\n我要一雪前耻，写起了权值线段树。\n不得不说这题细节还是很多的。。。\n中途杜大佬似乎在做 I 题，来向我问一些数学问题，我不会，感到无比愧疚。。\n接着写我的 A，然后交了几发，贡献了一波罚时，修了几个 bug 还是 AC 不了，我十分莫名其妙。。。\n大概 1.5h 的时候，杜大佬对着样例猜了个 I 结论，交了一发，AC 了！！\n我接着调我的 A 题，怀疑格式问题，把样例输出和我的输出用 diff 看了一下，没啥问题啊，我只是多了行末空格和文末回车而已。\n反正没啥事情干，就把多余的行末空格给改了，摆烂交了一发，也是在 1.5h 左右，居然 AC 了？？？？？？？\n这评测有毒啊。。不管了，吃了 $3$ 发罚时可算是过了。。。\n杜大佬去做 J 题了，我瞅了眼，好像是什么计数题，完全不懂。。。\n我决定把数学题放一放，去看看 D，然后发现这玩意是个树上染色，想了想之后发现有一个看上去挺对的贪心，写了一发过了，好开心。\n杜大佬给我看了看一个式子，说怎么快速枚举。。。\n我和他想了想也没得出什么结果，最后还是只能暴力，感觉这暴力应该是能过的。\n于是他开始写了，我没法帮他，试图推了推 C 题，不是很懂。。E 还是不会、F 据说是个大阴间题、K 看了看也有点莫名其妙。。\n看了看榜，G 题似乎是个可做题，就去做了。\n这期间（不到 3.5h 的时候）杜大佬把 J 一发过了！好耶！被杜大佬带飞了！\nG 是个玩游戏题，手玩了一波样例感觉发现了些规律，然后感觉挺对的就开始写了，结果 WA 了 $4$ 发，最终在 3.5h 多的时候过了。\n现在打算让杜大佬做 C 题，我去看看 K 题。。\n不一会他就会了 C，被带飞了！！然后将近 4.5h 的时候一发过了 C，好耶！！！！\n然而我的 K 还是无果，后来发现有一个在数据范围里的提示，这下似乎可做了一些。\n后来和杜大佬一起在 E、K 之间横跳，也没想出来啥，摆烂了。\n赛后 反正是有惊无险拿到了 rank1，主要 kh 他们队被 A 题困住了（因为那个行末空格），所以有点胜之不武。。。\n但总之还是挺开心的，被带飞了，哈哈！\n总结 计数，数学，DP。。。\n","permalink":"https://luoyisu.github.io/posts/220222-contest-with-dut/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e我和杜大佬一队，各做了 $4$ 道题，但总体来说我还是被他带飞了。\u003c/p\u003e","title":"220222 和大连理工大学线上 PK 记"},{"content":"前言 因为过于摆烂，所以记录一下警醒自己。\n赛时 8:30 拿到了压缩包，发现有一个文件夹里有一堆东西，很明显是交互题了。\n开题，发现 T1 奇妙构造，然后没大样例，没 spj，一看到括号就头大，跳了。\nT2 明显数据结构题，有人说背景和坦克世界有关，是 lxl 出的，大概看了看就扔了。\n对 T3 比较感兴趣，认真读了题，没啥想法，似乎需要确定一个很好的策略？（后来发现其实并不太对）\n想了想也没想出来啥策略。。。。。\n当时有两个很莫名其妙的想法：\n想办法多排除不合法的，最后在剩下的单词里随机一个； 直接在当前可能合法的字符串中找一个最有可能的返回。 回去看 T2，好像是三道题里最正经的。\n想了想发现我会莫队，好像能搞到 $O(n\\sqrt n\\log n)$​，一看数据范围，这能过几分全看常数啊。\n其实这玩意要是想优化到 $O(n\\sqrt n)$ 就是要把查询前驱后继的复杂度搞成 $O(1)$，然后前几天听过用链表+回滚莫队平衡复杂度的一道题，但我数据结构水平是真不行，想不出来怎么平衡复杂度。\n写了个 set 做法，常数大到爆炸，$10^5$ 都过不去。\n后来得知一个叫树状数组上二分的科技，然后写写写调调调卡卡卡，常数小了很多，在我的机子上跑 $10^5$ 需要 $3$ 秒，这下应该是有 $50$ 分了。。。\n时间所剩无几，稍微想了想 T1，没啥收获，写了 $25$ 分暴力。。。\n还剩一个小时，去肝 T3 吧。\n想着先咸鱼一个纯随机选的算法，然后一直调到结束（？）\n然后就很悲惨地结束了，到死都不知道怎么回事。\n可能太着急了吧。。。。\n赛后 听说 T3 乱搞能得很多很多分？\n好吧，我没搞出来，也许应该多留点时间搞。。。\n然后出分了：\n$10+30+0=40$？？？？？\n哦我 T1 数组开小了啊那没事了。\n那 T2 是什么情况？？？？？？？？？\n为什么我少了 $20$ 分？？？？？\n罢了罢了，接着去搞 T3 了，真好玩.jpg。\n总结 遇到陌生的模型转化能力还是欠缺啊（T1），括号序列转化为二叉树我确实想不到。。。也许需要有意去想办法转化？\nT2 其实没啥问题，已经尽最大努力了。\n怎么说呢，对题目难度还是没把握，T3 这种乱搞题。。。还是太谨慎了？也许应该大胆一点。\n真有点《遇到交互摆大烂》啊，明明我也做过好几道交互题来着。\n但是我并不是胆大心细的人啊。。。\n小错误犯了一堆，以后应该搞一个注意事项合集了。\n","permalink":"https://luoyisu.github.io/posts/wc2022/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e因为过于摆烂，所以记录一下警醒自己。\u003c/p\u003e","title":"WC2022线上(摆烂)测试总结"},{"content":"好久没写总结了，于是来写一发。\n概述 期望 $0+100+100=200$，实际 $0+0(100)+0=0(100)$。\n摆大烂，挂大分。\n还是太菜了，码力不够，思维也不够。\n赛时 首先看到 T1 是一个期望什么玩意，直接不想看，跑了。（摆烂 x1）\n然后看到 T2 是一个什么莫名其妙的像是计算几何的题，溜了。（摆烂 x2）\n又发现 T3 是一个很怪的像是模拟题的鬼东西，不想看，再见。（摆烂 x3）\n于是发现 T2 $n\\leq8$，我当场选择用模拟退火摆烂。\n开始码码码，大概过了一个小时才码完，但是因为没有大样例，没法调参。。。\n后来手造数据试图调参。。。\n然后想了想 T3 发现是大模拟+2-SAT，我直接码码码。\n码到一半回去把退火完善了一下，改成随温度降低调整幅度减小，感觉稳多了。\n然后一直在码 T3，其实也不是特别长，但我还是太菜了。。。\n后来还有一个多小时的时候过了样例，我也不想管了，直接开摆。\n然后不想看 T1 了，开摆！！\n赛后 哈哈我爆零了。\n哈哈我 T2 因为没有 include \u0026lt;ctime\u0026gt; CE了。\n哈哈我 T3 不知道为什么 WA 了。\n摆烂了。\n讲评的时候发现 T1 确实不是那么难，也许自己在 DP 上还是较弱。\n总结 别摆烂了！！！\n","permalink":"https://luoyisu.github.io/posts/220120-contest/","summary":"\u003cp\u003e好久没写总结了，于是来写一发。\u003c/p\u003e\n\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e期望 $0+100+100=200$，实际 $0+0(100)+0=0(100)$。\u003c/p\u003e\n\u003cp\u003e摆大烂，挂大分。\u003c/p\u003e\n\u003cp\u003e还是太菜了，码力不够，思维也不够。\u003c/p\u003e","title":"220120摆烂模拟赛"},{"content":"Description 有一棵初始为空的树，每次新给出一个点的父亲和它连向父亲边的权值以及这个点的权值，每次加点之后询问有多少点满足 $dis(i,j)\\leq val_i+val_j$，强制在线。\n$n\\leq10^5$。\nSolution 如果树是静态的，那么这是个点分治裸题：把条件拆成 $dis(i,root)-val_i\\leq -dis(root, j)+val_j$，用平衡树维护即可。\n现在我们动态加儿子，可以尝试用点分树维护。当一个点分树上一个子树的大小过于不平衡直接重构这个点分树即可。\n复杂度 $O(n\\log^3n)$。\n听起来很简单是吧，实际上写起来还是有点复杂的。\n按照常规套路，在每个点维护两棵平衡树，分别代表这个点在点分树上子树内所有点在原树上到该点的信息、这个点在点分树上子树内所有点在原树上到原树上该点父亲的信息，然后查询的时候减一下去掉重复统计的部分。\n重构怎么办呢？\n感觉上我们需要把整个子树都重建一遍，别的还好说，但我们要重构的这棵树的根到他父亲的信息似乎不是很好维护，然后有一个 trick，直接把原来的平衡树挪到新根上就好了！\n平衡树显然需要写一个垃圾回收。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; using std::cerr; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; int dep[maxn]; struct edge { int y, w; }; std::vector\u0026lt;edge\u0026gt; e[maxn]; namespace tree { int father[maxn][20], dis_rt[maxn]; inline void add(int x, int y, int w) { e[x].push_back({y, w}), e[y].push_back({x, w}); } void add_node(int x, int fa, int w) { father[x][0] = fa; if (fa) add(x, fa, w); dep[x] = dep[fa] + 1, dis_rt[x] = dis_rt[fa] + w; for (int i = 1; i \u0026lt;= 18; i++) father[x][i] = father[father[x][i - 1]][i - 1]; } int lca(int x, int y) { if (dep[x] \u0026lt; dep[y]) std::swap(x, y); int d = dep[x] - dep[y]; for (int i = 0; d; d \u0026gt;\u0026gt;= 1, i++) if (d \u0026amp; 1) x = father[x][i]; if (x == y) return x; for (int i = 18; i \u0026gt;= 0; i--) if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; return father[x][0]; } int dis(int x, int y) { return dis_rt[x] + dis_rt[y] - 2 * dis_rt[lca(x, y)]; } } using tree::dis; namespace Treap { int top; struct Node { int val, siz, rnd, num; Node *son[2]; inline void push_up() { siz = num; if (son[0]) siz += son[0]-\u0026gt;siz; if (son[1]) siz += son[1]-\u0026gt;siz; } } a[maxn * 100], *bin[maxn * 100]; inline Node *new_node(int val) { Node *res = bin[--top]; res-\u0026gt;son[0] = res-\u0026gt;son[1] = nullptr; res-\u0026gt;siz = res-\u0026gt;num = 1, res-\u0026gt;val = val, res-\u0026gt;rnd = rand(); return res; } inline void del_node(Node *p) { bin[top++] = p; } inline void rotate(Node *\u0026amp;x, int d) // 0:right 1:left { Node *t = x-\u0026gt;son[d]; x-\u0026gt;son[d] = t-\u0026gt;son[d ^ 1], t-\u0026gt;son[d ^ 1] = x; x-\u0026gt;push_up(), t-\u0026gt;push_up(); x = t; } void insert(Node *\u0026amp;x, int val) { if (!x) { x = new_node(val); return; } x-\u0026gt;siz++; if (x-\u0026gt;val == val) { x-\u0026gt;num++; return; } int d = val \u0026gt; x-\u0026gt;val; insert(x-\u0026gt;son[d], val); if (x-\u0026gt;son[d]-\u0026gt;rnd \u0026lt; x-\u0026gt;rnd) rotate(x, d); } void remove(Node *\u0026amp;x) { if (!x) return; remove(x-\u0026gt;son[0]), remove(x-\u0026gt;son[1]); del_node(x), x = nullptr; } int rank(Node *x, int k) { if (!x) return 0; if (k \u0026lt; x-\u0026gt;val) return rank(x-\u0026gt;son[0], k); else return rank(x-\u0026gt;son[1], k) + x-\u0026gt;num + (x-\u0026gt;son[0] ? x-\u0026gt;son[0]-\u0026gt;siz : 0); } struct init { init() { for (int i = 0; i \u0026lt; maxn * 100; i++) bin[top++] = \u0026amp;a[i]; } } init_; } Treap::Node *fa[maxn], *self[maxn]; using Treap::insert; using Treap::rank; using Treap::remove; int val[maxn]; int father[maxn]; namespace divide { std::set\u0026lt;int\u0026gt; son[maxn]; int time, is[maxn], tot, all, siz[maxn], root, mx[maxn]; int vis[maxn]; void remove(int x) { is[x] = time, tot++; remove(self[x]); for (auto i : son[x]) remove(i), remove(fa[i]); son[x].clear(); } void get_siz(int x, int fa, int dep) { siz[x] = 1, mx[x] = 0; for (auto v : e[x]) if (is[v.y] == time \u0026amp;\u0026amp; vis[v.y] != time \u0026amp;\u0026amp; v.y != fa) get_siz(v.y, x, dep + v.w), siz[x] += siz[v.y], mx[x] = std::max(mx[x], siz[v.y]); mx[x] = std::max(mx[x], all - siz[x]); if (mx[x] \u0026lt; mx[root]) root = x; } void dfs(int x, int fa, int dep, Treap::Node *\u0026amp;p) { insert(p, dep - val[x]); for (auto v : e[x]) if (is[v.y] != time || v.y == fa || vis[v.y] == time) continue; else dfs(v.y, x, dep + v.w, p); } void solve(int x) { vis[x] = time; dfs(x, 0, 0, self[x]); for (auto v : e[x]) { if (is[v.y] != time || vis[v.y] == time) continue; root = 0, mx[root] = 1 \u0026lt;\u0026lt; 30, all = siz[v.y]; get_siz(v.y, x, 0), get_siz(root, x, 0); dfs(v.y, 0, v.w, fa[root]), father[root] = x, son[x].insert(root); solve(root); } } void rebuild(int x) { time++; tot = 0; int f = father[x]; son[f].erase(x); Treap::Node *tmp = fa[x]; fa[x] = nullptr; remove(x); root = 0, mx[root] = 1 \u0026lt;\u0026lt; 30, all = tot; get_siz(x, 0, 0), get_siz(root, 0, 0); father[root] = f, son[f].insert(root); fa[root] = tmp; solve(root); } } int add(int x, int f, int w, int vall) { tree::add_node(x, f, w); val[x] = vall; divide::son[father[x] = f].insert(x); int res = rank(self[x], vall); insert(self[x], -vall); for (int i = x; father[i]; i = father[i]) { int f = father[i], w = dis(x, f); res += rank(self[f], vall - w); res -= rank(fa[i], vall - w); insert(fa[i], w - vall), insert(self[f], w - vall); } int flag = 0; for (int i = x; father[i]; i = father[i]) if (self[i]-\u0026gt;siz \u0026gt; self[father[i]]-\u0026gt;siz * 0.8) flag = father[i]; if (flag) divide::rebuild(flag); return res; } int main() { int u; scanf(\u0026#34;%d\u0026#34;, \u0026amp;u); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); long long ans = 0; for (int i = 1, a, c, r; i \u0026lt;= n; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;c, \u0026amp;r); a = a ^ (ans % 1000000000); printf(\u0026#34;%lld\\n\u0026#34;, ans += add(i, a, c, r)); } } ","permalink":"https://luoyisu.github.io/posts/uoj55/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e有一棵初始为空的树，每次新给出一个点的父亲和它连向父亲边的权值以及这个点的权值，每次加点之后询问有多少点满足 $dis(i,j)\\leq val_i+val_j$，强制在线。\u003c/p\u003e\n\u003cp\u003e$n\\leq10^5$。\u003c/p\u003e","title":"uoj55 紫荆花之恋"},{"content":"前言 不能完全不管字符串，就硬着头皮学一学。\n完全未完工。\n后缀数组 后缀数组主要指的是两个数组：\n$sa_i$ 表示排名第 $i$ 小的后缀的起始位置；\n$rk_i$ 表示从 $i$ 开始的后缀的排名。\n这里的后缀大小比较的是字典序。\n说白了以上两个数组的意思分别是 kth 和 rank。\n很显然 $sa_{rk_i}=rk_{sa_i}=i$\n建议好好记住这个定义，否则以后可能绕来绕去就糊涂了。\n后缀数组求法 不讲线性求法了（我也不会），我们来说一说常见好写的倍增法。\n我们不是要求 $sa$ 吗，显然有 $sa$ 数组中两个下标 $i\u0026lt;j$ 的条件是 $rk_{sa_i}\u0026lt;rk_{sa_j}$。\n假设我们对从每个字符开始长度为 $w$ 的串排好序了。\n然后我们试图得到长度为 $2w$ 的 $sa$ 数组。\n我们只需要把 $sa$ 数组以 $rk_{i}$ 为第一关键字，$rk_{i+w}$ 为第二关键字排序就行了。得出 $sa$ 数组之后再更新一下 $rk$ 数组即可。\n听起来很简单啊，算一下复杂度，如果用快速排序，时间复杂度是 $O(n\\log^2n)$ 的。\n但是！如果我们用基数排序而不是快速排序，时间复杂度会优化到 $O(n\\log n)$。\n这个基数排序就是万恶之源了。\n啥是基数排序呢？就是对于多关键字的排序，先对第二关键字稳定排序，再对第一关键字稳定排序，就能对整个序列稳定排序。\n然后如果对每个关键字排序时使用计数排序，复杂度是 $O(n)$，那么在求 SA 的时候排序复杂度也就是 $O(n)$ 了。\n然后就是比较绕的地方了，如果头脑很困不清醒（比如我）可能就会被绕进去。\n计数排序的原理说白了也很简单：算出比每个值小（或者说优先级更高）的值有几个，然后把这个值放到正确的位置里。\n在这里我们需要计数的是 $rk$ 的值。\nemmmm好像没什么可以说的了，该看代码理解了。\n借用 OI Wiki 上的一份代码：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; char s[N]; int n, sa[N], rk[N \u0026lt;\u0026lt; 1], oldrk[N \u0026lt;\u0026lt; 1], id[N], cnt[N]; int main() { int i, m, p, w; scanf(\u0026#34;%s\u0026#34;, s + 1); n = strlen(s + 1); m = max(n, 300); for (i = 1; i \u0026lt;= n; ++i) ++cnt[rk[i] = s[i]]; for (i = 1; i \u0026lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i \u0026gt;= 1; --i) sa[cnt[rk[i]]--] = i; for (w = 1; w \u0026lt; n; w \u0026lt;\u0026lt;= 1) { memset(cnt, 0, sizeof(cnt)); for (i = 1; i \u0026lt;= n; ++i) id[i] = sa[i]; for (i = 1; i \u0026lt;= n; ++i) ++cnt[rk[id[i] + w]]; for (i = 1; i \u0026lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i \u0026gt;= 1; --i) sa[cnt[rk[id[i] + w]]--] = id[i]; // 对第二关键字进行计数排序 memset(cnt, 0, sizeof(cnt)); for (i = 1; i \u0026lt;= n; ++i) id[i] = sa[i]; for (i = 1; i \u0026lt;= n; ++i) ++cnt[rk[id[i]]]; for (i = 1; i \u0026lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i \u0026gt;= 1; --i) sa[cnt[rk[id[i]]]--] = id[i]; // 对第一关键字进行计数排序 memcpy(oldrk, rk, sizeof(rk)); for (p = 0, i = 1; i \u0026lt;= n; ++i) { // 更新 rk 数组时需要注意：完全相同的串排名也应该一样。 if (oldrk[sa[i]] == oldrk[sa[i - 1]] \u0026amp;\u0026amp; oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) { rk[sa[i]] = p; } else { rk[sa[i]] = ++p; } } } for (i = 1; i \u0026lt;= n; ++i) printf(\u0026#34;%d \u0026#34;, sa[i]); return 0; } 然后上面的代码常数是很大的。\n有以下的常数优化：\n第二关键字无需计数排序，只需把超过范围的放到前面，剩下的按照原先顺序填进去即可。 优化值域：每次计数排序的值域可以设为每一次更新 $rk$ 时不同元素的个数。 用一个数组存下来 $rk_{id_i}$：减少不连续内存访问（我的盲区）。 用函数 cmp 来计算是否重复：减少不连续内存访问（我的盲区）。 若排名都不相同可直接生成后缀数组：如果 $rk$ 的值域已经达到了 $[1,n]$，那么已经排好序，无需接着生成数组。 下面是我写的优化过常数的代码：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using std::cerr; using std::cin; using std::cout; using std::endl; const int maxn = 1e6 + 10; char s[maxn]; int n, p, sa[maxn], rk[maxn \u0026lt;\u0026lt; 1], tmp[maxn], cnt[maxn], oldrk[maxn \u0026lt;\u0026lt; 1], val[maxn]; inline bool equ(int i, int j, int dep) { return oldrk[i] == oldrk[j] \u0026amp;\u0026amp; oldrk[i + dep] == oldrk[j + dep]; } int main() { scanf(\u0026#34;%s\u0026#34;, s + 1); n = strlen(s + 1); int m = 300, p; for (int i = 1; i \u0026lt;= n; i++) cnt[rk[i] = s[i]]++; for (int i = 1; i \u0026lt;= m; i++) cnt[i] += cnt[i - 1]; for (int i = n; i \u0026gt;= 1; i--) sa[cnt[rk[i]]--] = i; for (int dep = 1; dep \u0026lt;= n; dep \u0026lt;\u0026lt;= 1, m = p) { p = 0; for (int i = n - dep + 1; i \u0026lt;= n; i++) // 把超过去的放到前面 val[++p] = i; for (int i = 1; i \u0026lt;= n; i++) // 剩下的按照原顺序填进去 if (sa[i] \u0026gt; dep) val[++p] = sa[i] - dep; // val 是按照第二关键字排序后的 sa 数组的值 memset(cnt, 0, sizeof(cnt)); for (int i = 1; i \u0026lt;= n; i++) cnt[tmp[i] = rk[val[i]]]++; // tmp 是常数优化用的 for (int i = 1; i \u0026lt;= m; i++) cnt[i] += cnt[i - 1]; // 对计数排序用的数组求前缀和来得到元素的位置 for (int i = n; i \u0026gt;= 1; i--) sa[cnt[tmp[i]]--] = val[i]; // 对于排序前数组的每个值分配一个新位置 std::swap(rk, oldrk); p = 0; for (int i = 1; i \u0026lt;= n; i++) rk[sa[i]] = equ(sa[i], sa[i - 1], dep) ? p : ++p; // 更新 rk 数组 if (p == n) // 最后一个优化 break; } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, sa[i]); return 0; } 应用 咕咕咕\n","permalink":"https://luoyisu.github.io/posts/suffix-array/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e不能完全不管字符串，就硬着头皮学一学。\u003c/p\u003e\n\u003cp\u003e完全未完工。\u003c/p\u003e","title":"后缀数组学习笔记"},{"content":"Description 给出一些测试点的输入文件和输出文件以及每个测试点要实现的功能编号，你需要写一个程序通过这些给出的测试点。\n链接，这个题在 loj 上体验很好，洛谷上虽然也有这个题但容易被卡常。\nSolution 很明显：功能开头是 $1$ 还是 $2$ 区别很大，我们分开来看。\ninput1~7 input1~3 这三个点都是 $\\text{1\\\\_998244353}$，我们看一下数据。\ninput：0 1 2 3\noutput：1 19 361 6859\n很明显是要求 $19^n$。\n发现肯定有一个模数，那很容易想到就是 $998244353$​。\n写一个快速幂，这三个点就能过了。\n注意第三个点指数很大，根据欧拉定理，我们只需要在读入的时候对 $998244352$ 取模即可。\ninput4 这个点是 $1?$。\n看一下比较小的数据，发现还是求的 $19^n$，而模数不一样了，联想到由 $998244353$ 变成了 $?$，这个点看起来是让我们确定模数。\n找到最大的数，发现是 $10^6$ 级别的，且不超过 $2\\times10^6$，那我们可以尝试枚举这个模数，判断一下 $19^{627811703016764290815178977207148434322}$ 是否等于 $642666$ 即可。\n写了一个 python 代码跑：\ndef qpow(a, x, p): res = 1 while x \u0026gt; 0: if x % 2 == 1: res = res * a % p x \u0026gt;\u0026gt;= 1 a = a * a % p return res for i in range(10 ** 6, 2 * 10 ** 6): if qpow(19, 627811703016764290815178977207148434322, i) == 642666: print(\u0026#39;ans\u0026#39;, i) break #print(\u0026#39;check\u0026#39;, i) if i % 10000 == 0: print(i) 能找到一个模数是 $1145141$，当看到 $114514$ 我们就知道应该是找对了。\n模数找到了，这个点还有一个问题：指数太大。\n我们看一下 $1145141$ 这个数，写一个判断素数的程序，发现是个质数，且和 $19$ 互质，那么根据欧拉定理，我们只需要在读入的时候对 $1145141-1$ 取模即可。\n这个点也就很愉快地搞定了。\ninput5 实际上这个点可能是整道题最难的一个点了。\n这个点是 $1?+$。\n联系上一个点，看一下数据，发现似乎还是让我们确定模数，但模数似乎很大很大，最大的答案达到了 $5211500658258874318$，枚举肯定是不行了。\n我们想一想怎么样能确定模数。。。\n可以想到一个方法：找到两个相邻的指数，根据答案来确定质数。如果不懂就接着往下看。\n我们打一个表：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef __int128_t lll; lll read() { lll x = 0, f = 1; char ch = getchar(); for (; !isdigit(ch); ch = getchar()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x * f; } void write(lll x) { if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } inline void space() { putchar(\u0026#39; \u0026#39;); } inline void endln() { putchar(\u0026#39;\\n\u0026#39;); } int n = 10000; const int maxn = 1e4 + 10; pair\u0026lt;lll, lll\u0026gt; a[maxn]; inline lll myabs(lll x) { return x \u0026lt; 0 ? -x : x; } int main() { lll res = 0; freopen(\u0026#34;tmp5.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); for (int i = 1; i \u0026lt;= n; i++) a[i].first = read(); freopen(\u0026#34;software5.ans\u0026#34;, \u0026#34;r\u0026#34;, stdin); for (int i = 1; i \u0026lt;= n; i++) { a[i].second = read(); //if (myabs(a[i].first - a[i].second) \u0026lt; 10000000000) // write(a[i].first), putchar(\u0026#39; \u0026#39;), write(a[i].second), putchar(\u0026#39;\\n\u0026#39;); } std::sort(a + 1, a + 1 + n); for (int i = 2; i \u0026lt;= n; i++) if (a[i].first - a[i - 1].first \u0026lt; 5) write(a[i - 1].first), space(), write(a[i - 1].second), space(), write(a[i].first), space(), write(a[i].second), endln(); } /* 5211500658258874318 */ 发现有这么一组数据：\n264708066 1996649514996338529\r264708068 1589589654696467295 也就是说，设 $1996649514996338529=a,1589589654696467295=b$，有 $19\\times19a\\equiv b\\pmod p$。\n那么 $p\\mid19\\times19a-b=719200885258981741674$​，又由于 $p\u0026gt;5211500658258874318$​​，所以我们只需要枚举一个小于等于 $138$ 的约数就行。\n然后拿 python 一算，好家伙，$138$ 正好是一个约数，我们把 $719200885258981741674/138=5211600617818708273$ 这个数放进我们的程序里试一下，它居然过了，真好。\n那么这个点也就过了。\n以上五个点可以写成一个函数：传入模数，求 $19^n\\pmod p$。\ninput6~7 这两个点给出了模数 $998244353$，但特殊之处在于这个 $\\text{wa}$，看一下数据发现出现了负数，再看看题目上的提示，很明显是溢出导致的。\n具体是哪里溢出了呢？\n首先肯定不是快速幂，你可以试一试，也可以用这个思路去想：每个人的快速幂写法会有差异，不能用这个出题。\n那就只剩下暴力一个个乘上去了。。。\n试一下，发现貌似是对的。\n也就是说在 res = res * 19 % mod 这一步中没开 long long 导致溢出了。\n这玩意肯定没法用快速幂算，但是考虑到一个事情：这个溢出相当于对 $2^{32}$ 取模，那么就会产生循环节（因为这个数不是质数，欧拉函数不是它减去 $1$）。\n我们可以用 map 来判断循环节，反正循环节应该不是很长：\ntypedef long long ll; typedef __int128_t lll; typedef unsigned int ui; typedef unsigned long long ull; int n = 10000; const int maxn = 1e4 + 10; const int mod = 998244353; pair\u0026lt;lll, lll\u0026gt; a[maxn]; inline lll myabs(lll x) { return x \u0026lt; 0 ? -x : x; } inline int errmul(int a, int b) { return (int)((ui)a * (ui)b); } map\u0026lt;int, int\u0026gt; mp; int main() { int now = 1; mp[0] = 1; for (int i = 1; ; i++) { now = errmul(now, 19) % mod; if (mp.count(now)) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mp[now] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i - mp[now] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; now \u0026lt;\u0026lt; endl; return 0; } mp[now] = i; } } 然后找到循环节开始位置是 $55245$，长度是 $45699$。\n对于这两个点，直接暴力找循环节，对于一个询问，直接小学数学取个模就行。\n那么这前 $7$ 个点就过了，$41$ 分到手。\ninput8~16 这些点都有一个共同特征：给一个区间，问区间内所有数的一些性质。\n分开来看三种功能：\ninput8~10 这三个点的关键信息是 $\\text{p}$，看一下小数据：\ninput：2 10\noutput：pp.p.p...\n很明显了吧，是求区间内所有质数。\n发现数是非常大的，但区间不大，只有 $10^6$ 级别。\n那我们直接对每个区间内的所有数进行 Miller-Rabin 素性测试就行了。\n我一般找 $10$ 个随机数测试，但本机速度有点慢，跑不过去，于是进行了一波卡常：不使用随机数，而是用固定的数来测试（因为这样可以减少测试次数）。\n试了试发现好像只用 $2,3$​ 检测就能过这三个点，那就这样吧。\n后来我又试了试随机数的判定，不知道为什么，在 loj 跑 $10$ 个随机数仍然飞快（第 $10$ 个点 232ms），但在洛谷跑 $5$ 个随机数就很勉强（第 $10$ 个点 1.39s），所以还是建议大家去 loj 做，避免卡常（）\ninput11~13 关键信息是 $\\text{u}$，这是啥呢？\n看一看答案，发现只有三种：负号、正号、零。\n这。。再看看小数据联想一下，应该是莫比乌斯函数。\n和上一个功能一样，数非常大，区间不大。\n有一个比较经典的题是区间筛素数，使用的方法是先筛出平方根范围内的素数，然后再筛那个区间里的素数。\n我们可以尝试类似的思路。\n先筛出 $(10^{18})^{1/3}=10^6$ 范围内的素数以及莫比乌斯函数，用这些数去筛指定区间内的莫比乌斯函数，即让每个数都除掉他们在 $[1,10^6]$ 范围内的质因子，同时更新莫比乌斯函数。\n这样剩下的数有一些很好的性质：要么是素数，要么是两个大于 $10^6$ 素数的积。\n那么接下来的事情就比较明了了：\n用 Miller-Rabin 先判断剩下的数是不是素数，如果是，那么把答案取相反数； 如果不是素数，我们判断这个数是不是平方数，如果是，答案变为 $0$； 如果都不是，那么就是由两个不同素数乘起来得到的，这样答案不变。 写出来之后在我的机子上又跑不过去了，想办法剪剪枝卡常：\n多筛一些质数，能减少 Miller-Rabin 的执行次数； 很显然，如果答案已经是 $0$，不用管； 如果剩下的数是 $1$，不用管； 折腾完之后在我的机子上看起来速度还行，loj 上飞快。\n这三个点也就过了。\ninput14~16 关键信息是 $\\text{g}$，有了刚刚的经验，这个东西应该也是一个数学符号。\n想一想再看看数据能发现是判断一个数是否是指定数的原根。\n首先有原根判定定理：设 $m \\geqslant 3, \\gcd(a,m)=1$​，则 $a$​ 是模 $m$​ 的原根的充要条件是，对于 $\\varphi(m)$​ 的每个素因数 $p$​，都有 $a^{\\frac{\\varphi(m)}{p}}\\not\\equiv 1\\pmod m$​。\n对于 input14，模数全部是 $998244353$​，$\\varphi(998244353)=998244352$ 质因子只有 $2,7,17$，区间也不大，直接暴力判断即可。\n对于 input15，有一个模数是 $13123111$，$\\varphi(13123111)=13123110=2\\times3\\times5\\times7\\times11\\times13\\times19\\times23$，区间还贼大，暴力判断看上去不太行。\n得请出另一个结论了：若 $\\gcd\\big(k,\\varphi(m)\\big)=1$，则有：$\\delta_m(g^k)=\\varphi(m)$，即 $g^k$ 也是模 $m$ 的原根。\n用这个就可以筛原根了。\n接着是最后一个点 input16，这个点有一个 $10^9\\sim2\\times10^9$ 的质数作为模数需要我们确定，我们使用 input14 的思路暴力枚举这个质数，然后暴力分解质因数来判断原根情况和原来是否一致即可。我这里只检验了前 $49$ 位。\n看起来很暴力，但因为素数并不是特别多而且很容易检测出问题，实际代码跑起来是很快的。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using std::cerr; using std::cin; using std::cout; using std::endl; typedef long long ll; typedef __int128_t lll; typedef unsigned int ui; typedef unsigned long long ull; ll qpow(ll a, ll x, ll p) { ll res = 1; for (; x; x \u0026gt;\u0026gt;= 1, a = (lll)a * a % p) if (x \u0026amp; 1) res = (lll)res * a % p; return res; } bool MR(ll n) { if (n \u0026lt; 3 || n % 2 == 0) return n == 2; if (n == 3 || n == 5 || n == 7 || n == 11) return 1; if (n % 3 == 0) return n == 3; ll a = n - 1, b = 0; while (a % 2 == 0) a \u0026gt;\u0026gt;= 1, b++; for (int i = 0, j; i \u0026lt; 5; i++) { ll c = rand() % (n - 1) + 1; ll v = qpow(c, a, n); if (v == 1) continue; for (j = 0; j \u0026lt; b; j++) { if (v == n - 1) break; v = (lll)v * v % n; } if (j \u0026gt;= b) return false; } return true; } char s[100]; std::vector\u0026lt;int\u0026gt; a; int n, m; int check(int x) { a.clear(); int t = x - 1; for (int i = 2; i * i \u0026lt;= t; i++) { if (t % i == 0) { a.push_back(i); while (t % i == 0) t /= i; } } int q = x - 1; for (int i = 1; i \u0026lt;= 49; i++) { int now = i + n - 1; int ok = 1; for (int j : a) if (qpow(now, q / j, x) == 1) { ok = 0; break; } if (ok \u0026amp;\u0026amp; s[i] == \u0026#39;.\u0026#39;) return false; else if (!ok \u0026amp;\u0026amp; s[i] == \u0026#39;g\u0026#39;) return false; } return true; } int main() { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; freopen(\u0026#34;in.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cin \u0026gt;\u0026gt; (s + 1); for (int i = l; i \u0026lt;= r; i++) { if (!MR(i)) continue; int flag = check(i); if (flag == 1) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } } 我这里采用 $10$ 个程序并行的方式进行计算，效率很高，我刚开始第六个程序，第一个程序就跑完了。\n找出来合法的数只有一个：$1515343657$。质因数分解一下 $1515343656$，发现质因子是 $2,3,4003,15773$，区间不大，直接用 input14 的方法暴力判断即可。\n这样这道题就做完了。\nCode 完全没压行，所以很长。\n明明实际上挺码农的但写起来不感觉码农，也说明这道题挺有意思的。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using std::cerr; using std::cin; using std::cout; using std::endl; typedef long long ll; typedef __int128_t lll; typedef unsigned int ui; typedef unsigned long long ull; namespace IO { const int mxsiz = 1 \u0026lt;\u0026lt; 20; char inbuf[mxsiz], *p1, *p2; char outbuf[mxsiz], *op = outbuf; struct endio { endio(){}; ~endio() { fwrite(outbuf, 1, op - outbuf, stdout); } } useless_var; inline char gc() { return p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = inbuf) + fread(inbuf, 1, mxsiz, stdin), p1 == p2) ? EOF : *p1++; } #define isdigit(x) (x \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;9\u0026#39;) inline ll read() { ll x = 0, f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x * f; } int read_mod(int p) { int x = 0, f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = (lll)x * 10 % p + ch - \u0026#39;0\u0026#39;, x %= p; return x * f; } #undef isdigit inline void push(char ch) { if (op - outbuf == mxsiz) fwrite(outbuf, 1, mxsiz, stdout), op = outbuf; *op++ = ch; } template \u0026lt;typename T\u0026gt; inline void work_wt(T x) { if (x \u0026gt; 9) work_wt(x / 10); push(x % 10 + \u0026#39;0\u0026#39;); } template \u0026lt;typename T\u0026gt; inline void write(T x) { if (x \u0026lt; 0) x = -x, push(\u0026#39;-\u0026#39;); work_wt(x); } inline void endln() { push(\u0026#39;\\n\u0026#39;); } inline void space() { push(\u0026#39; \u0026#39;); } template \u0026lt;typename T\u0026gt; inline void writeln(T x) { write(x), endln(); } } using namespace IO; ll qpow(ll a, ll x, ll p) { ll res = 1; for (; x; x \u0026gt;\u0026gt;= 1, a = (lll)a * a % p) if (x \u0026amp; 1) res = (lll)res * a % p; return res; } namespace task1 { int n; void solve(const ll mod = 998244353) { n = read(); for (int i = 1; i \u0026lt;= n; i++) write(qpow(19, read_mod(mod - 1), mod)), endln(); } std::map\u0026lt;int, int\u0026gt; mp; inline int errmul(int a, int b) { return (int)((ui)a * (ui)b); } void solve2() { const int begin = 55245, round = 45699; const int mod = 998244353; mp[0] = 1; int now = 1; for (int i = 1; i \u0026lt;= begin + round; i++) { now = errmul(now, 19) % mod; mp[i] = now; } n = read(); for (int i = 1; i \u0026lt;= n; i++) { ll x = read(); write(x \u0026lt;= begin ? mp[x] : mp[(x - begin) % round + begin]); endln(); } } } bool MR(ll n) { if (n \u0026lt; 3 || n % 2 == 0) return n == 2; if (n == 3 || n == 5 || n == 7 || n == 11) return 1; ll a = n - 1, b = 0; while (a % 2 == 0) a \u0026gt;\u0026gt;= 1, b++; for (int i = 0, j; i \u0026lt; 2; i++) { ll c; if (i == 0) c = 2; else if (i == 1) c = 3; ll v = qpow(c, a, n); if (v == 1) continue; for (j = 0; j \u0026lt; b; j++) { if (v == n - 1) break; v = (lll)v * v % n; } if (j \u0026gt;= b) return false; } return true; } namespace task2 { void solve() { int n = read(); while (n--) { ll l = read(), r = read(); for (ll i = l; i \u0026lt;= r; i++) push(MR(i) ? \u0026#39;p\u0026#39; : \u0026#39;.\u0026#39;); endln(); } } } namespace task3 { const int maxn = 5e6 + 10; int mu[maxn], pri[maxn], vis[maxn], tot; void init(const int n = 5e6) { mu[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { if (!vis[i]) pri[++tot] = i, mu[i] = -1; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * pri[j] \u0026lt;= n; j++) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; break; } else mu[i * pri[j]] = -mu[i]; } } } int ans[maxn]; ll now[maxn]; inline bool check(ll x) { ll p = std::sqrt(x); return p * p == x; } void work(ll x, ll y) { if (y \u0026lt;= 5e6) { for (int i = x; i \u0026lt;= y; i++) if (mu[i] == 0) push(\u0026#39;0\u0026#39;); else if (mu[i] == 1) push(\u0026#39;+\u0026#39;); else if (mu[i] == -1) push(\u0026#39;-\u0026#39;); } else { for (int i = 0; i \u0026lt;= y - x; i++) now[i] = i + x; memset(ans, 1, sizeof(ans)); for (int i = 1; i \u0026lt;= tot; i++) { int p = pri[i]; ll j = 1ll * x / p; ll pos = 1ll * j * p; while (pos \u0026lt; x) pos += p; while (pos \u0026lt;= y) { int rp = pos - x; int cnt = 0; while (now[rp] % p == 0) now[rp] /= p, cnt++; if (cnt \u0026gt; 1) ans[rp] = 0; else if (ans[rp] \u0026gt; 1) ans[rp] = -1; else ans[rp] *= -1; pos += p; } } for (int i = 0; i \u0026lt;= y - x; i++) { if (ans[i] == 0 || now[i] == 1) continue; if (MR(now[i])) ans[i] = ans[i] \u0026gt; 2 ? -1 : ans[i] * -1; else if (now[i] != 1 \u0026amp;\u0026amp; check(now[i])) ans[i] = 0; else if (ans[i] \u0026gt; 2) ans[i] = 1; } for (int i = 0; i \u0026lt;= y - x; i++) if (ans[i] == 0) push(\u0026#39;0\u0026#39;); else if (ans[i] == 1) push(\u0026#39;+\u0026#39;); else if (ans[i] == -1) push(\u0026#39;-\u0026#39;); } } void solve() { init(); int n = read(); for (ll x, y, i = 1; i \u0026lt;= n; i++) x = read(), y = read(), work(x, y), endln(); } } std::string s; namespace task4 { int n; const int maxn = 1.4e7 + 10; bool ans[maxn]; void BF(int l, int r, int p) { int q = p - 1; for (int i = l; i \u0026lt;= r; i++) { if (qpow(i, q / 2, p) == 1 || qpow(i, q / 7, p) == 1 || qpow(i, q / 17, p) == 1) ans[i - l] = 0; else ans[i - l] = 1; } for (int i = 0; i \u0026lt;= r - l; i++) push(ans[i] ? \u0026#39;g\u0026#39; : \u0026#39;.\u0026#39;); endln(); } void BF2(int l, int r, int p) { int q = p - 1; for (int i = l; i \u0026lt;= r; i++) { if (qpow(i, q / 2, p) == 1 || qpow(i, q / 3, p) == 1 || qpow(i, q / 4003, p) == 1 || qpow(i, q / 15773, p) == 1) ans[i - l] = 0; else ans[i - l] = 1; } for (int i = 0; i \u0026lt;= r - l; i++) push(ans[i] ? \u0026#39;g\u0026#39; : \u0026#39;.\u0026#39;); endln(); } const int g = 6; inline int gcd(int x, int y) { return y == 0 ? x : gcd(y, x % y); } void qwq(int l, int r, int p) { const int q = p - 1; int now = g; for (int i = 1; i \u0026lt;= r; i++) { if (gcd(i, q) == 1) { ans[now] = 1; } now = now * g % p; } for (int i = l; i \u0026lt;= r; i++) push(ans[i] ? \u0026#39;g\u0026#39; : \u0026#39;.\u0026#39;); endln(); } void work(int l, int r, int p) { if (p == 998244353) BF(l, r, p); else if (p == 1515343657) BF2(l, r, 1515343657); else qwq(l, r, p); } void solve(int flag = 0) { n = read(); for (int i = 1; i \u0026lt;= n; i++) { int x = read(), y = read(); if (flag \u0026amp;\u0026amp; i == n) work(x, y, 1515343657); else work(x, y, read()); memset(ans, 0, sizeof(ans)); } } } int main() { cin \u0026gt;\u0026gt; s; if (s == \u0026#34;1_998244353\u0026#34;) task1::solve(); else if (s == \u0026#34;1?\u0026#34;) task1::solve(1145141); else if (s == \u0026#34;1?+\u0026#34;) task1::solve(5211600617818708273); else if (s == \u0026#34;1wa_998244353\u0026#34;) task1::solve2(); else if (s == \u0026#34;2p\u0026#34;) task2::solve(); else if (s == \u0026#34;2u\u0026#34;) task3::solve(); else if (s == \u0026#34;2g\u0026#34;) task4::solve(); else if (s == \u0026#34;2g?\u0026#34;) task4::solve(1); } ","permalink":"https://luoyisu.github.io/posts/loj3050/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e给出一些测试点的输入文件和输出文件以及每个测试点要实现的功能编号，你需要写一个程序通过这些给出的测试点。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://loj.ac/p/3050\"\u003e链接\u003c/a\u003e，这个题在 loj 上体验很好，洛谷上虽然也有这个题但容易被卡常。\u003c/p\u003e","title":"loj3050 「十二省联考 2019」 骗分过样例"},{"content":"Description 求 $$ \\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\operatorname{lcm}(i,j) $$ $n,m\\leq10^7$​。\nSolution 这道题算是一道比较有代表性的题目了，综合了各种 trick。\ntrick1：lcm 转化为 gcd： $$ \\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\operatorname{lcm}(i,j)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\frac{i\\times j}{\\gcd(i,j)} $$ trick2：枚举分母： $$ ans=\\sum\\limits_{d=1}^{\\min(n,m)}\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\frac{i\\times j}{d}[\\gcd(i,j)=d] $$ trick3：把 $[\\gcd(i,j)=d]$​​ 转化为 $[\\gcd(\\dfrac{i}{d},\\dfrac{j}{d})=1]$​​，同时改变枚举的 $i,j$​（$i$ 变为 $i/d$，$j$ 同理）。 $$ \\begin{aligned} ans\u0026amp;=\\sum\\limits_{d=1}^{\\min(n,m)}d\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\frac{i\\times j}{d\\times d}[\\gcd(\\frac{i}{d},\\frac{j}{d})=1]\\\\ \u0026amp;=\\sum\\limits_{d=1}^{\\min(n,m)}d\\sum\\limits_{i=1}^{\\lfloor \\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}i\\times j[\\gcd(i,j)=1] \\end{aligned} $$ trick4：$[n=1]$ 用一个结论转化为莫比乌斯函数的形式：$\\sum_{d\\mid n}\\mu(d)=[n=1]$​（证明不讲了）。 $$ ans=\\sum\\limits_{d=1}^{\\min(n,m)}d\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}i\\times j\\sum\\limits_{k\\mid\\gcd(i,j)}\\mu(k) $$ trick5：优先枚举因数，然后把枚举因数转化成枚举倍数放到后面的限制条件里。 $$ \\begin{aligned} ans\u0026amp;=\\sum\\limits_{d=1}^{\\min(n,m)}d\\sum\\limits_{k\\mid\\gcd(i,j)}\\mu(k)\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}i\\times j\\\\ \u0026amp;=\\sum\\limits_{d=1}^{\\min(n,m)}d\\sum\\limits_{k=1}^{\\lfloor\\min(n,m)/d\\rfloor}\\mu(k)\\sum\\limits_{i=1,k\\mid i}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1,k\\mid j}^{\\lfloor\\frac{m}{d}\\rfloor}i\\times j \\end{aligned} $$ trick6：$1\\sim n$​ 中 $x$​ 的倍数有 $\\lfloor\\dfrac{n}{x}\\rfloor$​ 个，那么有 $\\sum_{i=1,x\\mid i}^nt=\\sum_{i=1}^{\\lfloor n/x\\rfloor}tx$​​​（不一定完全一样，但可以用这个方法化简）。​ $$ \\begin{aligned} ans\u0026amp;=\\sum\\limits_{d=1}^{\\min(n,m)}d\\sum\\limits_{k=1}^{\\lfloor\\min(n,m)/d\\rfloor}\\mu(k)\\times k^2\\sum\\limits_{i=1,k\\mid i}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1,k\\mid j}^{\\lfloor\\frac{m}{d}\\rfloor}\\frac{i\\times j}{k\\times k}\\\\ \u0026amp;=\\sum\\limits_{d=1}^{\\min(n,m)}d\\sum\\limits_{k=1}^{\\lfloor\\min(n,m)/d\\rfloor}\\mu(k)\\times k^2\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{dk}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{dk}\\rfloor}j \\end{aligned} $$ 到这一步，$k^2$ 后面的两个东西是等差数列求和的形式，可以 $O(1)$ 得出，然后看到除法+下取整，而且 $\\mu(k)\\times k^2$ 的前缀和可以预处理得出，那么这玩意就是个数论分块：\n设 $$ sum(n)=\\sum\\limits_{i=1}^ni $$ $$ f(x,y)=\\sum\\limits_{k=1}^{\\lfloor\\min(n,m)\\rfloor}\\mu(k)\\times k^2\\times sum(\\lfloor\\frac{n}{k}\\rfloor)\\times sum(\\lfloor\\frac{m}{k}\\rfloor) $$ 那么 $$ ans=\\sum\\limits_{d=1}^{\\min(n,m)}d\\times f(\\lfloor\\frac{n}{d}\\rfloor,\\lfloor\\frac{m}{d}\\rfloor) $$ 诶，这又是个数论分块的形式？？？\n那这就做完了。\n时间复杂度似乎应该是 $O(n^{0.75}+n)$​​​​（后面是预处理的复杂度）。\n不过我们的式子是可以接着往下推的，还有 trick 可以讲。\n可以发现我们上面的式子中有 $k,d,dk$ 三个未知数，我们可以枚举其中一个来消去一个未知数。\ntrick7：枚举一个未知数来达到减小未知数的目的（这个好像比较灵活，我讲不太明白）。\n设 $s=dk$。 $$ ans=\\sum\\limits_{d=1}^{\\min(n,m)}d\\sum\\limits_{s=1,d\\mid s}^{\\min(n,m)}\\mu(\\frac{s}{d})\\times(\\frac{s}{d})^2\\times sum(\\frac{n}{s})\\times sum(\\frac{m}{s}) $$ trick8：这个算是很通用的 trick 了，换枚举顺序，同时换枚举的限制，让式子更舒服（？）。 $$ \\begin{aligned} ans\u0026amp;=\\sum\\limits_{s=1}^{\\min(n,m)}sum(\\frac{n}{s})\\times sum(\\frac{m}{s})\\sum\\limits_{d=1,d\\mid s}d\\times\\mu(\\frac{s}{d})\\times(\\frac{s}{d})^2\\\\ \u0026amp;=\\sum\\limits_{s=1}^{\\min(n,m)}s\\times sum(\\frac{n}{s})\\times sum(\\frac{m}{s})\\sum\\limits_{d=1,d\\mid s}\\mu(\\frac{s}{d})\\times\\frac{s}{d} \\end{aligned} $$ trick9：当枚举的是所有因数的时候，枚举 $\\dfrac{n}{d}$ 和 $d$ 是一样的。 $$ ans=\\sum\\limits_{s=1}^{\\min(n,m)}s\\times sum(\\frac{n}{s})\\times sum(\\frac{m}{s})\\sum\\limits_{d=1,d\\mid s}\\mu(d)\\times d $$ 后面的求和似乎是个积性函数，可以筛出来然后求前缀和。然后同样整除分块。\nCode 写的是两个整除分块的做法。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e7 + 10, mod = 20101009, inv_2 = 10050505; typedef long long ll; inline void upd(ll \u0026amp;x, ll y) { x += y, x %= mod; } int pri[maxn], mu[maxn], tot, vis[maxn]; ll f[maxn]; void init(const int n = 1e7) { mu[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { if (!vis[i]) pri[++tot] = i, mu[i] = -1; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; (ll)i * pri[j] \u0026lt;= n; j++) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; break; } mu[i * pri[j]] = -mu[i]; } } for (int i = 1; i \u0026lt;= n; i++) f[i] = f[i - 1], upd(f[i], 1ll * i * i % mod * (mu[i] + mod) % mod); } ll S(ll x) { return x * (x + 1) / 2 % mod; } ll solve(int n, int m) { ll res = 0; for (int i = 1, j; i \u0026lt;= std::min(n, m); i = j + 1) { j = std::min(n / (n / i), m / (m / i)); upd(res, (f[j] - f[i - 1] + mod) % mod * S(n / i) % mod * S(m / i) % mod); } return res; } int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; ll ans = 0; init(); for (int i = 1, j; i \u0026lt;= std::min(n, m); i = j + 1) { j = std::min(n / (n / i), m / (m / i)); upd(ans, solve(n / i, m / i) * (i + j) % mod * inv_2 % mod * (j - i + 1) % mod); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","permalink":"https://luoyisu.github.io/posts/luogu1829/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e求\n$$\n\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\operatorname{lcm}(i,j)\n$$\n$n,m\\leq10^7$​。\u003c/p\u003e","title":"luogu1829 Crash的数字表格 / JZPTAB"},{"content":"概述 不是特别难，F 倒不简单。\nA Description 给出一个 $n$ 项的数列，要求选出 $x$ 个数（不要求连续），使这 $x$ 个数的和为奇数。判断这是否可能。\nSolution 这显然是 奇数+奇数=偶数 和 奇数+偶数=奇数 这两个结论的简单运用\n首先先选一个奇数，如果还要选奇数个数那么必须选一个偶数。\n然后尽可能选看最后够不够即可。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1100; int cnt1, cnt2, n, x; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cnt1 = cnt2 = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; for (int i = 1, x; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; x, (x % 2 == 0 ? cnt1 : cnt2)++; if (cnt2 \u0026lt; 1) { puts(\u0026#34;No\u0026#34;); continue; } x--, cnt2--; if (cnt1 \u0026gt;= x) { puts(\u0026#34;Yes\u0026#34;); continue; } if (x % 2 == 1) { if (cnt1 \u0026lt; 1) { puts(\u0026#34;No\u0026#34;); continue; } cnt1--, x--; } x -= cnt2 / 2 * 2; x -= cnt1; puts(x \u0026gt; 0 ? \u0026#34;No\u0026#34; : \u0026#34;Yes\u0026#34;); } } B Description 对于一个 $01$ 字符串，如果这个字符串没有子序列（可以不连续）是 $101$ 或 $010$，那么它是好的。\n给定一个 $01$ 字符串 $s$。你可以选择一些位置，并翻转该位置的数 —— $0$ 变 $1$，$1$ 变 $0$。\n你需要求出，至少要选择多少个位置翻转，才能使这个字符串变成好的。\nSolution 看一下这个要求，显然符合条件的字符串只有 ：00000、11111，111000、000111 这四种形式。\n做个前缀和看看具体改成哪种即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1100; int sum0[maxn], sum1[maxn], n; char s[maxn]; int q(int l, int r) { return l \u0026gt; r ? 0 : std::min(sum0[r] - sum0[l - 1], sum1[r] - sum1[l - 1]); } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; (s + 1); n = strlen(s + 1); for (int i = 1; i \u0026lt;= n; i++) sum0[i] = sum0[i - 1], sum1[i] = sum1[i - 1], (s[i] - \u0026#39;0\u0026#39; ? sum1[i] : sum0[i])++; int ans = 1 \u0026lt;\u0026lt; 30; for (int i = 1; i \u0026lt;= n; i++) ans = std::min(ans, q(1, i) + q(i + 1, n)); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } C Description 给定 $n$ 个节点的无根树。\n两名选手轮流操作，每次可以选择一个叶节点并删除它以及所有和它相连的边。叶节点指度数不超过 $1$ 的节点。删除节点 $x$ 的选手胜利。\n你需要判断先手是否有必胜策略。具体来讲，如果先手有必胜策略，输出 Ayush，否则输出 Ashish。\nSolution 首先，当 $x$ 的度数小于等于 $1$ 时，先手必胜。\n而如果度数比 $1$ 大，比如是 $2$，那么先手一定会最后删掉与 $x$ 相邻的点，换成后手也同理。\n所以我们直接看 $n$ 的奇偶性就能知道轮流删之后谁能删掉 $x$。\n具体地：偶数先手赢，奇数后手赢。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1100; int deg[maxn], n, x; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { memset(deg, 0, sizeof(deg)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; for (int i = 1, x, y; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, deg[x]++, deg[y]++; if (deg[x] \u0026lt;= 1) { puts(\u0026#34;Ayush\u0026#34;); } else if (n % 2 == 1) { puts(\u0026#34;Ashish\u0026#34;); } else { puts(\u0026#34;Ayush\u0026#34;); } } } D Description 这是一道交互题。\n给定长为 $n$ 的数组 $a=[a_1,a_2,\u0026hellip;,a_n]$ 和 $k$ 个互不相交的子集 $S_1,S_2,\u0026hellip;,S_k$，这些子集中的元素都是 $[1,n]$ 之间的正整数。这些子集两两的交集为空。\n你可以进行最多 $12$ 次询问。每次询问你可以给出 $c$ 个互不相同且在 $[1,n]$ 之间的正整数 $v_1,v_2,\u0026hellip;,v_c$，然后你会得到 $\\max\\{v_i\\}$。\n对于每个子集 $S_i$，你需要求出 $P_i=\\max\\limits_{j \\notin S_i} a_j$。\n$2 \\leq n \\leq 1000,1 \\leq a_i,k \\leq n,1 \\leq c\u0026lt; n$。​​\nSolution 看到 $12$ 次询问，显然我们需要询问 $\\log n$ 次。可以向二分的思路上靠。\n注意到子集无交，那么有一个重要的结论：除了包含数组中最大数的集合，其他集合的答案一定是这个最大的数。\n我们可以通过 $1$ 次询问得到最大的数，再通过 $\\log_2n$ 次询问找到这个最大的数的位置。\n最后再通过一次询问得到这个包含最大数的答案即可，正好 $12$ 次。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1100; int n, k; std::vector\u0026lt;int\u0026gt; a[maxn]; int ans[maxn]; char s[maxn]; int ask(int l, int r) { cout \u0026lt;\u0026lt; \u0026#34;?\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r - l + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (int i = l; i \u0026lt;= r; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; int x; cin \u0026gt;\u0026gt; x; return x; } void clear() { for (int i = 1; i \u0026lt;= k; i++) a[i].clear(); memset(ans, 0, sizeof(ans)); } int main() { std::ios::sync_with_stdio(false); int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1, x; i \u0026lt;= k; i++) { int c; cin \u0026gt;\u0026gt; c; while (c--) cin \u0026gt;\u0026gt; x, a[i].push_back(x); std::sort(a[i].begin(), a[i].end()); } int mx = ask(1, n); int l = 1, r = n, pos = n; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (ask(1, mid) == mx) pos = mid, r = mid - 1; else l = mid + 1; } //cout \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= k; i++) { auto p = std::lower_bound(a[i].begin(), a[i].end(), pos); if (p == a[i].end() || *p != pos) ans[i] = mx; else { cout \u0026lt;\u0026lt; \u0026#34;?\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n - a[i].size() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (int j = 1; j \u0026lt;= n; j++) { auto p = std::lower_bound(a[i].begin(), a[i].end(), j); if (p == a[i].end() || *p != j) cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; ans[i]; } } cout \u0026lt;\u0026lt; \u0026#34;!\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (int i = 1; i \u0026lt;= k; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; s; clear(); } } E Description 给定 $n$​ 个节点标号为 $1$​ 到 $n$​ 的树，且 $1$​ 为树根，每个节点上有三个数字 $a_i,b_i,c_i$​。$a_i$​ 表示修改代价。$b_i,c_i$​ 的值为 $0$​ 或 $1$​ ， $b_i$​为初始值，$c_i$​为目标值。\n每次可以选择以节点 $u$​ 为根节点的子树，去把该子树的所有结点从初始值修改成目标值。修改方法为：可以选择该子树中任意 $k$​ 个节点进行交换初始值，使之与该节点的目标值相等，代价为 $k\\times a_u$​。\n判断能否把左右点从初始值变为目标值，并输出最小的代价。\nSolution 很水的一个题。\n对于一个点，在哪里交换是一样的，区别只有代价。\n那么我们显然应该用这个点到根路径上所有点代价的最小值去修改它。\n直接把代价下放然后取最小值即可，这样我们就可以非常贪心，如果能改直接在深度大的点改即可。\n具体到一个子树需要修改几次呢？\n随便写个 DP：$f(i,0/1)$ 表示以 $i$ 为根子树内还有多少个初始值为 $0/1$ 的点未被修改。\n然后对于一个子树我们能修改的就是 $\\min(f(i,0),f(i,1))$ 个点，算一下代价然后修改 $f$ 数组即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2e5 + 10; typedef long long ll; int a[maxn], b[maxn], c[maxn], n; ll ans; int f[maxn][2]; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } void dfs(int x, int fa) { a[x] = std::min(a[x], a[fa]); if (b[x] != c[x]) f[x][b[x] == 1]++; for (int v : e[x]) if (v != fa) dfs(v, x), f[x][0] += f[v][0], f[x][1] += f[v][1]; int need = std::min(f[x][0], f[x][1]); ans += 1ll * 2 * need * a[x]; f[x][0] -= need, f[x][1] -= need; } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; b[i] \u0026gt;\u0026gt; c[i]; for (int i = 1, x, y; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, add(x, y); a[0] = 1 \u0026lt;\u0026lt; 30; dfs(1, 0); if (f[1][0] != 0 || f[1][1] != 0) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } F Description 给定两个长度为 $n$ 的字符串 $s$，$t$。定义一次操作为选择 $s$ 的一个子串 $s_{l, l +1, \\dots, r}$，然后将之修改为 $s_{r, l, l + 1, l + 2, \\dots, r - 1 }$。请求助使 $s$ 与 $t$ 相等的最小操作次数。无解输出 $-1$。\n多组数据，$\\sum n \\leq 2000$，$s, t$ 中只有小写字母。\nSolution 这个操作的实质就是把一个字符提到前面去。\n首先如果有一种字符出现次数不同就一定无解，否则一定能构造出一组解。\n可以想到一个 DP：$f_{i,j}$​ 表示 $s$​ 匹配到第 $i$​ 位，$t$​ 匹配到第 $j$​ 位的最小操作次数，这里限制 $j\\geq i$​。\n为什么 $j$​ 可以比 $i$​ 大呢？意思就是在匹配时我们可以把 $s$ 串中后面的移到前面来。\n转移有三种情况：\n当 $s_i=t_j$，$f_{i,j}=f_{i-1,j-1}$，很显然；\n当出现次数允许（即 $i$ 后面有多的 $t_j$），我们可以从后面拿一个字符过来，即 $f_{i,j}=f_{i,j-1}$。这个东西看着很不对，但我们还有下面的转移：\n$f_{i,j}=f_{i-1,j}+1$。这个就是我们之前拿的字符，现在计算代价。\n好像很不对，但其实是对的：假如根本没拿过来，那就不会被转移到。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2010; char s[maxn], t[maxn]; int f[maxn][maxn]; int sum1[maxn][30], sum2[maxn][30]; int n; inline void updmi(int \u0026amp;x, int y) { x = std::min(x, y); } bool check() { for (int i = 0; i \u0026lt; 26; i++) { if (sum1[n][i] != sum2[n][i]) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } } return 1; } int main() { std::ios::sync_with_stdio(false); int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n; cin \u0026gt;\u0026gt; (s + 1) \u0026gt;\u0026gt; (t + 1); memset(sum1, 0, sizeof(sum1)), memset(sum2, 0, sizeof(sum2)); for (int i = 1; i \u0026lt;= n; i++) sum1[i][s[i] - \u0026#39;a\u0026#39;]++, sum2[i][t[i] - \u0026#39;a\u0026#39;]++; for (int i = 1; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt; 26; j++) sum1[i][j] += sum1[i - 1][j], sum2[i][j] += sum2[i - 1][j]; if (check() == 0) continue; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) f[i][j] = 1 \u0026lt;\u0026lt; 25; for (int i = 1; i \u0026lt;= n; i++) f[0][i] = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = i; j \u0026lt;= n; j++) { f[i][j] = f[i - 1][j] + 1; if (s[i] == t[j]) updmi(f[i][j], f[i - 1][j - 1]); if (sum1[i][t[j] - \u0026#39;a\u0026#39;] \u0026lt; sum2[j][t[j] - \u0026#39;a\u0026#39;]) updmi(f[i][j], f[i][j - 1]); } cout \u0026lt;\u0026lt; f[n][n] \u0026lt;\u0026lt; endl; } } ","permalink":"https://luoyisu.github.io/posts/cf-contest1363/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e不是特别难，F 倒不简单。\u003c/p\u003e","title":"Codeforces Round 646 (Div. 2)"},{"content":"概述 虽说是 Div2，但也不是特别简单，E 还是不太裸的。。\nA Description Pasha 有一个正整数长度的木棍 $n$​。他想要完成三次切割以获得四个部分。每个部分必须有一些正整数长度，这些长度的总和显然是 $n$。\nPasha 喜欢长方形但讨厌正方形，所以他想知道，有多少种方法可以将棍子分成四个部分，这样就可以用这些部分形成一个矩形，但不可能形成正方形。\n你的任务是帮助 Pasha 并计算这些方式的数量。\nSolution 看代码。\nCode #include \u0026lt;iostream\u0026gt; using std::cin; using std::cout; using std::endl; int n; int main() { cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; (n % 2 ? 0 : (n / 2 - 1) / 2) \u0026lt;\u0026lt; endl; } B Description Vika 有 $n$ 桶油漆，第 $i$ 桶有 $a_i$ 升油漆。\nVika 有一张无限长的长方形纸条，她将长方形纸条分成了无限个正方形，她将按照以下规则对正方形涂色。\n涂一个正方形需要 $1$ 升油漆。 第一个正方形可以用第任意第 $i$ 桶油漆。 若第 $k$ 个正方形用了第 $x$ 桶油漆，则第 $k+1$ 个正方形将用第 $x+1$ 桶油漆，若 $x=n$，则第 $k+1$ 个正方形将用第 $1$ 桶油漆。若 $a_x = 0$ 则停止涂色。 求 Vika 最多可以涂多少个正方形。\nSolution 设最小的元素是 $x$，很显然答案的下界是 $nx$。\n把所有元素都减去 $x$ 之后，我们需要找到一段所有元素都大于零的最长连续段，把这部分也加进答案里即可。\n这个最长连续段要么就是连续的一段，要么是头尾相接的一段，都模拟一下就好了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2e5 + 10; int a[maxn], n; long long ans = 0; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; int pos = 0; a[0] = 2e9; for (int i = 1; i \u0026lt;= n; i++) if (a[i] \u0026lt;= a[pos]) pos = i; int lpos = 1; for (int i = 1; i \u0026lt;= n; i++) if (a[i] == a[pos]) { lpos = i; break; } int lst = lpos; int sum = lpos + n - pos - 1; for (int i = lpos + 1; i \u0026lt;= n; i++) { if (a[i] != a[pos]) continue; sum = std::max(sum, i - lst - 1); lst = i; } cout \u0026lt;\u0026lt; (long long)a[pos] * n + sum \u0026lt;\u0026lt; endl; } C Description 给定 $k$，求 $2^k$ 个 $2^k$ 维向量满足每个向量的坐标表示中任意一维都为 $1$ 或 $-1$，且这些向量两两点积为 $0$。\n$0\\leq k\\leq 9$。\nSolution 这个题一看就比较找规律，再联想分治\u0026hellip;\n先构造一个如下的矩阵（$1$ 表示 $1$，$0$ 表示 $-1$）。\n11\r10 这是 $k=1$ 的情况，很显然满足要求。\n怎么从它扩展到 $k=2$ 呢？可以构造一个如下的矩阵：\n1111\r1010\r1100\r1001 就是把 $k=1$​ 的矩阵在四个地方复制一份，再把右下角的矩阵取反就行。\n然后重复以上操作就构造完了。\n证明一下：首先左半部分在原来两个矩阵内部内积是 $0$，取反之后仍然在内部内积是 $0$，而两个矩阵相同的行内积在右面正好会抵消，于是这么构造就是对的。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1 \u0026lt;\u0026lt; 10; int a[maxn][maxn]; void solve(int x, int y, int len, int opt) { if (len == 1) { a[x][y] = opt; return; } int p = len / 2; solve(x, y, p, opt), solve(x, y + p, p, opt), solve(x + p, y, p, opt), solve(x + p, y + p, p, opt ^ 1); } int k; int main() { cin \u0026gt;\u0026gt; k; solve(1, 1, 1 \u0026lt;\u0026lt; k, 1); for (int i = 1; i \u0026lt;= (1 \u0026lt;\u0026lt; k); i++, cout \u0026lt;\u0026lt; endl) for (int j = 1; j \u0026lt;= (1 \u0026lt;\u0026lt; k); j++) cout \u0026lt;\u0026lt; (a[i][j] ? \u0026#39;+\u0026#39; : \u0026#39;*\u0026#39;); } D Description 有一个网格，给出 $n$ 条线段，每条线段覆盖一些网格，问被覆盖的网格的面积并是多少。\n$n\\leq10000$。\nSolution 太扫描线了！！！\n把题目的网格图转成平面直角坐标系，线段转成点，然后扫描线即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;utility\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2e5 + 10; typedef long long ll; struct node { int x1, x2, y, opt; bool operator\u0026lt;(const node \u0026amp;b) const { return y \u0026lt; b.y; } } a[maxn]; int p[maxn], tot, n, cnt; struct Tree { struct Node { int l, r; ll sum, lzy; } t[maxn \u0026lt;\u0026lt; 3]; inline int ls(int x) { return x * 2; } inline int rs(int x) { return x * 2 + 1; } inline void push_up(int k) { t[k].sum = t[k].lzy \u0026gt; 0 ? p[t[k].r + 1] - p[t[k].l] : t[ls(k)].sum + t[rs(k)].sum; } void build(int l, int r, int k) { t[k].l = l, t[k].r = r; if (l == r) { t[k].sum = 0; return; } int mid = (l + r) / 2; build(l, mid, ls(k)), build(mid + 1, r, rs(k)); push_up(k); } void modify(int x, int y, int v, int k) { if (p[t[k].r + 1] \u0026lt;= x || p[t[k].l] \u0026gt;= y) return; if (p[t[k].r + 1] \u0026lt;= y \u0026amp;\u0026amp; p[t[k].l] \u0026gt;= x) { t[k].lzy += v, push_up(k); return; } int mid = floor((x + y) / 2.0); // 注意，坐标有负数，需要向下取整而不是向零取整 if (x \u0026lt;= mid) modify(x, y, v, ls(k)); if (y \u0026gt; mid) modify(x, y, v, rs(k)); push_up(k); } } t; signed main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int x1, x2, y1, y2; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; if (y1 == y2) { if (x1 \u0026gt; x2) std::swap(x1, x2); x2++, y2++; a[++tot] = {x1, x2, y1, 1}, a[++tot] = {x1, x2, y2, -1}; p[++cnt] = x1, p[++cnt] = x2; } else { if (y1 \u0026gt; y2) std::swap(y1, y2); x2++, y2++; a[++tot] = {x1, x2, y1, 1}, a[++tot] = {x1, x2, y2, -1}; p[++cnt] = x1, p[++cnt] = x2; } } std::sort(p + 1, p + 1 + cnt), std::sort(a + 1, a + tot + 1); cnt = std::unique(p + 1, p + 1 + cnt) - p - 1; t.build(1, cnt - 1, 1); ll ans = 0, lst = a[1].y; for (int i = 1; i \u0026lt;= tot; i++) { ans += (a[i].y - lst) * t.t[1].sum; t.modify(a[i].x1, a[i].x2, a[i].opt, 1); lst = a[i].y; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } E Description 给定一个长度为 $n$​​（$n\u0026lt;200000$​）的字符串 $s$，有两种指令：\n将区间 $[L,R]$​ 内的字符变为 $ch$；\n给定长度为 $k$​​​​​（$1\\leq k\\leq10$​​​​）的字符串排列 $t$​​​，向 $s$​​ 串中添加字符，使得 $s$​ 以 $t$ 为模式循环，求最少的循环次数。\n最多 $20000$ 条指令。\n字符集大小为 $k$。\nSolution 首先有一个结论：当两个相邻字符在字符串排列中前后顺序相同，这两个一定在同一个循环节内（因为不在的话会导致循环节增加一个）。\n这样对于一次询问，一个很暴力的想法是：把字符串遍历一遍，看相邻字符在排列中的顺序。\n注意到 $k$ 很小，我们尝试把询问的复杂度降到和 $k$ 有关。\n发现我们只需要相邻字符的信息，而且这个信息是个数，那我们可以直接把每两种字符的相邻次数存下来询问时 $O(k^2)$ 枚举一遍字符集，把顺序不同的加进答案即可。\n询问解决了，下一步是修改。\n我们需要区间赋值，整体查询，且维护信息可以合并，那直接选择线段树，每个结点维护这段区间中上文的数组，以及最左元素、最右元素方便合并。\n时间复杂度 $O(nk^2+mk^2\\log n)$。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;utility\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2e5 + 10, maxk = 11; char s[maxn]; int n, m, k; struct Tree { static const int maxn = ::maxn * 4; int cnt[maxn][maxk][maxk], lch[maxn], rch[maxn], lzy[maxn]; inline int ls(int x) { return x * 2; } inline int rs(int x) { return x * 2 + 1; } void push_up(int x) { for (int i = 0; i \u0026lt; k; i++) for (int j = 0; j \u0026lt; k; j++) cnt[x][i][j] = cnt[ls(x)][i][j] + cnt[rs(x)][i][j]; cnt[x][rch[ls(x)]][lch[rs(x)]]++, lch[x] = lch[ls(x)], rch[x] = rch[rs(x)]; } void access(int x, int ch, int len) { memset(cnt[x], 0, sizeof(cnt[x])), cnt[x][ch][ch] = len - 1, lch[x] = rch[x] = lzy[x] = ch; } void push_down(int x, int l, int r) { if (lzy[x] == -1) return; int mid = (l + r) / 2; access(ls(x), lzy[x], mid - l + 1), access(rs(x), lzy[x], r - mid); lzy[x] = -1; } void build(int l, int r, int k) { if (l == r) { lch[k] = rch[k] = s[l] - \u0026#39;a\u0026#39;; return; } int mid = (l + r) / 2; build(l, mid, ls(k)), build(mid + 1, r, rs(k)); push_up(k); } void modify(int l, int r, int x, int y, int v, int k) { if (l \u0026gt;= x \u0026amp;\u0026amp; r \u0026lt;= y) { access(k, v, r - l + 1); return; } int mid = (l + r) / 2; push_down(k, l, r); if (x \u0026lt;= mid) modify(l, mid, x, y, v, ls(k)); if (y \u0026gt; mid) modify(mid + 1, r, x, y, v, rs(k)); push_up(k); } Tree() { memset(lzy, -1, sizeof(lzy)); } } t; int pos[maxk]; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k \u0026gt;\u0026gt; (s + 1); t.build(1, n, 1); int opt, x, y; char ch; while (m--) { cin \u0026gt;\u0026gt; opt; if (opt == 1) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; ch, t.modify(1, n, x, y, ch - \u0026#39;a\u0026#39;, 1); else { long long ans = 0; cin \u0026gt;\u0026gt; (s + 1); for (int i = 1; i \u0026lt;= k; i++) pos[s[i] - \u0026#39;a\u0026#39;] = i; for (int i = 0; i \u0026lt; k; i++) for (int j = 0; j \u0026lt; k; j++) if (pos[i] \u0026gt;= pos[j]) ans += t.cnt[1][i][j]; cout \u0026lt;\u0026lt; ans + 1 \u0026lt;\u0026lt; endl; } } } ","permalink":"https://luoyisu.github.io/posts/cf-contest610/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e虽说是 Div2，但也不是特别简单，E 还是不太裸的。。\u003c/p\u003e","title":"Codeforces Round 337 (Div. 2)"},{"content":"概述 很水的一场比赛，快来做前几场比赛的小清新题！！\nA Description 给出两个时间，求它们中点时间。\nSolution 把小时和分钟转化成分钟再取中点，再转化回去即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 10; char a[maxn], b[maxn]; int change(char *a) { int h = (a[0] - \u0026#39;0\u0026#39;) * 10 + a[1] - \u0026#39;0\u0026#39;, m = (a[3] - \u0026#39;0\u0026#39;) * 10 + a[4] - \u0026#39;0\u0026#39;; return h * 60 + m; } std::string enchange(int mid) { std::string s = \u0026#34; \u0026#34;; int h = mid / 60, m = mid % 60; s[0] = h / 10 + \u0026#39;0\u0026#39;, s[1] = h % 10 + \u0026#39;0\u0026#39;, s[2] = \u0026#39;:\u0026#39;, s[3] = m / 10 + \u0026#39;0\u0026#39;, s[4] = m % 10 + \u0026#39;0\u0026#39;; return s; } int main() { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int p = change(a), q = change(b); int mid = (p + q) / 2; cout \u0026lt;\u0026lt; enchange(mid) \u0026lt;\u0026lt; endl; } B Description 从 $n$​ 个数中每次选两个数，这两个数的和必须为 $k$ 的倍数。问最多能选出多少个数满足条件。\nSolution 显然加入一个数模 $k$ 是 $x$，那么他只能和模 $k$ 是 $k-x$​ 的数配对。\n开一个桶记录一下每种余数的个数然后统计答案即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 2e5 + 10; int a[maxn], b[maxn], k, n; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1, x; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; x, b[x % k]++; int ans = b[0] / 2 * 2; for (int i = 1; i \u0026lt; k / 2; i++) ans += std::min(b[i], b[k - i]) * 2; if (k % 2 == 0) ans += b[k / 2] / 2 * 2; else ans += std::min(b[k / 2], b[k / 2 + 1]) * 2; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } C Description 给 $n$​​​​ 个数，让你找出 $m$​​​ 个数，使得这 $m$​​ 个数中的最大值减去最小值不大于 $5$​，求最大的 $m$。\nSolution 排序 + 双指针，太水了我都不知道该说什么。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 2e5 + 10; int a[maxn], n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; std::sort(a + 1, a + 1 + n); int l = 1, r = 1, ans = 1; while (l \u0026lt;= n) { while (r \u0026lt;= n \u0026amp;\u0026amp; a[r] - a[l] \u0026lt;= 5) r++; ans = std::max(ans, r - l); l++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } D Description 给出两个长度为 $n$ 的数组 $a,b$。\n你想要创建一个长度为 $n$​​ 的数组 $c$​​，且 $c_i=d\\times a_i+b_i,i\\in[1, n]$​​，要求你给 $d$​ 赋值，使得数组 $c$​​ 中的 $0$​​ 的个数最多并输出最多的 $0$​​ 的个数。\nSolution $$ c_i=d\\times a_i+b_i\\Rightarrow d=\\frac{-b_i}{a_i} $$\n可以算出来让每个数变成 $0$​ 的 $d$​ 是多少，然后看看出现次数最多是多少。\n为了避免浮点误差，我们把分子分母约分一下然后放进 map 里。\n特判一下本来就是 $0$ 的情况。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;utility\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; int gcd(int x, int y) { return y == 0 ? x : gcd(y, x % y); } typedef std::pair\u0026lt;int, int\u0026gt; pii; const int maxn = 1e6 + 10; std::map\u0026lt;pii, int\u0026gt; mp; int a[maxn], b[maxn], n; int ans; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; b[i]; for (int i = 1; i \u0026lt;= n; i++) if (a[i] \u0026lt; 0) a[i] *= -1, b[i] *= -1; else if (a[i] == 0) ans += b[i] == 0; for (int i = 1; i \u0026lt;= n; i++) { if (a[i] == 0) continue; int d = gcd(a[i], b[i] \u0026lt; 0 ? -b[i] : b[i]); a[i] /= d, b[i] /= d; mp[pii(a[i], b[i])]++; } int cnt = 0; for (auto k : mp) { cnt = std::max(cnt, k.second); } cout \u0026lt;\u0026lt; ans + cnt \u0026lt;\u0026lt; endl; } E Description 您是本地大学的教练，有 $n$ ​位选手在你这里学习，并且已知第 $i$ ​位的能力值为 $a_i$​。\n现在您需要挑选出若干位选手组成至多 $k$ ​支队伍。众所周知，参赛的人数越多，你的大学获胜的概率越大。所以，你需要使得你选出的至多$k$​支（至少$1$​支）非空队伍的总人数最多。但是，你知道每支队伍中队员们的实力应当差不多，这意味着对于任意一支队伍，不应当存在两名实力值相差超过 $5$ ​​的选手。所有的队伍都是相互独立的（这意味着我们不考虑来自两只不同队伍的选手的实力值差距）。\n可能有的选手不属于任何一支队伍。\n您的任务是求出满足以上要求的至多 $k$​（至少 $1$​​）支非空队伍的总人数。\n$n,k\\leq5000$。\nSolution 数据范围告诉我们要 DP。\n我们把实力值排个序，显然如果选了一个人，把和他实力值相差小于 $5$ 的人全选上是最优的。\n预处理一个 $lst_i$ 表示第 $i$ 个人，上一个实力值比他小超过 $5$ 的人的位置。\n设 $f(i,j)$ 表示前 $i$ 个人，已经组了 $j$​​ 个队伍的参赛总人数。\n然后考虑这个人选不选，有： $$ f(i,j)=\\max(f(i-1,j),f(lst_i,j-1)+i-lst_i) $$ 前面是不选，后面是选。\n直接转移即可，时间复杂度 $O(nk)$。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 5010; int lst[maxn], f[maxn][maxn], a[maxn], n, k; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; std::sort(a + 1, a + 1 + n); for (int i = 1; i \u0026lt;= n; i++) { int pos = i; while (pos \u0026gt;= 1 \u0026amp;\u0026amp; a[i] - a[pos] \u0026lt;= 5) pos--; lst[i] = pos; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= k; j++) { f[i][j] = f[i - 1][j]; f[i][j] = std::max(f[i][j], f[lst[i]][j - 1] + i - lst[i]); } } cout \u0026lt;\u0026lt; f[n][k] \u0026lt;\u0026lt; endl; } F1 Description 给出了一个由 $n$​ 个顶点和 $m$ 条边组成的无向无权连通图。它保证在给定的图中没有自环或重边。\n你的任务是找到这个图的一棵生成树，使得树上点的最大度数尽可能地大。\nSolution 很显然我们可以构造出一棵以原图中度数最大的点为根，包括其在原图上所有相邻结点的树。\nBFS 构造一下就行。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 2e5 + 10; int n, m, d; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } int cnt, vis[maxn], vis2[maxn], used[maxn]; void bfs(int s) { std::queue\u0026lt;int\u0026gt; q; vis2[s] = 1; q.push(s); while (!q.empty()) { int x = q.front(); q.pop(); for (int v : e[x]) { if (!vis2[v]) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl, q.push(v), vis2[v] = 1; } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0, x, y; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, add(x, y); int s = 1; for (int i = 2; i \u0026lt;= n; i++) if (e[i].size() \u0026gt; e[s].size()) s = i; bfs(s); } F2 Description 给你一个图，让你构造出一个编号为 $1$ 的点的度数为 $D$​ ​的树\n（保证没有自环和重边）\nSolution 我们设这棵树以 $1$ 为根。\n一开始想的是假如 $1$ 的一个子树内有一条边连向另一个子树，那么这条边就可以删掉。\n感觉很点双啊。。。。。。\n后来转念一想，都点双了，我们直接把 $1$ 号点删掉然后看有几个联通块不就能得到能删掉几条边了吗？。。。\n这样就能判断出来有解的条件：\n点 $1$ 的度数不小于 $D$； 删掉 $1$ 之后连通块个数不大于 $D$​。 可以 DFS 找连通块，用和 F1 类似的 BFS 做法输出答案。\nCode 很丑。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 2e5 + 10; int n, m, d; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } int cnt, vis[maxn], vis2[maxn], used[maxn]; void dfs(int x, int p) { vis[x] = p; for (int v : e[x]) if (v != 1 \u0026amp;\u0026amp; !vis[v]) dfs(v, p); } void bfs() { std::queue\u0026lt;int\u0026gt; q; vis2[1] = 1; int tot = 0; for (int i = 0; i \u0026lt; (int)e[1].size(); i++) if (!used[vis[e[1][i]]]) q.push(e[1][i]), cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e[1][i] \u0026lt;\u0026lt; endl, vis2[e[1][i]] = 1, used[vis[e[1][i]]] = 1, tot++; for (int v : e[1]) { if (!vis2[v]) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl, vis2[v] = 1, tot++, q.push(v); if (tot == d) break; } while (!q.empty()) { int x = q.front(); q.pop(); for (int v : e[x]) { if (!vis2[v]) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl, q.push(v), vis2[v] = 1; } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; d; for (int i = 0, x, y; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, add(x, y); for (int i = 2; i \u0026lt;= n; i++) if (!vis[i]) dfs(i, ++cnt); if ((int)e[1].size() \u0026lt; d || cnt \u0026gt; d) { puts(\u0026#34;NO\u0026#34;); return 0; } //for (int i = 1; i \u0026lt;= n; i++) // cout \u0026lt;\u0026lt; vis[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //cout \u0026lt;\u0026lt; endl; puts(\u0026#34;YES\u0026#34;); bfs(); } ","permalink":"https://luoyisu.github.io/posts/cf-contest1133/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e很水的一场比赛，快来做前几场比赛的小清新题！！\u003c/p\u003e","title":"Codeforces Round 544 (Div. 3)"},{"content":"概述 C 可以一做。\n别问为什么就三道题。\nA Description 给定两个数，每次用大数减去小数的差代替这个数，并称为一次操作。问有一个数为 $0$ 的时候一共有多少次操作。\n输入：第一行是一个正整数 $n$，表示数据的组数。接下来 $n$ 行，每行两个正整数 $a_i$ 和 $b_i$ 表示给定的两数。\n$a_i,b_i\\leq10^9$。\nSolution 发现这就是一个辗转相减求最大公约数的流程，显然暴力不行。\n但我们在普通辗转相除求最大公约数的时候统计一下答案就行。\n属实是考验了对基础算法的理解。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::cin; using std::cout; int ans = 0; int gcd(int x, int y) { if (y == 0) return x; ans += x / y; return gcd(y, x % y); } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if (a \u0026lt; b) std::swap(a, b); ans = 0; gcd(a, b); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; } } B Description 给定 $n$ 和 $n$ 个二元组 $(a_i,b_i)$ 。\n你可以任意排列这几个二元组，也可以任意更换一个二元组之间的两个元素的顺序。\n是否存在一种解，使得任意相邻的两个二元组中，相邻的两个元素相等。\n输出其排列顺序，并输出其是否需要改变两个元素的顺序。\nSolution 这个东西一看就非常欧拉路，我们把二元组的两个数之间连一个双向边，然后找欧拉路即可。\n最后输出边的方案。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 110; struct edge { int y, i, pos; }; std::vector\u0026lt;edge\u0026gt; e[maxn]; inline void add(int x, int y, int i) { e[x].push_back({y, i, 1}), e[y].push_back({x, i, 0}); } std::stack\u0026lt;edge\u0026gt; ans; int vis[maxn]; void dfs(int x) { edge i; while (e[x].size()) { int y = e[x].back().y; i = e[x].back(); e[x].pop_back(); if (vis[i.i]) continue; vis[i.i] = 1; dfs(y); ans.push(i); } } int deg[maxn], n; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; int mx = 0; int s = 0; for (int i = 1, x, y; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, add(x, y, i), deg[x]++, deg[y]++, s = y, mx = std::max(mx, std::max(x, y)); int flag = 0; for (int i = 0; i \u0026lt;= mx; i++) { if (deg[i] \u0026amp; 1) s = i, flag++; } if (flag != 0 \u0026amp;\u0026amp; flag != 2) { puts(\u0026#34;No solution\u0026#34;); return 0; } dfs(s); if ((int)ans.size() != n) { puts(\u0026#34;No solution\u0026#34;); return 0; } while (!ans.empty()) { auto p = ans.top(); ans.pop(); cout \u0026lt;\u0026lt; p.i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (p.pos ? \u0026#39;+\u0026#39; : \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; endl; } } C Description 给定一张 $n$ 点 $m$ 边的无向的网络流，源点为 $1$，汇点为 $n$。\n第 $i$ 条边用有序数对 $(a_i,b_i) (a_i\\not= b_i)$ 和容量值 $c_i$ 描述，表示连接 $a_i$ 与 $b_i$，容量为 $c_i$。\n你应当给这条边赋一个实数流量 $x_i$，满足 $|x_i|\\le c_i$，如果是正的表示从 $a_i$ 流向 $b_i$ 大小为 $x_i$，否则表示从 $b_i$ 流向 $a_i$ 大小为 $-x_i$。\n你构造的流需要满足：\n流守恒。即对所有不为 $1$ 或 $n$ 的点 $u$，进入 $u$ 的流等于从 $u$ 出去的流。\n对任意两个连通的节点 $x,y$，从 $x$ 到 $y$ 的所有路径 $x_i$（流量）的和都是相等的。\n现在请输出最大流（可以理解为 $\\sum_v x_{1,v}$），并构造一个方案。\n$1\\leq n\\leq100,1\\leq m\\leq5000$。\nSolution 这个题看上去挺莫名其妙的。把样例二画出来：\n看看这个图，和红的数字，似乎能发现什么东西\u0026hellip;\n我们给每个点一个高度（即图中红色的数字）。\n根据第二个要求，任意两点之间，不管怎么走，高度的差值是一定的，而相邻两点高度差值就是这条边的流量。\n再仔细想一想，在这道题中，图的形态固定，每条边的流量应该是有一个固定的比例的。\n根据第一个要求：每个点出的流量和入的流量相等。\n设 $out(i)$ 表示 $i$ 连向的点，$in(i)$ 表示连向 $i$ 的点，可以列出来一个方程：$\\sum (h_i-h_{in(i)})=\\sum(h_{out(i)}-h_i)$。\n那么总共有 $n-2$ 个方程。\n因为我们实际上是想要求流量，那么源点和汇点高度具体的值是无所谓的，减一下都会按照比例消掉。\n我们自己设一下源点和汇点高度。\n这样总共就有 $n$ 个方程，我们就可以解出来所有点的高度。（高斯消元）\n很显然，如果我们把所有点高度都按照一定比例缩放，这两个限制仍然是成立的。\n我们找到能缩放的最大比例，然后进行缩放，就得到了最大流（即和汇点相连的边的流量之和）和每条边的流量。\n重边是不用特殊处理的。\n复杂度是高斯消元的 $O(n^3)$。\nCode 注意除以 $0$。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 110; const double eps = 1e-8; int e[maxn][maxn], n, m; inline double change(double x) { return x \u0026lt; eps ? eps : x; } double a[maxn][maxn]; double root[maxn]; void guass() { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (i == j) continue; if (fabs(a[i][i]) \u0026lt; eps) continue; double d = a[j][i] / a[i][i]; for (int k = i; k \u0026lt;= n + 1; k++) a[j][k] -= a[i][k] * d; } } for (int i = 1; i \u0026lt;= n; i++) if (fabs(a[i][i]) \u0026gt; eps) root[i] = a[i][n + 1] / a[i][i]; } struct edge { int x, y; double cap; }; std::vector\u0026lt;edge\u0026gt; edges; inline void add(int x, int y, double cap) { edges.push_back({x, y, cap}); if (x != 1 \u0026amp;\u0026amp; x \u0026lt; n) a[x][x]--, a[x][y]++; if (y != 1 \u0026amp;\u0026amp; y \u0026lt; n) a[y][y]--, a[y][x]++; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; double c; for (int i = 1, x, y; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; c, add(x, y, c); a[1][n + 1] = 1, a[n][n + 1] = n + 1, a[1][1] = 1, a[n][n] = 1; guass(); double mul = 1e18; int flag = 0; for (auto k : edges) { if (fabs(root[k.y] - root[k.x]) \u0026lt; eps) continue; mul = std::min(mul, 1.0 * k.cap / fabs(root[k.y] - root[k.x])), flag = 1; } if (!flag) mul = 0; for (int i = 1; i \u0026lt;= n; i++) root[i] *= mul; double sum = 0; for (auto k : edges) if (k.x == n || k.y == n) sum += fabs(root[k.y] - root[k.x]); printf(\u0026#34;%lf\\n\u0026#34;, sum); for (auto k : edges) printf(\u0026#34;%lf\\n\u0026#34;, root[k.y] - root[k.x]); } ","permalink":"https://luoyisu.github.io/posts/cf-contest267/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003eC 可以一做。\u003c/p\u003e\n\u003cp\u003e别问为什么就三道题。\u003c/p\u003e","title":"Codeforces Testing Round 5"},{"content":"概述 没啥难题，也没有什么特别推荐的题。（快来做前几天的题！！）\nA Description 有四个房间，每个房间有两个守卫，每个守卫可以用不小于一给定价钱的巧克力或果汁贿赂。\n现在你有 $n$ 元要恰好花完，要贿赂一个房间里的两个守卫，问怎么分配钱。\nSolution 关键在于读懂英文题面，转化成上面的意思，然后就做完了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int x = std::min(a, b), y = std::min(c, d); if (x + y \u0026lt;= n) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n - x \u0026lt;\u0026lt; endl; return 0; } } cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } B Description 有 $n$ 个任务，你每次可以做连续的 $k$ 个，做完这 $k$ 个之后会接着做连续的 $k$ 个任务。一直做到不能做结束。你每次开始做任务时会得到一个对应的怒气值，而连续做的任务不会得到怒气值。\n问从哪个任务开始做得到怒气值最小。（建议看英文题面）\nSolution 发现从第 $i$ 个任务开始做，就会得到任务 $i,i+k,i+2k\u0026hellip;$ 的怒气值。也就是说任务被分成了 $k$ 组。\n没啥可说的，直接预处理每组任务怒气值然后输出最小值就可以了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 1e5 + 10; int a[maxn], n, k; int sum[maxn]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= k; i++) { for (int j = i; j \u0026lt;= n; j += k) sum[i] += a[j]; } int ans = 0; sum[0] = 1 \u0026lt;\u0026lt; 30; for (int i = 1; i \u0026lt;= k; i++) if (sum[i] \u0026lt; sum[ans]) ans = i; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } C Description 有 $n$ 个水果，每个水果有两个属性：美味值 $a$ 和卡路里值 $b$ 。现在选用若干个（至少 $1$ 个）水果制作一份特殊的沙拉，沙拉的美味值为所选的水果的美味值的和，沙拉的卡路里值为所选水果的卡路里值的和。沙拉的美味值恰好是卡路里值的 $k$ 倍。请计算该沙拉美味值最大为多少。\n$n,a_i,b_i\\leq100,k\\leq10$\nSolution 把卡路里值乘一下 $k$，问题转化为美味值和卡路里相等。\n这个东西就非常背包。\n随便乱写一个 DP：$f(i,j,k)$ 表示前 $i$ 个水果，美味值和为 $j$，卡路里和为 $k$ 的最大美味值。然后 $f(i,j,k)=\\max(f(i-1,j,k),f(i-1,j-a_i,k-b_i)+a_i)$。这玩意稍微算一下就知道过不去。\n因为转移已经是 $O(1)$ 的了，只能从状态入手。发现 $j,k$ 的转移都只和 $i$ 有关，可以搞成一维（类似emiya家今天的饭）：$f(i,d)$ 表示前 $i$ 个水果，卡路里与美味值差为 $d$ 的最大美味值。然后 $f(i,d)=\\max(f(i-1,d),f(i-1,d-(b_i-a_i))$。\n这样就解决了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 110, maxm = 3e5 + 10; int f[maxm], a[maxn], b[maxn], n, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; b[i], b[i] *= k; const int M = 1e5, D = 2e5; memset(f, -1, sizeof(f)); f[D] = 0; for (int i = 1; i \u0026lt;= n; i++) { int d = b[i] - a[i]; if (d \u0026gt; 0) { for (int j = -M; j + d \u0026lt;= M; j++) { if (f[j + D + d] != -1) f[j + D] = std::max(f[j + D], f[j + d + D] + a[i]); } } else { for (int j = M; j + d \u0026gt;= -M; j--) if (f[j + D + d] != -1) f[j + D] = std::max(f[j + D], f[j + d + D] + a[i]); } } cout \u0026lt;\u0026lt; (f[D] == 0 ? -1 : f[D]) \u0026lt;\u0026lt; endl; } D Description 给出一个 $n$ 个点，$m$ 条边的无向图，每条边有区间 $\\left[l_i,r_i\\right]$，求从 $1$ 到 $n$ 路径组成的边集，使该边集中所有区间的交内的正整数元素个数最多。\n$2\\leq n\\leq10^3,0\\leq m\\leq3\\times10^3$。\nSolution 数据范围这么小，我们直接枚举。\n考虑枚举一个区间的左端点，然后二分找最大的右端点，再 check 一下图是否联通即可。\n时间复杂度 $O(mn\\log m)$。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 3e3 + 10; struct UFS { int father[maxn], siz[maxn]; void init(int n = 1e3) { for (int i = 1; i \u0026lt;= n; i++) father[i] = i, siz[i] = 1; } int find(int x) { return x == father[x] ? x : father[x] = find(father[x]); } void uni(int x, int y) { int xx = find(x), yy = find(y); if (siz[xx] \u0026gt; siz[yy]) std::swap(xx, yy); father[xx] = find(yy), siz[yy] += siz[xx]; } bool ask(int x, int y) { return find(x) == find(y); } } ufs; struct edge { int x, y, l, r; bool operator\u0026lt;(const edge \u0026amp;b) const { return r \u0026lt; b.r; } } e[maxn]; int n, m; bool check(int x, int y) { ufs.init(n); for (int i = 1; i \u0026lt;= m; i++) if (e[i].l \u0026lt;= x \u0026amp;\u0026amp; e[i].r \u0026gt;= y) ufs.uni(e[i].x, e[i].y); return ufs.ask(1, n); } int solve(int x) { int l = 1, r = m, ans = 0; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (check(x, e[mid].r)) ans = mid, l = mid + 1; else r = mid - 1; } //cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e[ans].r \u0026lt;\u0026lt; endl; return e[ans].r - x + 1; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;e[i].x, \u0026amp;e[i].y, \u0026amp;e[i].l, \u0026amp;e[i].r); std::sort(e + 1, e + 1 + m); int ans = 0; for (int i = 1; i \u0026lt;= m; i++) ans = std::max(solve(e[i].l), ans); cout \u0026lt;\u0026lt; (ans == 0 ? \u0026#34;Nice work, Dima!\u0026#34; : std::to_string(ans)) \u0026lt;\u0026lt; endl; } E Description 给你一个 $n\\times m$ 矩阵。矩阵中有 $k$ 种元素。给你一个序列，你要将序列中的每一个元素转化为矩阵上的对应数字的坐标，并使得相邻元素表示的坐标的曼哈顿距离中的最大值最大，求出这个最大值。（建议看原题面）。\n$n,m\\leq2000$。$k\\leq9$。\nSolution 我们考虑算出每两种元素之间最大曼哈顿距离。\n有一个比较套路的做法：把曼哈顿距离展开： $$ dis=\\begin{cases}(x_1+y_1)-(x_2+y_2)\\\\(x_1-y_1)-(x_2-y_2)\\\\-(x_1-y_1)+(x_2-y_2)\\\\-(x_1+y_1)+(x_2+y_2)\\end{cases} $$ 也就是说最大曼哈顿距离一定是这四种中的一个，我们对每个颜色维护 $x_1+y_1,x_1-y_1$ 的最大值和最小值然后在上面四种情况里取最大值即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 2010; //const int dx[] = {0, 0, 1, -1}; //const int dy[] = {1, -1, 0, 0}; int ans[10][10], a[maxn][maxn]; int mxadd[10], miadd[10], mxmus[10], mimus[10], q[maxn], n, m, k, s; inline void upd(int \u0026amp;x, int y) { x = std::max(x, y); } inline void upd2(int \u0026amp;x, int y) { x = std::min(x, y); } struct point { int x, y; }; int main() { scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k, \u0026amp;s); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); memset(mimus, 1, sizeof(mimus)), memset(miadd, 1, sizeof(miadd)); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { upd(mxadd[a[i][j]], i + j); upd2(miadd[a[i][j]], i + j); upd(mxmus[a[i][j]], i - j); upd2(mimus[a[i][j]], i - j); } for (int i = 1; i \u0026lt;= k; i++) for (int j = 1; j \u0026lt;= k; j++) { ans[i][j] = std::max(std::max(abs(mxadd[i] - miadd[j]), abs(mxadd[j] - miadd[i])), std::max(abs(mxmus[i] - mimus[j]), abs(mxmus[j] - mimus[i]))); } int res = 0; for (int i = 1; i \u0026lt;= s; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;q[i]); for (int i = 1; i \u0026lt; s; i++) res = std::max(res, ans[q[i]][q[i + 1]]); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } ","permalink":"https://luoyisu.github.io/posts/cf-contest366/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e没啥难题，也没有什么特别推荐的题。（快来做前几天的题！！）\u003c/p\u003e","title":"Codeforces Round 214 (Div. 2)"},{"content":"概述 不简单，但也不算特别难。\nDiv1 的 BCDE 都值得一做。\n因为写得比较着急，可能有各种疏漏，见谅。\nDiv2 A Description 对于一个长度为 $n$ 的排列 $p$，定义其 fingerprint $F(p)$ 为 $p$ 中相邻元素和排序后得到的数组。更形式化地，\n$$F(p)=\\text{sort}([p_1+p_2,p_2+p_3,\\cdots,p_{n-1}+p_n])$$​。\n给定一个长度为 $n$ 的排列 $p$，你需要找到一个与 $p$​ 不同但 fingerprint 相同的排列。\nSolution 没啥可说的，看一看这个定义，因为是排列，直接倒序输出即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; int T; int main() { cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; a; for (int i = 1, x; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; x, a.push_back(x); std::reverse(a.begin(), a.end()); for (int u : a) cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } } Div2 B Description 给定一个序列 $a[1]-a[n]$​，满足 $\\sum_{i=1}^{n}a[i]=0$​。\n每次可以选两个数 $i$​，$j$​，使 $a[i]$ ​变为 $a[i]-1$​， $a[j]$ ​变为 $a[j]+1$​。\n当 $i\u0026lt;j$ ​​使操作无花费，否则操作花费 $1$​​。\n求使所有数都变为 $0$ ​所需的最小花费。\nSolution 显然我们需要尽可能进行无花费的操作。\n尽可能让前面的数减小，后面的数增加，但是要是已经是负的了，那么就需要花费代价。\n想一想再玩一玩样例，发现答案是最小前缀和的相反数（感性理解）。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 1e5 + 10; int n; int a[maxn]; long long sum[maxn]; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n; long long ans = 1ll \u0026lt;\u0026lt; 60; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], sum[i] = sum[i - 1] + a[i], ans = std::min(ans, sum[i]); cout \u0026lt;\u0026lt; std::abs(ans) \u0026lt;\u0026lt; endl; } } A Description 给定一个二进制字符串 由 0,1,? 组成。\n? 可以是 1 或者 0，由你自由选择。\n问你是否能构造出一个字符串，使得这个字符串每个长度为 $k$ 的子串中 0 和 1 的个数相等。\nSolution 不会做就找规律（）\n看样例发现这个东西很循环，往这个方面想一想就能想到：第 $s_i=s_{i+k}$。很显然不证明了。\n那么整个字符串就被分成了 $k$ 组，把已经确定的组都确定好，如果组内有矛盾显然无解。接着只检查 $s_1\\sim s_k$​ 合不合法即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 3e5 + 10; int a[maxn], n, k; char s[maxn]; bool solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; (s + 1); for (int i = 1; i \u0026lt;= n; i++) a[i] = s[i] == \u0026#39;?\u0026#39; ? -1 : s[i] - \u0026#39;0\u0026#39;; for (int i = 1; i \u0026lt;= k; i++) { int p = a[i]; for (int j = i + k; j \u0026lt;= n; j += k) if (a[j] != -1) p = a[j]; for (int j = i; j \u0026lt;= n; j += k) if (a[j] != -1 \u0026amp;\u0026amp; a[j] != p) return false; a[i] = p; } int cnt1 = 0, cnt2 = 0; for (int i = 1; i \u0026lt;= k; i++) if (a[i] == 1) cnt1++; else if (a[i] == -1) cnt2++; if (cnt1 \u0026lt;= k / 2 \u0026amp;\u0026amp; cnt1 + cnt2 \u0026gt;= k / 2) return true; return false; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { puts(solve() ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;); } } B Description 有一棵 $n$ 个点的树， Alice 和 Bob 初始在这棵树上的节点 $a$, $b$。\n他们可以在树上轮流移动一段距离不超过 $da$ 和 $db$ 的路径。\n路径长度的定义是两点之间树上简单路径的边数。\n如果 Alice 能在 $10^{100}$​ 次内追到 Bob ，那么则算 Alice 赢，否则算 Bob 赢。\nAlice 先走。\nSolution 看起来是个结论题，实际上也确实是。\n想一想加画一画能想到 Alice 获胜有以下三种情况。否则输。\n$dis(a,b)\\leq da$，一步就抓到了； $2da\\geq db$，可以一步一步逼近 Bob 胜利； Alice 走到一个能控制树上所有点的点，这样 Bob 不管怎么走都会输。这个时候需要满足 $2da\\geq d$，$d$ 是树的直径。 第一种情况很显然，第二种情况也挺显然：不管 Bob 怎么走，Alice 一定能拉近距离。\n第三种情况是很极限的情况，Bob 最远也只能走直径长度的路径，如果 Alice 能占据直径中点那自然必胜（建议画图理解）。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 1e5 + 10; int n, a, da, b, db; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } void clear() { for (int i = 1; i \u0026lt;= n; i++) e[i].clear(); } int dep[maxn]; void dfs(int x, int fa) { dep[x] = dep[fa] + 1; for (int v : e[x]) if (v != fa) dfs(v, x); } bool solve() { dep[0] = -1, dfs(b, 0); int rt = 0; int dis = dep[a]; if (dis \u0026lt;= da || 2 * da \u0026gt;= db) return true; for (int i = 1; i \u0026lt;= n; i++) if (dep[i] \u0026gt; dep[rt]) rt = i; dfs(rt, 0); for (int i = 1; i \u0026lt;= n; i++) if (dep[i] \u0026gt; dep[rt]) rt = i; int d = dep[rt]; //cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; if (da + da \u0026gt;= d) return true; return false; } int main() { std::ios::sync_with_stdio(false); int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; da \u0026gt;\u0026gt; db; for (int i = 1, x, y; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, add(x, y); puts(solve() ? \u0026#34;Alice\u0026#34; : \u0026#34;Bob\u0026#34;); clear(); } } C Description 给定一个含有 $n$​ 个正整数的序列 $a$​ ，对于一次操作，你可以任选一个位置 $i$​ 且满足 $a_i=i$​ ,那么就可以移除这个元素，并将后面所有的元素向前移动一位。\n对于每个相互独立的询问 $x,y$ 需要你求出在前 $x$ 个元素以及后 $y$ 个元素不能被移除的情况下，最多可以进行几次操作。\n$n,q \\leq 3\\times 10^5$。\nSolution 能想到能删除几个点和删除的顺序是没什么关系的，只要一个数前面能被删除的数足够多那么他就可以被删除（因为先删后面的不影响前面的）。\n考虑到这一点，我们直接让 $a_i=i-a_i$，每次删除一个数相当于区间减 $1$ 。显然负数永远都消不掉。\n这种奇怪的东西我们尝试把它离线下来。\n然后就不会了，我数据结构太差了qwq，直接看题解。。。\n要求解答案，我们需要尝试维护 $f_i$ 表示从 $i$ 开始能删掉几个数。\n我们把询问按照右端点排序，考虑加进去一个数之后对上面这个东西的贡献。\n显然 $f_i$ 是单调不增的，也就是说，对于前一部分，会使 $f_i$ 增加 $1$，后面不变。\n或者换个说法：$f_k\\geq q_r\u0026gt;f_{k+1}$。\n区间加 $1$，单点查询，选择树状数组。\n实际上只需要记录操作次数即可。\n至于怎么找这个 $k$​，树状数组上二分即可。\n有时间会写个线段树版，树状数组上二分还是很难受的。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 3e5 + 10; inline int lowbit(int x) { return x \u0026amp; -x; } int n, a[maxn], t[maxn]; void modify(int x, int v) { for (; x \u0026lt;= n; x += lowbit(x)) t[x] += v; } int query(int x) { int res = 0; for (; x; x -= lowbit(x)) res += t[x]; return res; } int kth(int k) { int res = 0; for (int i = 1 \u0026lt;\u0026lt; 18; i; i \u0026gt;\u0026gt;= 1) { if (res + i \u0026lt;= n \u0026amp;\u0026amp; k - t[res + i] \u0026gt; 0) res += i, k -= t[res]; } return res + 1; } struct Q { int l, r, ans, id; bool operator\u0026lt;(const Q \u0026amp;b) const { return r \u0026lt; b.r; } } q[maxn]; bool cmp(const Q \u0026amp;a, const Q \u0026amp;b) { return a.id \u0026lt; b.id; } int main() { int m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]), a[i] = i - a[i]; for (int i = 1, l, r; i \u0026lt;= m; i++) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r), q[i].id = i, q[i].l = 1 + l, q[i].r = n - r; std::sort(q + 1, q + 1 + m); int now = 1; for (int i = 1; i \u0026lt;= m; i++) { while (now \u0026lt;= q[i].r) { int pos = a[now] \u0026lt; 0 ? 1 : std::min(kth(now - a[now]), now + 1); modify(pos, 1), now++; } q[i].ans = q[i].r - query(q[i].l); } std::sort(q + 1, q + 1 + m, cmp); for (int i = 1; i \u0026lt;= m; i++) printf(\u0026#34;%d\\n\u0026#34;, q[i].ans); } D Description 这是一道交互题\n给定 $2n$ 个数 $1,2\\sim 2n$，A 和 B 进行交互，如下规则：\nA 需要将元素分成 $n$ 组 $\\mathbf{pair}$（二元组） B 从每组 $\\mathbf{pair}$ 中选择一个元素，如果权值和是 $2n$ 的倍数那么 B 胜，否则 A 胜。 你需要选择 A/B 中的一者扮演角色，并取得胜利。\n$n\\le 5\\times 10^5$​。\nSolution 观察样例 + 手算，发现当 $n$ 是偶数的时候，A 可以胜利：排一个 $(1,1+n),(2,2+n)\u0026hellip;$ 即可。\n简易证明：取出来 $n$ 个数的和在模 $n$ 意义下是 $n(n-1)/2$，设 $n=2m$，则和为 $m(2m-1)$，这玩意是必然没法被 $2m$ 整除的，也就是说在和在模 $n$ 意义下都没法是 $0$，那 $2n$ 就更不行了。\n然后盲猜：当 $n$ 是奇数，B 胜利。\n有了刚刚的偶数，我们可以考虑试图取在模 $n$ 意义下是 $0,1,2,\u0026hellip;,n-1$​ 的数，这些数加在一起一定是 $2n$ 的倍数。\n稍微证明一下为什么一定能取到：因为模 $n$ 相同的一个数有两个，取了一个就必然不会取另一个，我们把 $i,i+n$ 连起来，表示只选其中一个。\n同一组的两个数也不能同时选，我们也连起来。\n这样每个点的度数就是 $2$，也就是说连出了一堆环，且 $i,i+n$​​ 在一个环里且相邻。这样就能得出一定能取到了（好像不太严谨，感性理解吧）。\n选一个就不能选另一个，这是啥？无疑是二分图染色。\n我们对每个环二分图染色就能得到结果了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; void end() { int x; cin \u0026gt;\u0026gt; x; } const int maxn = 1e6 + 10; typedef std::pair\u0026lt;int, int\u0026gt; pii; int used[maxn], must[maxn], vis[maxn]; std::vector\u0026lt;int\u0026gt; e[maxn], ans[2]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } int lst[maxn]; void dfs(int x, int d) { ans[d].push_back(x); vis[x] = 1; for (int v : e[x]) if (!vis[v]) dfs(v, d ^ 1); } int main() { std::ios::sync_with_stdio(false); int n; cin \u0026gt;\u0026gt; n; if (n % 2 == 0) { cout \u0026lt;\u0026lt; \u0026#34;First\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; end(); return 0; } else { cout \u0026lt;\u0026lt; \u0026#34;Second\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n * 2; i++) { int x; cin \u0026gt;\u0026gt; x; if (lst[x]) add(lst[x], i); else lst[x] = i; } for (int i = 1; i \u0026lt;= n; i++) add(i, i + n); for (int i = 1; i \u0026lt;= 2 * n; i++) if (!vis[i]) dfs(i, 0); long long sum = 0; for (int k : ans[0]) sum += k; if (sum % (2 * n)) std::swap(ans[0], ans[1]); for (int k : ans[0]) cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; end(); return 0; } } E Description 你有一个 $n\\times m\\space(1 \\leq n, m\\leq200)$​ 的格子纸，格子要么涂黑（#）要么涂白（.）。你需要用若干个 $1\\times n$ ​和 $n\\times 1$ ​的长方形去覆盖所有黑色格子，要求不能盖到白色格子上，不能盖到其他长方形上，不能出格子纸的边界，求最小用多少个长方形。\nSolution 遇事不决看样例。发现对于一个点，横着的边和竖着的边不能同时选。\n选一个边就相当于少了一个矩形，那么我们就要尽可能多选边。\n一个常规套路：把边看成点，那么有两种点，且选了一个就不能选另一个，这是啥？不还是二分图吗！\n我们把与一个点相邻的相互垂直的边两两连起来。\n因为要多选点，也就是说要求二分图最大点独立集，那么只要求最大匹配即可，最大点独立集的大小就是点数减去最大匹配。\n就这么简单？确实就这么简单，但还有点小细节：假如一个黑色格子周围没有边，它应该被算进答案，但我们刚刚没算。\n那就加上即可，或者直接懒一点：最终答案 = 黑格子数 - 边数 + 最大匹配。\nCode 我这个代码感觉加边部分还是很清晰的。\n我是用点编号来代替边的编号，很简单。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using std::cerr; using std::cin; using std::cout; using std::endl; const int maxn = 100010; char str[210][210]; struct edge { int x, y, cap, flow; }; struct Dinic { std::vector\u0026lt;edge\u0026gt; edges; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y, int cap) { //cout \u0026lt;\u0026lt; \u0026#34;added: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; edges.push_back({x, y, cap, 0}); edges.push_back({y, x, 0, 0}); int m = edges.size(); e[x].push_back(m - 2), e[y].push_back(m - 1); } int dis[maxn], vis[maxn], cur[maxn], s, t; bool bfs() { std::queue\u0026lt;int\u0026gt; q; memset(vis, 0, sizeof(vis)); q.push(s), vis[s] = 1, dis[s] = 0; while (!q.empty()) { int x = q.front(); q.pop(); for (int i : e[x]) { auto \u0026amp;k = edges[i]; if (!vis[k.y] \u0026amp;\u0026amp; k.cap - k.flow \u0026gt; 0) dis[k.y] = dis[x] + 1, vis[k.y] = 1, q.push(k.y); } } return vis[t]; } int dfs(int x, int lim) { if (x == t || lim == 0) return lim; int res = 0, f; for (int \u0026amp;i = cur[x]; i \u0026lt; (int)e[x].size(); i++) { auto \u0026amp;k = edges[e[x][i]]; if (dis[k.y] != dis[x] + 1 || (f = dfs(k.y, std::min(lim, k.cap - k.flow))) == 0) continue; k.flow += f, edges[e[x][i] ^ 1].flow -= f, res += f, lim -= f; if (lim == 0) break; } return res; } int dinic(int s_, int t_) { s = s_, t = t_; int ans = 0; while (bfs()) memset(cur, 0, sizeof(cur)), ans += dfs(s, 1 \u0026lt;\u0026lt; 30); return ans; } } G; int n, m; inline int id(int x, int y) { return (y - 1) * n + x + n * m + 2; } inline int id2(int x, int y) { return m * (x - 1) + y + 1; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%s\u0026#34;, str[i] + 1); int s = 1, t = n * m * 2 + 3, tot = 0, cnt_p = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { if (str[i][j] == \u0026#39;#\u0026#39;) { cnt_p++; if (str[i + 1][j] == \u0026#39;#\u0026#39;) tot++, G.add(1, id2(i, j), 1); } } for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt; m; j++) { if (str[i][j] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; str[i][j + 1] == \u0026#39;#\u0026#39;) { //cout \u0026lt;\u0026lt; \u0026#34;cur: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; G.add(id(i, j), t, 1), tot++; if (i \u0026gt; 1 \u0026amp;\u0026amp; str[i - 1][j] == \u0026#39;#\u0026#39;) G.add(id2(i - 1, j), id(i, j), 1); if (i \u0026lt; n \u0026amp;\u0026amp; str[i + 1][j] == \u0026#39;#\u0026#39;) G.add(id2(i, j), id(i, j), 1); if (i \u0026gt; 1 \u0026amp;\u0026amp; str[i - 1][j + 1] == \u0026#39;#\u0026#39;) G.add(id2(i - 1, j + 1), id(i, j), 1); if (i \u0026lt; n \u0026amp;\u0026amp; str[i + 1][j + 1] == \u0026#39;#\u0026#39;) G.add(id2(i, j + 1), id(i, j), 1); } } cout \u0026lt;\u0026lt; cnt_p - (tot - G.dinic(s, t)) \u0026lt;\u0026lt; endl; } ","permalink":"https://luoyisu.github.io/posts/cf-contest1404/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e不简单，但也不算特别难。\u003c/p\u003e\n\u003cp\u003eDiv1 的 BCDE 都值得一做。\u003c/p\u003e\n\u003cp\u003e因为写得比较着急，可能有各种疏漏，见谅。\u003c/p\u003e","title":"Codeforces Round 668 (Div. 1\u00262)"},{"content":"概述 Div1 的 B、C、D、E 都值得一做。\nDiv2 A Description 有一个长度为 $n$​ 的序列，你需要找到一个非零整数 $d$​ 满足：当所有数都除以 $d$​ 之后（可以为小数），正数的个数要大于 $\\lceil\\dfrac{n}{2}\\rceil$​。\nSolution 当正数数量足够，$d=1$；当负数数量足够，$d=-1$，否则无解。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; int cnt = 0, n, cnt2; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1, x; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; x, cnt += x \u0026gt; 0, cnt2 += x \u0026lt; 0; int p = ceil(1.0 * n / 2); if (cnt \u0026gt;= p) puts(\u0026#34;1\u0026#34;); else if (cnt2 \u0026gt;= p) puts(\u0026#34;-1\u0026#34;); else puts(\u0026#34;0\u0026#34;); } Div2 B Description 萨沙和迪玛要做两个 $N$​ 层蛋糕，已知一条街上的 $2n$ 个商店 $a_1,a_2\u0026hellip;.a_{2n}$ ​每家只能提供一个 $a_i$ ​层蛋糕，蛋糕必须按照从 $1\\sim n$（从小到大）的顺序购买。最初，萨沙和迪玛位于第一个（最左边）房子附近。输出他们在购买两个蛋糕时必须行走的最小距离。相邻两栋房子之间的距离正好是 $1$。​\nSolution 显然两个人并没有什么特殊要求，找距离和最小的走即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 2e5 + 10; int a[maxn], b[maxn][2], n; inline int dis(int x, int y) { return std::abs(x - y); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= 2 * n; i++) { cin \u0026gt;\u0026gt; a[i]; if (b[a[i]][0]) b[a[i]][1] = i; else b[a[i]][0] = i; } int nowa = 1, nowb = 1; long long ans = 0; for (int i = 1; i \u0026lt;= n; i++) { int x = b[i][0], y = b[i][1]; if (dis(nowa, x) + dis(nowb, y) \u0026lt; dis(nowa, y) + dis(nowb, x)) ans += dis(nowa, x) + dis(nowb, y), nowa = x, nowb = y; else ans += dis(nowa, y) + dis(nowb, x), nowa = y, nowb = x; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } Div2 C Description 有一个 $n\\times n$ 的网格，有一些部分是陆地，剩下的是海洋。海洋不能通行。一个人想从一个格子出发到另一个格子。\n你可以造至多一个隧道连接两个格子，如果从 $(x_1,y_1)$ 连到 $(x_2,y_2)$，代价是 $(x_1-x_2)^2+(y_1-y_2)^2$。在陆地上行走没有代价。\n问最小代价是多少。$n\\leq50$。\nSolution 因为只能造一个隧道，我们只能在出发点所在陆地和终点所在陆地造一个隧道。\n$n$ 这么小，直接最暴力的暴力即可，找到出发地所在联通块所有点和终点所在联通块所有点，直接暴力找最小代价即可。\n时间复杂度 $O(n^4)$。\n优化其实也可以，我们只求出来每个联通块最外圈的点，这样就是 $O(n^2)$ 的了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int dx[] = {1, -1, 0, 0}; const int dy[] = {0, 0, -1, 1}; const int maxn = 55; struct point { int x, y; } s, t; char ss[maxn][maxn]; int a[maxn][maxn], vis[maxn][maxn], n; inline bool is_in(int x, int y) { return x \u0026gt;= 1 \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; y \u0026gt;= 1 \u0026amp;\u0026amp; y \u0026lt;= n; } void dfs(std::vector\u0026lt;point\u0026gt; \u0026amp;p, int x, int y) { vis[x][y] = 1; p.push_back({x, y}); for (int i = 0; i \u0026lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (is_in(nx, ny) \u0026amp;\u0026amp; !vis[nx][ny] \u0026amp;\u0026amp; a[nx][ny] == 0) dfs(p, nx, ny); } } inline int pow_2(int x) { return x * x; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s.x \u0026gt;\u0026gt; s.y \u0026gt;\u0026gt; t.x \u0026gt;\u0026gt; t.y; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; (ss[i] + 1); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) a[i][j] = ss[i][j] == \u0026#39;1\u0026#39; ? 1 : 0; std::vector\u0026lt;point\u0026gt; p, q; dfs(p, s.x, s.y), memset(vis, 0, sizeof(vis)), dfs(q, t.x, t.y); int ans = 1 \u0026lt;\u0026lt; 30; for (auto k : p) for (auto f : q) { ans = std::min(ans, pow_2(k.x - f.x) + pow_2(k.y - f.y)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } A Description 有 $n$ 个站台和一个玩具火车，第 $i$ 个站台单向连向第 $i+1$ 个站台，特殊地，第 $n$ 个站台连向第 $1$ 个站台。\n有 $m$ 个糖果，每个糖果初始在 $a_i$ 站台，要被送到 $b_i$​ 站台。\n火车经过一个站台时，可以卸下任意数量糖果，但只能往火车上装一个糖果。\n问从每个站台出发，把所有糖果运送到指定位置需要的时间。（经过一条边需要 $1$ 的时间）。\nSolution 一个站台里的糖果数决定了要经过这个站台的次数。\n显然只有最后一次经过拿的糖果的目的地能影响时间，我们贪心地让这个时间最小。\n预处理出从 $1$ 出发把每个车站的糖果的都送完的时间加上 $1$。\n输出一个车站的答案后，只需要把这个车站的时间都加上 $n$ 并更新答案即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 5100; int n, m; std::vector\u0026lt;int\u0026gt; all[maxn]; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int mx = 0; for (int i = 1, x, y; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; all[x].push_back(y \u0026lt; x ? y + n : y); } for (int i = 1; i \u0026lt;= n; i++) { std::sort(all[i].begin(), all[i].end(), std::greater\u0026lt;int\u0026gt;()); int now = 0; for (auto \u0026amp;p : all[i]) p += now, now += n, mx = std::max(mx, p); } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; mx - i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (auto \u0026amp;p : all[i]) p += n, mx = std::max(p, mx); } } B Description 给定一个序列 $a$，有 $n$ 个元素，编号从 $0$ 到 $n-1$。求 $\\max\\limits_{0 \\leq l \\leq r \\leq n-1}(r-l+1)\\times\\sum\\limits_{l\\leq i\\leq r}a_i$。\n有一个错误算法：\n```\rfunction find_answer(n, a)\r# Assumes n is an integer between 1 and 2000, inclusive\r# Assumes a is a list containing n integers: a[0], a[1], ..., a[n-1]\rres = 0\rcur = 0\rk = -1\rfor i = 0 to i = n-1\rcur = cur + a[i]\rif cur \u0026lt; 0\rcur = 0\rk = i\rres = max(res, (i-k)*cur)\rreturn res\r``` 你需要构造一组数据，使这个标准答案减去错误算法得出的答案是 $k$。\n$|a_i| \\leq 10^6,n \\leq 2000$。\nSolution 不难发现这个错误做法会在出现负数的时候出错，那么我们先安排一个 $-1$ 进去。\n这时候错误做法的答案是 $(\\sum a_i+1)(n-1)$，而正确答案是 $n\\times\\sum a_i$。\n那么应该新加进去的数是 $k-\\sum a_i+n$（这里的 $\\sum a_i,n$ 都是加进去之前的）。\n如果这个数比 $10^6$ 大我们就加进去 $10^6$，否则直接加该加的数即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int mx = 1e6; std::vector\u0026lt;int\u0026gt; ans; int k; int main() { ans.push_back(-1); int sum = -1, n = 1; cin \u0026gt;\u0026gt; k; while (sum - n + 1 \u0026lt; k) { if (k - sum + n \u0026lt;= mx) ans.push_back(k - sum + n), n++; else n++, ans.push_back(mx); sum += ans.back(); } cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for (int p : ans) cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } C Description 在摩尔斯电码（以下简称“摩码”）中，字母表中的一个字母被表示为一个长度为$1\\sim4$的 01 串。长度为 $1\\sim4$ 的 01串共有 $2^1+2^2+2^3+2^4=30$ 个，而字母只有 $26$ 个，所以有 $4$ 个 01 串不表示任何字母——0011、0101、1110、1111，其他 $26$ 个 01 串表示互不相同的 $26$ 个字母。 你有一个 01 串 $S$，初始为空。现在有 $m$ 次添加，每次往 $S$ 的末尾添加一个字符（0 或 1）。对于每一次添加，你都要回答目前的 $S$ 的所有非空子串用摩码所能表示的字母串的总数。由于答案可能巨大，你只需要输出答案模 $10^9+7$ 的结果。\n$m\\leq3000$。\nSolution $m$ 很小，我们可以考虑用暴力一点的方法草过去这个题。\n可以考虑对每个操作计算其对答案的贡献，那么我们就是要计算后缀对答案的贡献。\n发现我们的字母串是本质不相同的，使用 Trie 树就可以维护之前的所有前缀。\n进行一个操作时，我们在 Trie 树上的所有叶子节点下面都新开一个点，然后找它的 $4$ 个父亲（即枚举新后缀所在摩尔斯电码的长度），直接把方案数加上去就行。\n复杂度 $O(m^2)$。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 3000 * 3000 + 10, mod = 1e9 + 7; typedef long long ll; inline void upd(int \u0026amp;x, int y) { x += y % mod, x %= mod; } int ans = 0; struct Tree { int ch[maxn][2], f[maxn], tot, father[maxn], a[maxn]; void dp(int x) { int p = x; int s = 0; for (int i = 0; i \u0026lt; 4; i++) { int fa = father[x]; //cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; fa \u0026lt;\u0026lt; endl; int now = ch[fa][1] == x; s += now \u0026lt;\u0026lt; i; x = fa; if (i == 3 \u0026amp;\u0026amp; (s == 3 || s == 5 || s == 14 || s == 15)) continue; upd(f[p], f[x]); if (x == 0) break; } upd(ans, f[p]); } void insert(int x, int pos) { a[pos] = 0; for (int i = 0; i \u0026lt;= pos; i++) { int p = a[i]; if (!ch[p][x]) ch[p][x] = ++tot, father[tot] = p, dp(tot); a[i] = ch[p][x]; } } } t; int main() { int m; cin \u0026gt;\u0026gt; m; t.f[0] = 1; for (int i = 1; i \u0026lt;= m; i++) { int x; cin \u0026gt;\u0026gt; x; t.insert(x, i); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } D Description 给出一个长度为 $n$ 的序列，把它划分成若干段，使得每一段中出现过恰好一次的元素个数 $\\le k$，求方案数对 $998244353$ 取模后的结果。\nSolution 不难想到一个 DP：$f(i)$ 表示前 $i$ 位的答案。$f(i) = \\sum\\limits_{0 \\leq j \u0026lt; i \\wedge g(j+1, i) \\leq k} f(j)$。其中 $g(i,j)$ 表示区间 $[i,j]$ 中出现过恰好一次的元素个数。\n直接转移是 $O(n^2)$ 甚至 $O(n^3)$​ 的，想办法优化。\n不会，下文包括代码全是抄题解。\n因为恰好一次，我们想办法记录一个 $lst_i$​ 数组表示 $i$​ 上一次出现位置。\n我们维护 $g_j=g(j+1,i)$\n那么新加入 $a_i$​ 时，我们应该把 $[lst_{lst_{a_i}},lst_{a_i}-1)$​ 里的 $g$​​ 减一，把 $[lst_{a_i},i)$ 里的 $g$ 加上 $1$。\n问题变成有一个序列，每个元素有一个权值和键值。我们每次将区间键值 $\\pm1$，查询序列中键值 $\\leq k$​ 的元素权值和。\n对这种莫名其妙的维护我们可以尝试分块。\n对序列进行分块，对每个块维护一个 $sum(i,j)$ 表示第 $i$ 个块中 $g_p\\geq j$ 的 $f_p$ 之和。并维护一个 $all_i$ 表示块内所有 $f_p$​​​ 之和。\n$lzy$ 是块上的加法懒标记。\n查询直接遍历所有块把答案加进去即可（用 $all_i-sum(i,k-lzy_i+1)$ 就得到这个块的答案了）。\n修改怎么办呢？对于整块，我们直接加懒标记。\n对于散点，我们如果要把 $g_j$​​ 加上 $1$​​，那么就相当于把 $sum(i,g_j)$​​ 加上 $f_j$，反之同理。\n这样查询和修改就是 $O(1)$​ 的。\n时间复杂度 $O(nw+\\dfrac{n^2}{w})\\geq O(n\\sqrt n)$。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 1e5 + 10, mod = 998244353; typedef long long ll; int n, k, len, id[maxn], lst[maxn], tot; int f[maxn], sum[410][maxn], lzy[maxn], bl[maxn], cnt[maxn], br[maxn], all[maxn], a[maxn], llst[maxn]; inline void upd(int \u0026amp;x, int y) { x += (y + mod) % mod, x %= mod; } void add(int l, int r, int v) { if (l \u0026gt; r) return; if (id[l] == id[r]) { for (int i = l; i \u0026lt;= r; i++) if (v == 1) upd(sum[id[l]][++cnt[i]], f[i]); else upd(sum[id[l]][cnt[i]--], -f[i]); return; } for (int i = l; id[i] == id[l]; i++) if (v == 1) upd(sum[id[l]][++cnt[i]], f[i]); else upd(sum[id[l]][cnt[i]--], -f[i]); for (int i = r; id[i] == id[r]; i--) if (v == 1) upd(sum[id[r]][++cnt[i]], f[i]); else upd(sum[id[r]][cnt[i]--], -f[i]); for (int i = id[l] + 1; i \u0026lt; id[r]; i++) lzy[i] += v; } int work() { int res = 0; for (int i = 0; i \u0026lt;= tot; i++) { upd(res, all[i]); if (k - lzy[i] + 1 \u0026gt;= 0) upd(res, -sum[i][k - lzy[i] + 1]); else upd(res, -all[i]); } return res; } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; f[0] = 1, len = sqrt(n), tot = n / len + 1; for (int i = 1; i \u0026lt;= tot; i++) { bl[i] = (i - 1) * len, br[i] = std::min(i * len - 1, n); for (int j = bl[i]; j \u0026lt;= br[i]; j++) id[j] = i; } sum[1][0] = 1, all[1] = 1; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) { add(llst[a[i]], lst[a[i]] - 1, -1), add(lst[a[i]], i - 1, 1); llst[a[i]] = lst[a[i]], lst[a[i]] = i; f[i] = work(); upd(sum[id[i]][0], f[i]), upd(all[id[i]], f[i]); } cout \u0026lt;\u0026lt; f[n] \u0026lt;\u0026lt; endl; } E Description 这是一道交互题。\n有一个 $n$ 个节点的树，你需要通过不超过 $11111$ 次询问得知树的形态。\n询问方式为给出两个非空无交点集 $S$ ，$T$ 和一个点 $u$，可以得到满足 $s \\in S , t \\in T$ 且路径 $(s,t)$ 经过 $u$ 点的二元组 $(s,t)$ 的总数。\n$n\\leq500$。\nSolution 没什么头绪，看看我们能通过询问得到什么。\n假设我们以 $1$ 为根，每次询问 $(\\{1\\},\\{2,3,\u0026hellip;,n\\},i)$ 能得到以 $i$ 为根子树大小。\n那么把子树大小按从小到大排序，一个点儿子必定在其左侧，现在我们把问题转化为找儿子了。\n设现在还没有确定父亲的点集合为 $S$。\n问一次 $(\\{1\\},S,i)$ 能得到点 $i$ 的儿子个数 $k$，我们接下来二分 $k$ 次，每次找到一个最小的 $p$，使询问 $(\\{1\\},\\{S_1,S_2,\u0026hellip;,S_p\\},i)$ 的结果非零。\n那么这个 $p$​ 就是一个儿子。我们把它删掉接着二分就找到了所有儿子。\n找完之后把点 $i$ 加进集合里就行。\n时间复杂度 $O(n^2\\log n)$，询问次数大概是 $2n+2n\\log_2n$。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 510; struct node { int id, siz; bool operator\u0026lt;(const node \u0026amp;b) const { return siz \u0026lt; b.siz; } } a[maxn]; int father[maxn], n; void get_siz() { a[1].id = 1, a[1].siz = n; for (int i = 2; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; n - 1 \u0026lt;\u0026lt; endl; for (int i = 2; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; a[i].siz; a[i].id = i; } std::sort(a + 1, a + 1 + n); } int S[maxn], top; bool check(int x, int pos) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= x; i++) cout \u0026lt;\u0026lt; a[S[i]].id \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; int res = 0; cin \u0026gt;\u0026gt; res; return res \u0026gt; 0; } void solve() { //for (int i = 1; i \u0026lt;= n; i++) // cout \u0026lt;\u0026lt; a[i].id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[i].siz \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; i++) { if (a[i].siz == 1) S[++top] = i; else { //cout \u0026lt;\u0026lt; a[i].id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[i].siz \u0026lt;\u0026lt; \u0026#34;!!!\\n\u0026#34;; int times; cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; top \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= top; i++) cout \u0026lt;\u0026lt; a[S[i]].id \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; a[i].id \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; times; while (times--) { int l = 1, r = top, ans = -1; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (check(mid, a[i].id)) r = mid - 1, ans = mid; else l = mid + 1; } father[a[S[ans]].id] = a[i].id; int flag = 0; for (int i = 1; i \u0026lt; top; i++) { if (i == ans) flag = 1; if (flag) S[i] = S[i + 1]; } top--; } S[++top] = i; } } } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; get_siz(), solve(); cout \u0026lt;\u0026lt; \u0026#34;ANSWER\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 2; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; father[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://luoyisu.github.io/posts/cf-contest1129/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003eDiv1 的 B、C、D、E 都值得一做。\u003c/p\u003e","title":"Codeforces Round 542 (Div. 1\u00262)"},{"content":"概述 除了 Div2 的两道题，其他题都挺好的，建议做（）\nDiv2 A Description 有两个游戏机，当前电量分别为 $a,b$，你每秒可以给游戏机充 $1\\%$ 电，另一个游戏机会损失 $2\\%$ 电，问两个游戏机能同时工作的最长时间。\nSolution 选择电量较小的充电然后模拟。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; int a, b; int main() { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if (a == 1 \u0026amp;\u0026amp; b == 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } int ans = 0; while (a \u0026gt; 0 \u0026amp;\u0026amp; b \u0026gt; 0) { if (a \u0026gt;= b) b += 1, a -= 2; else a += 1, b -= 2; ans++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } Div2 B Description 有 $n$ 幅画，每幅画有一个美丽值 $a_i$，你可以任意排列这些画。当一个人从一幅画走到一幅美丽值更高的画时，他的心情会增加 $1$。\n求这个人从 $1$ 到 $n$ 依次经过这些画能得到的最高心情。\nSolution 我们贪心地找还没选过的美丽值最小的画，然后再选比它美丽值大的美丽值最小的画。用 multiset 实现。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;queue\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 1e5 + 10; std::multiset\u0026lt;int\u0026gt; S; int n, a[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i], S.insert(a[i]); int cnt = 0; while (S.size()) { int now = *S.begin(); S.erase(S.find(now)); auto pos = S.lower_bound(now + 1); while (pos != S.end()) { cnt++, S.erase(pos); now = *pos; pos = S.lower_bound(now + 1); } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } A Description 给出 $n$ 对坐标 $(x_i,y_i)$。求问曼哈顿距离和欧氏距离相等的坐标组 $(i,j)$（$1\\leq i\u0026lt;j\\leq n$）有多少对？$1\\leq n\\leq 2\\times 10^5,|x_i|,|y_i|\\leq 10^9$。\nSolution 不难发现两个点满足题目条件当且仅当两个点横坐标相同或纵坐标相同。\n容斥一下，答案等于横坐标相同的方案数 + 纵坐标相同的方案数 - 横纵坐标都相同的方案数。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;map\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; typedef std::pair\u0026lt;int, int\u0026gt; pii; std::map\u0026lt;int, int\u0026gt; mpx, mpy; std::map\u0026lt;pii, int\u0026gt; mp; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0, x, y; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, mpx[x]++, mpy[y]++, mp[pii(x, y)]++; long long ans = 0; for (auto k : mpx) ans += 1ll * k.second * (k.second - 1) / 2; for (auto k : mpy) ans += 1ll * k.second * (k.second - 1) / 2; for (auto k : mp) ans -= 1ll * k.second * (k.second - 1) / 2; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } B Description 从第一张照片开始看，可以向左翻或者向右翻，第 $1$​​​​​​ 张左边是第 $n$​​​​​ 张，第 $n$​​​​ 张右边是第一张，翻一次要 $a$​​​ 时间，照片有 w 和 h 两种摆放，w 的照片要耗费 $b$​​ 时间翻转，看一张照片要 $1$​ 个单位时间，一共有 $T$​ 个单位时间，问最多可以看多少张照片？\n建议看原题面。\nSolution 把环变成链，然后双指针就行。\n从 $l=2,r=n+1$ 开始移动指针。\n判断是否合法就是长度不超过 $n$，且当前区域看照片的时间加上移动的保底时间（$r-l-1$​）和折返的时间。\n建议多手玩。。。。\n说起来轻巧，但细节真多啊啊啊啊啊。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 1e6 + 10; int n, a, b, t, p[maxn], ans; char s[maxn]; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; t \u0026gt;\u0026gt; (s + 1); for (int i = 1; i \u0026lt;= n; i++) p[i] = 1 + (s[i] == \u0026#39;w\u0026#39; ? b : 0), p[i + n] = p[i]; int l = 2, r = n + 1, sum = 0; for (int i = 2; i \u0026lt;= n + 0; i++) sum += p[i]; //for (int i = 1; i \u0026lt;= 2 * n; i++) // cout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; endl; while (l \u0026lt;= n + 1 \u0026amp;\u0026amp; r \u0026lt;= 2 * n) { sum += p[r], r++; while (r - l \u0026gt; n || sum + a * (std::min(r - n - 2, n - l + 1) + r - l - 1) \u0026gt; t) sum -= p[l], l++; ans = std::max(ans, r - l); //cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } C Description 给定一 $N\\times M$​ 的表格 $a$，让你对其进行压缩，使得：\n每一行与每一列相对大小不变，即若 $a_{i,j}\u0026lt;a_{i,k}$​，则压缩后的 $a_{i,j}\u0026lt;a_{i,k}$​，对于小于及等于的情况和同列不同行的情况同理。 压缩后表格中的最大值尽量小。 输出压缩后的表格。\n$1\\leq n,m$ 且 $nm\\leq10^6$，$a_{i,j}\\leq10^9$​。\nSolution 发现题目唯一限制就是大小关系，很容易想到差分约束，我们对每一行和每一列，从小的连向大的，最后求一下最长路。\n对于相同的数，我们用一个并查集缩成一个点。\n能发现这个图是一个 DAG，我们直接 BFS 求最长路就行。\n可以建一个超级源点。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 1e6 + 10; int n, m; inline int id(int x, int y) { return (x - 1) * m + y; } struct node { int id, val; bool operator\u0026lt;(const node \u0026amp;b) const { return val \u0026lt; b.val; } }; std::vector\u0026lt;int\u0026gt; e[maxn]; std::vector\u0026lt;node\u0026gt; line[maxn], row[maxn]; inline void add(int x, int y) { e[x].push_back(y); } int father[maxn], rd[maxn], f[maxn]; int find(int x) { return x == father[x] ? x : father[x] = find(father[x]); } inline void uni(int x, int y) { father[find(x)] = find(y); } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1, x; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; x; father[id(i, j)] = id(i, j); line[i].push_back({id(i, j), x}); row[j].push_back({id(i, j), x}); } for (int i = 1; i \u0026lt;= n; i++) { std::sort(line[i].begin(), line[i].end()); for (int j = 0; j \u0026lt; m - 1; j++) if (line[i][j].val == line[i][j + 1].val) uni(line[i][j].id, line[i][j + 1].id); } for (int i = 1; i \u0026lt;= m; i++) { std::sort(row[i].begin(), row[i].end()); for (int j = 0; j \u0026lt; n - 1; j++) if (row[i][j].val == row[i][j + 1].val) uni(row[i][j].id, row[i][j + 1].id); } for (int i = 1; i \u0026lt;= n * m; i++) if (find(i) == i) add(0, i), rd[i]++; for (int i = 1; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt; m - 1; j++) if (line[i][j].val != line[i][j + 1].val) add(find(line[i][j].id), find(line[i][j + 1].id)), rd[find(line[i][j + 1].id)]++; for (int i = 1; i \u0026lt;= m; i++) for (int j = 0; j \u0026lt; n - 1; j++) if (row[i][j].val != row[i][j + 1].val) add(find(row[i][j].id), find(row[i][j + 1].id)), rd[find(row[i][j + 1].id)]++; std::queue\u0026lt;int\u0026gt; q; q.push(0); while (!q.empty()) { int now = q.front(); q.pop(); for (int v : e[now]) { f[v] = std::max(f[v], f[now] + 1); rd[v]--; if (rd[v] == 0) q.push(v); } } for (int i = 1; i \u0026lt;= n; i++, cout \u0026lt;\u0026lt; endl) for (int j = 1; j \u0026lt;= m; j++) cout \u0026lt;\u0026lt; f[find(id(i, j))] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } D Description 给定一个长度为 $n$ 的序列以及 $m$ 个操作，每个操作形如 $a_i~b_i$，表示将序列中第 $a_i$ 个数改为 $b_i$。\n对于每个操作，求出序列的最长严格上升子序列长度。\n注意：每个操作之间彼此独立。（即每次操作未进行时的序列是输入时的原序列，而不是上一次操作后得到的序列）\n$1\\leq n,m\\leq4\\times10^5$\nSolution 下文称“最长严格上升子序列”为 LIS。\n询问每次独立。求出原序列的答案之后，可以发现，每次修改之后 LIS 的变化只有以下三种：\n修改之后就没法选了，LIS 长度减小 $1$，这时原 LIS 必定包括这个数； 原来 LIS 不包括这个数，改完之后就能包括了，LIS 长度增加 $1$​； 其他，LIS 不变。 问题转化为修改一个数之后怎么快速求出包含这个数的 LIS 长度。\n设 $f_i$ 为以 $i$ 结尾的 LIS 长度，$g_i$ 表示以 $i$ 开头的 LIS 长度。\n首先求原序列，这个离散化之后用树状数组直接正着求 $f$​，倒着求 $g$​ 就可以。\n原序列的答案就是 $ans=\\max\\{f_i+g_i-1\\}$​。\n设把一个数 $i$ 修改后新的 $f_i,g_i$ 为 $f_i\u0026rsquo;,g_i\u0026rsquo;$ 。我们可以把以上的三种情况合并成 $2$​ 种：\n原 LIS 包括这个数，新答案为 $\\max(ans-1,f_i\u0026rsquo;+g_i\u0026rsquo;-1)$。 不包括，新答案为 $\\max(ans,f_i\u0026rsquo;+g_i\u0026rsquo;-1)$​。 所有询问的 $f_i\u0026rsquo;,g_i\u0026rsquo;$​​ 可以离线之后用一样的方法求出来。（想在线可以用主席树）\n现在只剩一个问题了，怎么判断一个数是否在 LIS 中？\n我们对 $f_i+g_i-1=ans$ 的 $f_i$ 都存起来，如果唯一就说明一定选了这个数。\nCode 有点重工业。重复的事情干很多次。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 8e5 + 10; int n, m, tot; int pool[maxn], a[maxn]; int f[maxn], g[maxn], cnt[maxn]; int ans = 0; struct Q { int id, val, x; int f, g, ans; bool operator\u0026lt;(const Q \u0026amp;b) const { return x == b.x ? val \u0026lt; b.val : x \u0026lt; b.x; } } q[maxn]; bool cmpid(const Q \u0026amp;a, const Q \u0026amp;b) { return a.id \u0026lt; b.id; } inline int lowbit(int x) { return x \u0026amp; -x; } int t[maxn]; void modify(int x, int v) { for (; x \u0026lt;= tot; x += lowbit(x)) t[x] = std::max(t[x], v); } int query(int x) { int res = 0; for (; x; x -= lowbit(x)) res = std::max(res, t[x]); return res; } void init() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], pool[++tot] = a[i]; for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; q[i].x \u0026gt;\u0026gt; q[i].val, q[i].id = i, pool[++tot] = q[i].val; std::sort(pool + 1, pool + 1 + tot); tot = std::unique(pool + 1, pool + 1 + tot) - pool - 1; for (int i = 1; i \u0026lt;= n; i++) a[i] = std::lower_bound(pool + 1, pool + 1 + tot, a[i]) - pool; for (int i = 1; i \u0026lt;= m; i++) q[i].val = std::lower_bound(pool + 1, pool + 1 + tot, q[i].val) - pool; for (int i = 1; i \u0026lt;= n; i++) f[i] = query(a[i] - 1) + 1, modify(a[i], f[i]); memset(t, 0, sizeof(t)); for (int i = n; i \u0026gt;= 1; i--) g[i] = query(tot - a[i]) + 1, modify(tot - a[i] + 1, g[i]); for (int i = 1; i \u0026lt;= n; i++) ans = std::max(ans, f[i] + g[i] - 1); for (int i = 1; i \u0026lt;= n; i++) if (f[i] + g[i] - 1 == ans) cnt[f[i]]++; } int main() { init(); std::sort(q + 1, q + 1 + m); int now = 1; memset(t, 0, sizeof(t)); for (int i = 1; i \u0026lt;= m; i++) { while (now \u0026lt; q[i].x) modify(a[now], f[now]), now++; q[i].f = query(q[i].val - 1) + 1; } now = n; memset(t, 0, sizeof(t)); for (int i = m; i \u0026gt;= 1; i--) { while (now \u0026gt; q[i].x) modify(tot - a[now] + 1, g[now]), now--; q[i].g = query(tot - q[i].val) + 1; } //for (int i = 1; i \u0026lt;= m; i++) // cout \u0026lt;\u0026lt; q[i].x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; q[i].val \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; q[i].f \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; q[i].g \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= m; i++) { if (f[q[i].x] + g[q[i].x] - 1 == ans \u0026amp;\u0026amp; cnt[f[q[i].x]] == 1) q[i].ans = std::max(ans - 1, q[i].f + q[i].g - 1); else q[i].ans = std::max(ans, q[i].f + q[i].g - 1); } std::sort(q + 1, q + 1 + m, cmpid); for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; q[i].ans \u0026lt;\u0026lt; endl; } E Description 给出两棵 $n$ 个节点的树，每次操作可以把第一棵树的一条边删掉然后连两个点，且必须满足每次操作完之后仍是一棵树。\n问最少需要多少步操作才能把第一棵树变成第二棵树（是完全相同，并不是同构），并输出方案。\n$n \\leq 5\\times 10^5$。\nSolution 同为 $3000+$ 分，这个题比前几天抄的一个 重工业数学题CF1190F 小清新多了。\n显然原来就相同的边不会被删掉，这样就得到了答案的下界。\n我们尝试构造一组达到下界的解。\n先 DFS 两棵树。\n用并查集把这些不用修改的边缩成一个点，每个集合代表元素就是这个集合在新树中深度最小的点。\n然后从原树从底向上进行操作，找到不在同一个集合的两个点，断开原来的边，连上深度大的点在新树的父亲。\n因为我们是从下到上操作，相当于每次操作时都是断开原树中叶子和它父亲的边，就能保证操作是合法的。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cctype\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 5e5 + 10; typedef std::pair\u0026lt;int, int\u0026gt; pii; struct Graph { std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } int father[maxn]; void dfs(int x, int fa) { father[x] = fa; for (int v : e[x]) if (v != fa) dfs(v, x); } int h[maxn], tot, vis[maxn]; void bfs() { std::queue\u0026lt;int\u0026gt; q; q.push(1); h[++tot] = 1; while (!q.empty()) { int x = q.front(); vis[x] = 1, h[++tot] = x; q.pop(); for (int v : e[x]) if (!vis[v]) q.push(v); } } } g1, g2; int n; int father[maxn]; int find(int x) { return x == father[x] ? x : father[x] = find(father[x]); } void uni(int x, int y) { father[find(x)] = find(y); } bool ask(int x, int y) { return find(x) == find(y); } void solve(int x, int fa) { for (int v : g1.e[x]) { if (v == fa) continue; solve(v, x); if (!ask(v, x)) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; find(v) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; g2.father[find(v)] \u0026lt;\u0026lt; endl; } } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 1, x, y; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, g1.add(x, y); for (int i = 1, x, y; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, g2.add(x, y); g1.dfs(1, 0), g2.dfs(1, 0); father[1] = 1; int ans = n - 1; for (int i = 2; i \u0026lt;= n; i++) { int f = g2.father[i]; if (g1.father[i] == f || g1.father[f] == i) father[i] = f, ans--; else father[i] = i; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; solve(1, 0); } ","permalink":"https://luoyisu.github.io/posts/cf-contest650/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e除了 Div2 的两道题，其他题都挺好的，建议做（）\u003c/p\u003e","title":"Codeforces Round 345 (Div. 1\u00262)"},{"content":"还可以。\nA Description 有一个整数 $x$，找到一对满足以下条件的两个正整数 $a,b$：\n$1\\leq a,b\\leq x$；\n$a$ 能被 $b$ 整除；\n$ab\u0026gt;x$；\n$\\dfrac{a}{b}\u0026lt;x$。\n$x\\leq100$。\nSolution $x$ 很小，直接枚举 $a,b$。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::cin; using std::cout; using std::endl; int main() { int x; cin \u0026gt;\u0026gt; x; for (int a = 1; a \u0026lt;= x; a++) for (int b = 1; b \u0026lt;= x; b++) if (a % b == 0 \u0026amp;\u0026amp; a * b \u0026gt; x \u0026amp;\u0026amp; 1.0 * a / b \u0026lt; x) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } } cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } B Description 有一个数组 $a$​，和一个正整数 $k$，你需要重复一下操作 $k$ 次：找到最小的非零数，把其它的数都减去这个数，把这个数变为 $0$。输出每次操作找到的数。\nSolution 排序然后模拟。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; int n, a[maxn], k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; std::sort(a + 1, a + 1 + n); int pos = 1, lzy = 0; while (k--) { int now = pos; if (pos \u0026gt; n) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; continue; } while (pos \u0026lt;= n \u0026amp;\u0026amp; a[pos] == a[now]) pos++; cout \u0026lt;\u0026lt; a[now] - lzy \u0026lt;\u0026lt; endl; lzy += a[now] - lzy; } } C Description 有一个长度为 $n$ 的数组 $\\{a_i\\}$，你可以对其进行一下两个操作之一：\n选一个下标 $i$ 和一个正整数 $x$，将这个数组以 $i$ 为结尾的前缀都加上 $x$； 选一个下标 $i$ 和一个正整数 $x$，将这个数组以 $i$ 为结尾的前缀都加对 $x$​ 取模。 你需要在 $n+1$​ 个操作内把这个数组变成严格单调递增的，输出你的操作。、\n$1\\leq n\\leq2000,0\\leq a_i\\leq10^5$，你选择的 $x$ 需要满足 $1\\leq x\\leq10^6$。\nSolution 发现 $n,a_i$ 都和 $x$ 差了很多，很容易想到构造一个 $1\\sim n+1$ 的数组的方法：我们可以直接把整个数组都加上一个很大的数，设这个数是 $X$，那么接下来 $n$ 次操作依次取模即可。\n具体地，第 $i$ 次第二个操作是把以 $i$ 为结尾的前缀对 $a_i+X-i$ 取模。\n确定 $X$ 的值也很简单，$X=(a_i-i)_{max}$​。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2010; int X = 1e6; int a[maxn], n; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; int mx = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], mx = std::max(mx, a[i] - i); X -= mx; cout \u0026lt;\u0026lt; n + 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; X \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[i] + X - i \u0026lt;\u0026lt; endl; return 0; } D Description 这是一道交互题。\n交互库选择了两个数 $(a,b)$​ 。每次询问一个二元组 $(c,d)$，返回 $a\\oplus c$ 和 $b\\oplus d$ 的大小关系。你需要在 $62$ 次询问内确定 $a,b$，保证 $0\\leq a,b\\leq2^{30}$。\nSolution 我们显然可以一位一位考虑，尝试在 $2$ 次操作之内得到一位的答案。\n考虑我们能得到什么信息，显然一开始询问 $(0,0)$ 可以得到 $a,b$ 的大小关系，那么我们就从大小关系入手。\n因为大小比较是从高到低比的，我们就从高到低确定每一位。\n假设我们在第 $i$​​ 位，有 $a,b$​​ 中包括这一位以及比这一位低的数的大小关系 $flag$​，比第 $i$​ 位高的已经确定好的 $a,b$​ 。我们先问一遍 $c=a\\oplus2^i,d=b\\oplus2^i$​​​。如果得到的大小关系和 $flag$ 不一样，那么 $a,b$ 在这一位就不相等，根据原先的 $flag$ 就能确定这一个 $1$ 在 $a,b$​ 的哪个数上，然后再问一次更新 $flag$；如果相等就再问一次确定这一位是 $1$ 还是 $0$。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; int flag; int ask(int a, int b) { int x; cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; x; if (x == -2) exit(0); return x; } int a, b, lsta, lstb; int main() { flag = ask(0, 0); for (int i = 29; i \u0026gt;= 0; i--) { int res = ask(a ^ (1 \u0026lt;\u0026lt; i), b ^ (1 \u0026lt;\u0026lt; i)); if (res != flag) { if (flag == -1) b ^= 1 \u0026lt;\u0026lt; i; else a ^= 1 \u0026lt;\u0026lt; i; flag = ask(a, b); } else { int p = ask(a ^ (1 \u0026lt;\u0026lt; i), b); if (p == -1) a ^= 1 \u0026lt;\u0026lt; i, b ^= 1 \u0026lt;\u0026lt; i; } } cout \u0026lt;\u0026lt; \u0026#34;!\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } E Description 给定一棵 $n$​​​ 个节点的树，点有点权 $a_u$​​，可能为负。现在请你在树上找出 $k$​（$1~\\leq~k~\\leq~n$）个不相交集合，每个集合中的点构成一个联通块。\n设选出的所有点的集合为 $s$，最大化 $\\dfrac{\\sum_{u\\in s}a_u}{k}$，在满足前面那个东西最大的前提下，最大化 $k$。\nSolution 发现我们是要最大化每个集合中点权和的平均值。\n那么有一个结论（感性理解）：我们选点权最大的集合，平均值最大。\n那么还要最大化 $k$，就尽可能多选这个点权最大的集合就行。\n设计一个很简单的树形 DP：$f(i)$ 为选 $i$​ 为根子树最大权值。$f(i)=w_i+\\sum max(0,f(v))$。\n然后统计一下最大值，再 DP 一次，然后再算一次 $f(i)$，这次当其已经成为最大值时，我们直接把这个连通块删掉，即把 $f(i)$ 设置为极小值即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 3e5 + 10; const long long inf = 1ll \u0026lt;\u0026lt; 60; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } int w[maxn], n; long long f[maxn], ans = -inf, cnt; void dfs(int x, int fa) { f[x] = w[x]; for (int v : e[x]) if (v != fa) dfs(v, x), f[x] += std::max(f[v], 0ll); } void dfs2(int x, int fa) { f[x] = w[x]; for (int v : e[x]) if (v != fa) dfs2(v, x), f[x] += std::max(f[v], 0ll); if (f[x] == ans) cnt++, f[x] = -inf; } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; for (int i = 1, x, y; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, add(x, y); dfs(1, 0); for (int i = 1; i \u0026lt;= n; i++) ans = std::max(ans, f[i]); memset(f, 0, sizeof(f)); dfs2(1, 0); cout \u0026lt;\u0026lt; ans * cnt \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } F Description 有一个给定一棵树，点有点权，其中这棵树满足除了权值最小的点外，每个点都有一个权值比它小的点与它相邻。权值最小的点唯一要求你重新构建这棵树，使得代价最小。计算代价的方法如下：\n一个点的代价为：$\\text{deg}_u \\times a_u$​​​，其中 $\\text{deg}_u$​​ 表示点 $u$​ 的度数，即新树中与 $u$ 直接相连的节点数。 一条边 $(u,v)$​​​​ 的代价为 $\\lceil \\log_2 \\text{dis}(u,v) \\rceil \\times \\min(a_u,a_v)$​​​)，其中 $\\text{dis}(u,v)$​​ 为 $u$​ 和 $v$ 在原树中的距离。 Solution 考虑最小生成树。\n这个点的代价就很怪，发现可以转到边上，那么在 $(u,v)$ 之间加一条边的代价就是 $a_u+a_v+\\lceil \\log_2 \\text{dis}(u,v) \\rceil \\times \\min(a_u,a_v)$。\n直接加边是 $O(n^2)$ 的，过不去。\n发现有一个条件没用，这个条件就是说如果我们以最小值为根遍历原树，每个点有且仅有一个点的权值小于它，就是他的父亲。\n边太多了，我们考虑少加一些边，即去掉一些肯定不优的。\n再次看一下式子，并想一想生成树——每个点只会往生成树里连一条边，也就是说我们需要给每个点找一个代价最小的边。\n那么对于一个点 $u$ ，显然不能从它的儿子里找，这显然比从祖先找要劣。再想一想，最远就是和根连边，因为如果不从他到根这条路径上找点，其他的点权值肯定比根大，距离也更长。\n因此就是要最小化 $a_v\\times(\\lceil \\log_2 \\text{dis}(u,v)\\rceil+1)$​，因为有 $\\log_2$，我们可以倍增找这个最小值。\n然后就做完了。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; namespace IO { // 省略 } using namespace IO; const int maxn = 5e5 + 10, inf = 1 \u0026lt;\u0026lt; 30; typedef long long ll; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } int f[maxn][26], a[maxn], n; int mi[maxn][26], mii; int dep[maxn]; long long ans = 0; void dfs(int x, int fa) { f[x][0] = fa, mi[x][0] = a[fa]; dep[x] = dep[fa] + 1; long long m = a[fa]; for (int i = 1; i \u0026lt;= 25; i++) { f[x][i] = f[f[x][i - 1]][i - 1]; if (f[x][i] == 0) break; m = std::min(m, 1ll * a[f[x][i]] * (i + 1)); } m = std::min(m, 1ll * a[mii] * (int(ceil(log2(dep[x] - 1))) + 1)); if (fa != 0) ans += m + a[x]; for (int v : e[x]) if (v != fa) dfs(v, x); } int main() { n = read(), a[0] = inf; for (int i = 1; i \u0026lt;= n; i++) a[i] = read(), mii = a[i] \u0026lt; a[mii] ? i : mii; for (int i = 1; i \u0026lt; n; i++) add(read(), read()); dfs(mii, 0); writeln(ans); return 0; } ","permalink":"https://luoyisu.github.io/posts/cf-contest1088/","summary":"\u003cp\u003e还可以。\u003c/p\u003e","title":"Codeforces Round 525 (Div. 2)"},{"content":"挺难的，但没有 DP 好评（）\nDiv2 A Description 假设一个人有 $n$ 点血，定义他的等级为 $$ \\begin{cases}\\text{A}\u0026amp;n\\bmod4=1\\\\ \\text{B}\u0026amp;n\\bmod4=3\\\\ \\text{C}\u0026amp;n\\bmod4=2\\\\ \\text{D}\u0026amp;n\\bmod4=0 \\end{cases}$$。并定义等级由 $\\text{D}\\sim\\text{A}$ 依次更好。\n现在给出一个人的血量 $x$，他可以回 $0\\sim2$ 点血。问回几点血得到的等级最高。\nSolution 分类讨论即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; int main() { int n; cin \u0026gt;\u0026gt; n; if (n % 4 == 1) cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; else if (n % 4 == 2) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026#34;B\u0026#34; \u0026lt;\u0026lt; endl; else if (n % 4 == 3) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } Div2 B Description Tokitsukaze 有 $3$ 块麻将，每个麻将上有一个 $2$ 位的字符串，由 $1\\sim9$ 的一位数字和 m/s/p 组成，现在有两种出牌方式：\n3个完全一样的麻将； 第2位相同，前面是连号的（比如1p，2p，3p就可以）。 但是 Tokitsukaze 不是个遵守规则的人，TA可以把任意一个麻将换成另一种麻将，可以换多次，也可以不换。问 Tokitsukaze 至少要换多少次才能一次出完 $3$ 个麻将？\nSolution 模拟，但是可以想办法简化代码。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; using std::cin; using std::cout; using std::endl; std::string a, b, c; std::string s[3]; int main() { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; if (a == b \u0026amp;\u0026amp; b == c) // 三个一样 { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } s[0] = a, s[1] = b, s[2] = c; std::sort(s, s + 3); if (s[0][0] + 1 == s[1][0] \u0026amp;\u0026amp; s[1][0] + 1 == s[2][0] \u0026amp;\u0026amp; s[0][1] == s[1][1] \u0026amp;\u0026amp; s[2][1] == s[1][1]) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; // 已经是顺子 return 0; } if (s[0] == s[1] || s[1] == s[2] || s[0] == s[2]) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; // 两个一样 return 0; } for (int i = 0; i \u0026lt; 2; i++) for (int j = i + 1; j \u0026lt; 3; j++) { if ((s[i][0] + 1 == s[j][0] || s[j][0] + 1 == s[i][0] || s[i][0] + 2 == s[j][0] || s[j][0] + 2 == s[i][0]) \u0026amp;\u0026amp; s[i][1] == s[j][1]) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; // 两个相邻或差一个 return 0; } } cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; } A Description 最近，Tokitsukaze 发现了一个有趣的游戏。在游戏开始，有 $n$ 个数（$1\\sim n$）。这 $n$ 个数每 $k$ 个被分为一组（最后一组可能不到 $k$ 个）。现在她想拿出 $m$个数 $p_1, p_2,\\dots,p_m$（输入保证该序列为升序）。她会从 $1$ 到 $n$ 逐个看，如果发现了她想要的数，那么她会将这组数中所有她想要的都取走，算作一次操作。一次操作结束后，数列中的数会自动左移补上被拿出的数的位置，但数值不变。求经过多少次操作后，她能取到所有她想要的数？$1\\leq n\\leq10^{18},1\\leq m\\leq10^5$。\nSolution 显然需要一个 $O(m)$ 的算法，我们对于每个数，算出来它在哪个块里，然后把在块里的数全跳过去就行。\n假设当前数是 $p_i$，之前已经拿了 $del=i-1$ 个数，那么它所在的块就是 $\\lceil\\dfrac{p_i-del}{k}\\rceil$。\nCode 要注意 ceil 返回值是 double，会有精度问题，用返回值是 long double 的 ceill 就没有这个问题了。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; typedef long long ll; ll n, m, k; ll a[maxn]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; ll now = 1, ans = 0; for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; a[i]; while (now \u0026lt;= m) { ll del = now - 1; ll nowblock = ceill(1.0l * (a[now] - del) / k); while ((ll)ceill(1.0l * (a[now] - del) / k) == nowblock) now++; ans++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } B Description A 和 B 在玩一个小游戏，轮流从 $n$ 堆石子里拿石子，一次拿一个。当拿之前所有石子都被拿完了或拿完一个石子之后有两堆石子剩余个数一样（包括都为空的石子），A 先手，问谁能赢。\nSolution 手玩一下发现当两个人开始轮流取的时候，取什么都是一样的，而最终一定会变成每堆石子的数目分别为 $0\\sim n-1$ 这种情况。\n所以直接算一下每堆石子和最终状态差值，看看是奇数还是偶数就知道谁赢了。\n需要提前看一下能不能进入轮流取的情况，即先手拿完第一下会不会输。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; int n, a[maxn]; std::map\u0026lt;int, int\u0026gt; cnt; bool check() { cnt.clear(); for (int i = 0; i \u0026lt; n; i++) if (cnt.count(a[i])) return false; else cnt[a[i]] = 1; if (cnt[0] == n) return false; return true; } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i], cnt[a[i]]++; int ok = 1; if (cnt[0] \u0026gt;= 2) // 有不止一个 0，先手输 { cout \u0026lt;\u0026lt; \u0026#34;cslnb\u0026#34; \u0026lt;\u0026lt; endl; return 0; } int tot = 0; for (int i = 0; i \u0026lt; n; i++) { if (cnt[a[i]] \u0026gt;= 3) // 同一个数出现超过两次，先手输 { ok = 0; break; } else if (cnt[a[i]] \u0026gt;= 2) // 同一个数出现两次，比它小 1 的数出现过，先手输 { if (cnt[a[i] - 1] \u0026gt;= 1) { ok = 0; break; } } } for (auto k : cnt) { if (k.second \u0026gt;= 2) tot++; } if (tot \u0026gt;= 2) // 出现两次的数超过 1 个，先手输 { ok = 0; } if (!ok) { cout \u0026lt;\u0026lt; \u0026#34;cslnb\u0026#34; \u0026lt;\u0026lt; endl; return 0; } std::sort(a, a + n); long long sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += std::max(0, a[i] - i); } cout \u0026lt;\u0026lt; (sum % 2 ? \u0026#34;sjfnb\u0026#34; : \u0026#34;cslnb\u0026#34;) \u0026lt;\u0026lt; endl; } C Description 有一个长度为 $n$ 的01字符串，和一个整数 $k$。A、B。二人进行做博弈游戏，每个人必须选择连续的 $k$ 个字符，把这连续的 $k$ 个字符全变为 $0$ 或者 $1$。\n如果某次操作之后整个字符串全为 $1$ 或者 $0$，那么这个人胜利，假设二人都绝顶聪明。给你初始局面，A先手，问 A、B 谁能赢，又或者平局。\nSolution 发现一个事情：如果先手第一次操作后赢不了，那么以后永远都赢不了。因为后手可以把他的操作改回去。\n而如果后手第一次操作后赢不了，那么必定平局——即把先手操作改回去来防御，如此循环。\n判断先手能不能赢很简单，前缀和一下即可。\n怎么判断后手能不能赢呢？\n首先必须满足 $k\\neq1\\operatorname{and}2k\\geq n$，前一个要求很好理解，后一个要求就是说如果先手赢不了，他直接修改两边就行，后手赢不了。\n我们先枚举先手选的区间 $[l,r]$，如果 $a_{l-1}\\neq a_{l}\\operatorname{or} a_r\\neq a_{r+1}$，那么就会平局（先手可以把这个区间全改成挨着它的那个颜色，这样后手就改不过来）。如果每一个区间先手都没法让他变平局，后手胜利。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; int n, a[maxn], sum[maxn], k; char ss[maxn]; inline int s(int l, int r) { return l \u0026gt; r ? 0 : sum[r] - sum[l - 1]; } bool check1() { for (int i = 1; i + k - 1 \u0026lt;= n; i++) { int p = s(1, i - 1) + s(i + k, n); // 判断先手必胜 if (p == 0 || p + k == n) return true; } return false; } bool check2() { if (k == 1 || k * 2 \u0026lt; n) return false; for (int i = 2; i \u0026lt;= n - k - 1; i++) { if (a[i] != a[i - 1] || a[i + k] != a[i + k + 1]) return false; } return a[1] != a[n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; (ss + 1); for (int i = 1; i \u0026lt;= n; i++) a[i] = ss[i] - \u0026#39;0\u0026#39;, sum[i] = sum[i - 1] + a[i]; if (check1()) { cout \u0026lt;\u0026lt; \u0026#34;tokitsukaze\u0026#34; \u0026lt;\u0026lt; endl; return 0; } else if (check2()) { cout \u0026lt;\u0026lt; \u0026#34;quailty\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;once again\u0026#34; \u0026lt;\u0026lt; endl; } } D Description 平面上有 $n$ 个点，坐标为 $(x_i,y_i)$，有三条直线，两条平行 $y$ 轴，一条平行 $x$ 轴，他们会围起一些点。如图：\n求对于这三条线所有的可能，有多少种非空点集会被这三条线围起来。\n$n\\leq2\\times10^5,1\\leq x_i,y_i\\leq10^9$。\nSolution 发现这个平行 $x$ 轴的直线可以作为突破点。\n首先把所有点坐标离散化一下。\n我们从上到下移动这条线 $y=a$，当它扫到一个点时，我们把所有 $y\\geq a$ 的点的答案都算进去。这样就不会算重也不会漏。\n考虑这条线上只有一个点的情况，那么新的点集数就是 $cnt(1,x)\\times cnt(x,x_{max})$，其中 $cnt(l,r)$ 表示在 $x=l$ 到 $x=r$ 这段闭区间内每条总共有几个横坐标不同的点（注意新扫到的点也算在内），解释就是从左面的直线有 $cnt(1,x)$ 种可以取的地方，右面同理，然后乘法原理一下。\n如果直线上有多个点呢？我们先把所有点都算进去，然后对于每个点的贡献就是 $cnt(nxt+1,x)\\times cnt(x,x_{max})$，其中 $nxt$ 是这条直线上在当前点左面的点的横坐标。\n怎么维护 $cnt$？发现我们需要单点加区间求和，那么树状数组就可以胜任了。\n时间复杂度 $O(n\\log n)$。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cout; using std::endl; const int maxn = 2e5 + 10; struct point { int x, y; } a[maxn]; int XX[maxn], YY[maxn], n, totx, toty, cnt[maxn]; std::vector\u0026lt;int\u0026gt; p[maxn]; inline int lowbit(int x) { return x \u0026amp; -x; } struct Tree { int t[maxn], n; void modify(int x, int v) { for (; x \u0026lt;= n; x += lowbit(x)) t[x] += v; } int get(int x) { int res = 0; for (; x; x -= lowbit(x)) res += t[x]; return res; } int query(int l, int r) { return get(r) - get(l - 1); } } t; void init() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;XX[i], \u0026amp;YY[i]), a[i].x = XX[i], a[i].y = YY[i]; std::sort(XX + 1, XX + 1 + n), std::sort(YY + 1, YY + 1 + n); totx = std::unique(XX + 1, XX + 1 + n) - XX - 1, toty = std::unique(YY + 1, YY + 1 + n) - YY - 1; for (int i = 1; i \u0026lt;= n; i++) a[i].x = std::lower_bound(XX + 1, XX + 1 + totx, a[i].x) - XX, a[i].y = std::lower_bound(YY + 1, YY + 1 + toty, a[i].y) - YY; for (int i = 1; i \u0026lt;= n; i++) p[a[i].y].push_back(a[i].x); for (int i = 1; i \u0026lt;= toty; i++) std::sort(p[i].begin(), p[i].end()); t.n = n; } int main() { init(); long long ans = 0; for (int y = toty; y \u0026gt;= 1; y--) { int nxt = 1; for (int x : p[y]) if (cnt[x] == 0) t.modify(x, 1), cnt[x]++; for (int x : p[y]) ans += 1ll * t.query(nxt, x) * t.query(x, totx), nxt = x + 1; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } E Description 给定平面上$N$个关键点，现在你可以放置 $M$ 条直线，直线之间可以相交，需要满足所有关键点与原点之间的线段至少与你放置的一条直线相交（相交在端点也算相交）。如果有一个关键点就是原点，那么一定要满足有一条直线经过原点。\n你需要求出在满足上述条件的情况下原点到所有放置的直线的距离的最小值的最大可能值是多少。\n$n,x_i,y_i,m\\leq10^5$。\nSolution 显然可以二分答案 $ans$，可以发现我们选择的直线一定在原点为圆心，半径为 $ans$ 的圆的切线上（因为这样更优）。\n发现一个点到原点的直线被一条选择的直线经过等价于这条被选择的直线与圆的切点在这个点到圆两条切线之间的圆弧上。\n那么我们的问题就转化为圆上有若干个圆弧，要覆盖整个圆，求这 $m$ 个圆弧能不能达成目的。\n这个问题如果在序列上做是很经典的题，就是区间覆盖，按照左端点排序即可。我们可以把一个圆弧用两个角度来表示就实现了转化。\n但是现在是在一个环上，我们肯定把长度变为二倍然后变成序列题目。\n直接找一个起点跑是 $O(n^2)$ 的，不行。\n我们可以想办法预处理一些什么东西。\n发现对于每条线段，我们如果选择它，那么选择的下一条线段是确定的。这个东西可以用类似双指针的算法预处理出来。\n然后，如果每步的决策是固定的，我们显然可以倍增优化。\n$f_{i,j}$ 表示第 $i$ 条线段选 $2^j$ 条线段之后下一个到了哪条线段。然后就行了。\n时间复杂度 $O(n\\log n\\log d)$，$d$ 是到原点最近的点到原点的距离。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; const double eps = 1e-10, pi = acos(-1.0), pi2 = pi * 2; struct seg { double l, r; bool operator\u0026lt;(const seg \u0026amp;b) const { return l \u0026lt; b.l; } } s[maxn * 2]; struct point { double x, y, diss; double dis() { return diss = sqrt(x * x + y * y); } } p[maxn]; int n, m, n2; int f[maxn * 2][25]; int end(int x, int d) { for (int i = 0; d; i++, d \u0026gt;\u0026gt;= 1) if (d \u0026amp; 1) x = f[x][i]; return x; } bool check(double x) { for (int i = 1; i \u0026lt;= n; i++) { double k = atan2(p[i].y, p[i].x), delta = acos(x / p[i].diss); s[i] = {k - delta, k + delta}; if (s[i].l \u0026lt; 0) s[i].l += pi2, s[i].r += pi2; s[i + n] = {s[i].l + pi2, s[i].r + pi2}; } std::sort(s + 1, s + 1 + 2 * n); f[n2 + 1][0] = n2 + 1; int r = n2, l = n2; for (; l; l--) { while (s[r].l \u0026gt; s[l].r) r--; f[l][0] = r + 1; } for (int i = 1; i \u0026lt;= 19; i++) for (int j = 1; j \u0026lt;= n2 + 1; j++) f[j][i] = f[f[j][i - 1]][i - 1]; for (int i = 1; i \u0026lt;= n; i++) if (end(i, m) \u0026gt;= i + n) return true; return false; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m, n2 = n * 2; double r = 1e18, l = 0.0; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; r = std::min(p[i].dis(), r); } while (r - l \u0026gt; eps) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } printf(\u0026#34;%.10lf\\n\u0026#34;, l); } F Description 给出三个整数 $n,m,p$，试求出 $n$ 个互不相同的整数使得它们中的每个整数 $x$ 均满足以下条件：\n$x \\in [0,m-1]$ $\\gcd(m,x) = 1$ $\\nexists e,k \\in \\mathbb{N},p^e = km+x$ 如果能够找到，输出可能的选择方案，否则输出 -1。\n$1 \\leq n \\leq 5 \\times 10^5 , 1 \\leq p \u0026lt; m \\leq 10^{18}$，保证 $m$ 是某个质数的正整数次幂。\nSolution 完全不会，以下是从各路题解拼凑出来的东西。\n明确一下题目要求，设 $S=\\{x|x\\in\\mathbb Z,0\\leq x\u0026lt;m,\\gcd(m,x)=1\\},T=\\{p^e\\bmod m|e\\in N\\}$，我们需要从集合 $S-T$ 中找出 $n$ 个数。\n设 $m=q^k$。\n要判断有解，我们显然需要判断 $S-T$ 的大小。显然 $|S|=\\varphi(m)=q^k-q^{k-1}=m(1-\\dfrac{1}{q})$。\n当 $\\gcd(q,m)\u0026gt;1$，$m$ 是 $q$ 的倍数，那么 $T=\\{p^0\\}=\\{1\\}$。（$0$ 不合法）此时 $|S-T|=\\varphi(m)-1$，判是否有解然后暴力枚举一组解就行。\n否则 $T\\subseteq S$，我们需要求出来 $|T|$，集合 $T$ 肯定是循环的，其实就是求 $p$ 的阶 $\\text{order(p)}$，这玩意是 $\\varphi(m)$ 的约数，而约数个数是不多的，我们可以用 Pollard-Rou 分解质因数然后枚举因数检查就能知道 $p$ 的阶。那么如果 $\\varphi(m)-\\text{order}(p)\u0026lt;n$，无解。\n下面是构造解的过程：\n当 $m$ 存在原根 $g$ 时，设 $p\\equiv g^u\\pmod m$，那么一个数 $p^e=g^{ue}\\equiv g^{ue\\ \\bmod\\ \\varphi(m)}\\pmod m$ （由欧拉定理）在 $T$ 中当且仅当关于 $e$ 的方程 $ue\\equiv v\\pmod{\\varphi(m)}$ 有解。这个有解的充要条件是 $\\gcd(u,\\varphi(m))\\mid v$。又由于 $(g^{u})^{\\text{order}(p)}\\equiv1\\pmod m$，可以得出 $u=\\dfrac{\\varphi(m)}{\\text{order}(p)}$（欧拉定理）。\n这样就得出了不合法的数的性质，我们从小到大暴力枚举指数，检查是否合法即可。\n当 $m$ 不存在原根即 $m=2^k,k\\geq3$，且 $p$ 是奇数（因为要互质）。\n用以下做法：\n当 $m\\leq10^7$，暴力。 当 $p=4x+1$，$\\forall e\\in\\mathbb N,p^e\\equiv1\\pmod4$，那么我们直接在模 $4$ 余 $3$ 的数里选即可，因为数据范围很大，总能找到。 当 $p=4x+3$，我们只能选模 $4$ 余 $1$ 的数，注意到在 $p^e$ 中，$1$ 和 $3$ 总是交替出现。那么把 $p$ 换成 $p^2$。还有一个事情是：在模 $2^k$（$k\\geq3$）意义下，取一个伪原根 $g\u0026rsquo;=5$，任意一个模 $4$ 余 $1$ 的数都可以用 $g\u0026rsquo;$ 的若干次幂表示出。可以对 $k$ 用归纳法证明，我懒了。于是就用有原根的方法做即可。 顺便一提，怎么找原根呢？上定理！\n原根判定定理：设 $m \\geqslant 3, \\gcd(a,m)=1$，则 $a$ 是模 $m$ 的原根的充要条件是，对于 $\\varphi(m)$ 的每个素因数 $p$，都有 $a^{\\frac{\\varphi(m)}{p}}\\not\\equiv 1\\pmod m$。\n最小原根的数量级：若 $m$ 有原根，则其最小原根是不多于 $m^{0.25}$ 级别的。\n我们只需要分解质因数，然后从小到大原根枚举检验即可。\nCode 不好写，因为这题实在太难，参考了 CF 上别人的代码。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; using std::cerr; using std::cin; using std::cout; using std::endl; typedef __int128_t ll; namespace IO { const int mxsiz = 1 \u0026lt;\u0026lt; 20; char inbuf[mxsiz], *p1, *p2; char outbuf[mxsiz], *op = outbuf; struct endio { endio(){}; ~endio() { fwrite(outbuf, 1, op - outbuf, stdout); } } useless_var; inline char gc() { return p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = inbuf) + fread(inbuf, 1, mxsiz, stdin), p1 == p2) ? EOF : *p1++; } #define isdigit(x) (x \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;9\u0026#39;) // 防止忘记打 \u0026lt;cctype\u0026gt; 头文件 inline ll read() { ll x = 0; int f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x * f; } template \u0026lt;typename T\u0026gt; inline void read(T \u0026amp;x) { x = 0; int f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; x *= f; } #undef isdigit inline bool ischar(char x) { return x \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;z\u0026#39;; } inline char readchar() { char ch = gc(); while (!ischar(ch)) ch = gc(); return ch; } inline void push(char ch) { if (op - outbuf == mxsiz) fwrite(outbuf, 1, mxsiz, stdout), op = outbuf; *op++ = ch; } template \u0026lt;typename T\u0026gt; inline void work_wt(T x) { if (x \u0026gt; 9) work_wt(x / 10); push(x % 10 + \u0026#39;0\u0026#39;); } template \u0026lt;typename T\u0026gt; inline void write(T x) { if (x \u0026lt; 0) x = -x, push(\u0026#39;-\u0026#39;); work_wt(x); } inline void writestr(const char *s) { int n = strlen(s); for (int i = 0; i \u0026lt; n; i++) push(s[i]); } inline void endln() { push(\u0026#39;\\n\u0026#39;); } inline void space() { push(\u0026#39; \u0026#39;); } template \u0026lt;typename T\u0026gt; inline void writeln(T x) { write(x), endln(); } } using namespace IO; const ll inf = 1e18; ll n, m, p; ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); } ll qpow(ll a, ll x, ll p) { ll res = 1; for (; x; x \u0026gt;\u0026gt;= 1, a = a * a % p) if (x \u0026amp; 1) res = res * a % p; return res; } bool MR(ll x) { if (x \u0026lt; 3 || x % 2 == 0) return x == 2; ll a = x - 1, b = 0; while (a % 2 == 0) a /= 2, b++; for (ll times = 0, j; times \u0026lt; 10; times++) { ll c = rand() % (x - 2) + 2, v = qpow(c, a, x); if (v == 1) continue; for (j = 0; j \u0026lt; b; j++) { if (v == x - 1) break; v = v * v % x; } if (j \u0026gt;= b) return false; } return true; } ll myabs(ll x) { return x \u0026lt; 0 ? -x : x; } ll PR(ll x) { ll c = rand() % (x - 1) + 1, val = 1, s = 0, t = 0; for (ll lim = 1;; lim \u0026lt;\u0026lt;= 1, s = t, val = 1) { for (ll step = 1; step \u0026lt;= lim; step++) { t = (t * t + c) % x; val = val * myabs(t - s) % x; if (step % 127 == 0) { ll d = gcd(val, x); if (d \u0026gt; 1) return d; } } ll d = gcd(val, x); if (d \u0026gt; 1) return d; } } void out_ans(const std::vector\u0026lt;ll\u0026gt; \u0026amp;ans) { if (ans.size() \u0026lt; n) writeln(-1); else { for (int i = 0; i \u0026lt; n; i++) write(ans[i]), space(); endln(); } } namespace BF { const int maxm = 1e7 + 10; bool vis[maxm]; void solve() { ll now = p; vis[1] = 1; while (!vis[now]) { vis[now] = 1; now = now * p % m; } for (int i = 2; i \u0026lt;= m; i++) if (m % i == 0) { for (int j = 1; i * j \u0026lt;= m; j++) vis[i * j] = 1; break; } std::vector\u0026lt;ll\u0026gt; ans; for (int i = 1; i \u0026lt;= m; i++) if (!vis[i]) ans.push_back(i); out_ans(ans); } } struct primes { ll val; int times; bool operator\u0026lt;(const primes \u0026amp;b) const { return val \u0026lt; b.val; } }; std::vector\u0026lt;primes\u0026gt; all; void PF(ll x, int times) { if (x == 1) return; if (MR(x)) { all.push_back({x, times}); return; } ll g = x, t = 0; while (g \u0026gt;= x) g = PR(g); while (x % g == 0) x /= g, t++; PF(g, times * t), PF(x, times); } void find_order(int pos, ll val, ll \u0026amp;ans) { if (pos == (int)all.size()) { if (qpow(p, val, m) == 1) ans = std::min(ans, val); return; } for (int i = 0; i \u0026lt;= all[pos].times; i++) find_order(pos + 1, val, ans), val = val * all[pos].val; } std::map\u0026lt;ll, int\u0026gt; mp; int main() { n = read(), m = read(), p = read(); srand(time(0)); if (m \u0026lt;= 1e7) { BF::solve(); return 0; } std::vector\u0026lt;ll\u0026gt; ans; PF(m, 1); ll q = all[0].val; if (p % q == 0) { for (ll i = 2; i \u0026lt;= m \u0026amp;\u0026amp; ans.size() \u0026lt; n; i++) if (i % q != 0) ans.push_back(i); out_ans(ans); return 0; } all.clear(); ll phi = m - m / q; PF(phi, 1); for (auto k : all) mp[k.val] += k.times; all.clear(); for (auto k : mp) all.push_back({k.first, k.second}); ll order = inf, g; find_order(0, 1, order); if (phi - order \u0026lt; n) { writeln(-1); return 0; } if (q == 2) { if (p % 4 == 1) for (ll i = 3; ans.size() \u0026lt; n; i += 4) ans.push_back(i); else { p = p * p % m; g = 5; for (ll i = 1, now = g; ans.size() \u0026lt; n; i++, now = now * g % m) if (i % (phi / order) != 0) ans.push_back(now); } } else { for (ll i = 2;; i++) { bool flag = 1; for (int j = 0; j \u0026lt; (int)all.size() \u0026amp;\u0026amp; flag; j++) flag \u0026amp;= qpow(i, phi / all[j].val, m) != 1; if (flag) { g = i; break; } } for (ll i = 1, now = g; ans.size() \u0026lt; n; i++, now = now * g % m) if (i % (phi / order) != 0) ans.push_back(now); } out_ans(ans); } ","permalink":"https://luoyisu.github.io/posts/cf-contest1190/","summary":"\u003cp\u003e挺难的，但没有 DP 好评（）\u003c/p\u003e","title":"Codeforces Round 573 (Div. 1\u00262)"},{"content":"还行吧，但我实在太菜了，水题都不会做\nA Description 数轴上 $n$ 个点，求离最近的点的距离恰好为 $d$ 的点的数目。\nSolution 扫一遍，我直接用 set 去重（）\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;set\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 110; long long a[maxn], n, d; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; std::set\u0026lt;long long\u0026gt; S; a[0] = -5e9, a[n + 1] = 5e9; for (int i = 1; i \u0026lt;= n; i++) { int nxt = a[i] + d; if (a[i + 1] - nxt \u0026gt;= d) S.insert(nxt); nxt = a[i] - d; if (nxt - a[i - 1] \u0026gt;= d) S.insert(nxt); } cout \u0026lt;\u0026lt; S.size() \u0026lt;\u0026lt; endl; } B Description 一个长度为 $n$ 的 $01$ 串，给出 $m$ 个区间，每个区间权值是区间里 $1$ 的数目乘 $0$​​ 的数目。输出总权值最大的串。\nSolution 和同近积大，直接 $0$ 和 $1$ 交替输出就行。\nCode n, m = map(int, input().split()) for i in range(n): if i % 2 == 0: print(0, end=\u0026#39;\u0026#39;) else: print(1, end=\u0026#39;\u0026#39;) C Description 给你 $n$ 个数，从每一个数起向后找一个数，这两个数组成一个数对，求一共有多少个数对。（去掉重复的）\nSolution 一个数最优答案肯定在最左面，我们开个桶然后倒着更新答案即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;set\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; int a[maxn], n, b[maxn], ans[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; int sum = 0; for (int i = n; i \u0026gt;= 1; i--) { ans[a[i]] = sum; sum -= b[a[i]]; b[a[i]] = 1, sum++; } long long res = 0; for (int i = 1; i \u0026lt;= 1e5; i++) res += ans[i]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } D Description 定义一种矩阵是菱形矩阵，其大小是 $n\\times m$；满足以下条件：有且只有一个格子的值是 $0$，其他格子的值是到值为 $0$ 的格子的曼哈顿距离。\n给出 $t$​ 个数，问这些数能不能构造出一个菱形矩阵。如果可以，输出其 $n,m$​，以及值为 $0$​​​ 的格子的坐标。\n$t\\leq10^6$。\nSolution 首先发现矩阵是可以旋转的，这肯定不影响。\n如果矩阵无限大，那每个数的数量是 $4\\times n$。\n手玩一下样例可以发现第一个不符合上面要求的数（即出到矩阵外了）一定是值为 $0$​ 的数的横坐标或纵坐标。\n这样我们就确定了 $x$。\n证明不写了，懒，挺显然的。\n我们可以枚举 $n$​，同时也就确定了 $m$​。想一想怎么确定 $y$​——找找奇怪的性质。\n发现最大的数一定在一个角上，那随便算一下就知道 $y=n+m-mx$​，$mx$ 是给出的最大的数。\n发现我们现在时间复杂度还很充裕，且已经知道了 $x,y,n,m$，只需要 check 一下，那怎么 check 呢？当然是暴力了！（）（）（）\n时间复杂度 $O(t)$ 乘上 $t$ 的因数个数，这玩意显然能过。（因为很难跑满）\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e6 + 10; int cnt[maxn], n, t, m, x, y, mx, tot[maxn]; bool check(int n, int m, int x, int y) { for (int i = 0; i \u0026lt;= mx + 5; i++) tot[i] = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) tot[abs(i - x) + abs(j - y)]++; for (int i = 0; i \u0026lt;= mx; i++) if (cnt[i] != tot[i]) return false; return true; } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; for (int i = 0, p; i \u0026lt; t; i++) cin \u0026gt;\u0026gt; p, cnt[p]++, mx = std::max(mx, p); if (cnt[0] != 1) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } for (int i = 1; i \u0026lt;= t; i++) if (cnt[i] != i * 4) { x = i; break; } for (n = 1; n \u0026lt;= t; n++) { if (t % n) continue; m = t / n; y = m + n - x - mx; if (y \u0026gt; 0 \u0026amp;\u0026amp; check(n, m, x, y)) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; return 0; } } cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } E Description 给出一个 $n$ 个结点的带权树和 $k$，找出一条点数不大于 $k$​​ 的路径，使得路径外的点到路径的距离的最大值最小。求这个最小的最大值。$n\\leq10^5$。\nSolution 和树网的核一样。甚至更简单\n树上路径、最小、最大，去想一想直径。\n能证明这条路径一定在任意一条直径上。\n于是对于一条路径分两种情况。到路径距离最大的点可能是直径的两个段点之一，也可能在路径上某个点的子树内。\n对前者直接双指针即可，后者搜一遍就行。\n时间复杂度 $O(n)$​。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; struct edge { int y, w; }; std::vector\u0026lt;edge\u0026gt; e[maxn]; inline void add(int x, int y, int w) { e[x].push_back({y, w}), e[y].push_back({x, w}); } int n, k; int dis[maxn], father[maxn], ind[maxn], dep[maxn]; void dfs(int x, int fa) { father[x] = fa, dep[x] = dep[fa] + 1; for (auto k : e[x]) { if (k.y == fa || ind[k.y]) continue; int v = k.y; dis[v] = dis[x] + k.w; dfs(v, x); } } int find_root() { int res = 0; for (int i = 1; i \u0026lt;= n; i++) if (dis[i] \u0026gt; dis[res]) res = i; return res; } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1, x, w, y; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; w, add(x, y, w); dfs(1, 0); int root = find_root(); dis[root] = 0; dfs(root, 0); root = find_root(); int ans = 1 \u0026lt;\u0026lt; 30; if (n == 1) { puts(\u0026#34;0\u0026#34;); return 0; } for (int i = root, j = root; i; i = father[i]) { while (father[j] \u0026amp;\u0026amp; dep[i] - dep[j] \u0026lt; k - 1) j = father[j]; ans = std::min(ans, std::max(dis[j], dis[root] - dis[i])); } for (int p = root; p; p = father[p]) ind[p] = 1, dis[p] = 0; for (int p = root; p; p = father[p]) dfs(p, father[p]); for (int i = 1; i \u0026lt;= n; i++) ans = std::max(ans, dis[i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } F Description 有一个长度为 $n$​ 的序列，有两种操作。\n操作一：将 $a_i$ 修改为 $y$；\n操作二：给出 $l,r$，求 $[l,r]$ 内有几个子区间内所有数按位或起来的结果大于等于 $X$（$X$ 在题目一开始给出，为定值）。\n$n,m\\leq10^5$。\nSolution 难，我看了题解。\n先考虑如果只有一次询问怎么办。\n能（能吗？）想到一个分治算法：把 $[l,r]$ 的询问拆成 $[l,mid],[mid+1,r]$，求出解，然后合并这两个区间。\n具体怎么得出大区间的解呢？我们联想区间最长连续子段和的做法，求出每个区间的前缀或和后缀或。\n这样我们可以用双指针得到两个区间合并后的解。\n单点修改，区间查询，显然我们需要线段树来维护这个东西。\n那怎么把上面这个做法推广到线段树上呢？好像直接做不太行，我们显然需要看一看或运算的性质。\n一个数或另一个数之后最少只变了 $1$​ 位，且不会变回去，也就是说每个区间前缀/后缀或应该是分成至多 $\\log a_i$​ 段的，我们用 vector 维护这个值，就能做到 $O(\\log a_i)$​ 合并了。\n那我们用线段树维护，把得到的这 $\\log n$​ 个区间依次合并起来就行。\n这时候发现时间复杂度是 $O(m\\log n\\log a_i)$。\n后来我双指针写挂了，一怒之下把双指针换成了暴力合并，复杂度是 $O(m\\log n\\log^2a_i)$​，也能轻松通过。​\n注意位运算的优先级。\nCode 建议把所有函数规划好再写，然后想一些简单的方法来简化代码。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; namespace IO { const int mxsiz = 1 \u0026lt;\u0026lt; 20; char inbuf[mxsiz], *p1, *p2; char outbuf[mxsiz], *op = outbuf; struct endio { endio(){}; ~endio() { fwrite(outbuf, 1, op - outbuf, stdout); } } useless_var; inline char gc() { return p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = inbuf) + fread(inbuf, 1, mxsiz, stdin), p1 == p2) ? EOF : *p1++; } #define isdigit(x) (x \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;9\u0026#39;) // 防止忘记打 \u0026lt;cctype\u0026gt; 头文件 inline int read() { int x = 0, f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x * f; } template \u0026lt;typename T\u0026gt; inline void read(T \u0026amp;x) { x = 0; int f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; x *= f; } #undef isdigit inline bool ischar(char x) { return x \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;z\u0026#39;; } inline char readchar() { char ch = gc(); while (!ischar(ch)) ch = gc(); return ch; } inline void push(char ch) { if (op - outbuf == mxsiz) fwrite(outbuf, 1, mxsiz, stdout), op = outbuf; *op++ = ch; } template \u0026lt;typename T\u0026gt; inline void work_wt(T x) { if (x \u0026gt; 9) work_wt(x / 10); push(x % 10 + \u0026#39;0\u0026#39;); } template \u0026lt;typename T\u0026gt; inline void write(T x) { if (x \u0026lt; 0) x = -x, push(\u0026#39;-\u0026#39;); work_wt(x); } inline void writestr(char *s) { int n = strlen(s); for (int i = 0; i \u0026lt; n; i++) push(s[i]); } inline void endln() { push(\u0026#39;\\n\u0026#39;); } inline void space() { push(\u0026#39; \u0026#39;); } template \u0026lt;typename T\u0026gt; inline void writeln(T x) { write(x), endln(); } } using namespace IO; const int maxn = 1e5 + 10; typedef long long ll; int n, X, m; int a[maxn]; struct seg { int val, len; void p() { write(val), space(), write(len), space(), endln(); } }; struct node { std::vector\u0026lt;seg\u0026gt; l, r; ll ans; void p() { writestr(\u0026#34;l :\\n\u0026#34;); for (auto k : l) k.p(); writestr(\u0026#34;r :\\n\u0026#34;); for (auto k : r) k.p(); writeln(ans); } } t[maxn * 4]; inline int ls(int x) { return x * 2; } inline int rs(int x) { return x * 2 + 1; } node merge(const node \u0026amp;ls, const node \u0026amp;rs) { node k; k.l = ls.l; for (auto p : rs.l) { if ((k.l.back().val | p.val) == k.l.back().val) k.l.back().len += p.len; else k.l.push_back({k.l.back().val | p.val, p.len}); } k.r = rs.r; for (auto p : ls.r) { if ((k.r.back().val | p.val) == k.r.back().val) { k.r.back().len += p.len; } else k.r.push_back({k.r.back().val | p.val, p.len}); } k.ans = ls.ans + rs.ans; // 原先的双指针 /* for (int i = 0, j = (int)rs.l.size() - 1; i \u0026lt; (int)ls.r.size(); i++) { while (j \u0026amp;\u0026amp; ls.r[i].val | rs.l[j].val \u0026gt;= X) j--; if (j \u0026gt;= 0) k.ans += rs.l[j].sum * ls.r[i].len; } */ for (auto i : ls.r) for (auto j : rs.l) if ((i.val | j.val) \u0026gt;= X) k.ans += (ll)i.len * j.len; return k; } void modify(int l, int r, int x, int v, int k) { if (l == r) { t[k].ans = v \u0026gt;= X, t[k].l.clear(), t[k].r.clear(); t[k].l.push_back({v, 1}), t[k].r.push_back({v, 1}); return; } int mid = (l + r) / 2; if (x \u0026lt;= mid) modify(l, mid, x, v, ls(k)); else modify(mid + 1, r, x, v, rs(k)); t[k] = merge(t[ls(k)], t[rs(k)]); } node query(int l, int r, int x, int y, int k) { if (l == x \u0026amp;\u0026amp; r == y) return t[k]; int mid = (l + r) / 2; if (y \u0026lt;= mid) return query(l, mid, x, y, ls(k)); if (x \u0026gt; mid) return query(mid + 1, r, x, y, rs(k)); return merge(query(l, mid, x, mid, ls(k)), query(mid + 1, r, mid + 1, y, rs(k))); } void build(int l, int r, int k) { if (l == r) { t[k].ans = a[l] \u0026gt;= X, t[k].l.clear(), t[k].r.clear(); t[k].l.push_back({a[l], 1}), t[k].r.push_back({a[l], 1}); return; } int mid = (l + r) / 2; build(l, mid, ls(k)); build(mid + 1, r, rs(k)); t[k] = merge(t[ls(k)], t[rs(k)]); } int main() { n = read(), m = read(), X = read(); for (int i = 1; i \u0026lt;= n; i++) a[i] = read(); build(1, n, 1); while (m--) { int opt = read(), x = read(), y = read(); if (opt == 1) modify(1, n, x, y, 1); else writeln(query(1, n, x, y, 1).ans); } } ","permalink":"https://luoyisu.github.io/posts/cf-contest1004/","summary":"\u003cp\u003e还行吧，但我实在太菜了，水题都不会做\u003c/p\u003e","title":"Codeforces Round 495 (Div. 2)"},{"content":"似乎仍然不是很难。\nA Description 有 $n$ 个人，每个人需要 $2$ 张红纸，$5$ 张绿纸，$8$ 张蓝纸。一次可以买 $k$ 张同一种颜色的纸。问最少需要买几次。\nSolution 算一下每种颜色需要几张纸然后除一下向上取整。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; int a = n * 2, b = n * 5, c = n * 8; a = ceil(1.0 * a / k), b = ceil(1.0 * b / k), c = ceil(1.0 * c / k); cout \u0026lt;\u0026lt; a + b + c \u0026lt;\u0026lt; endl; } B Description 有一个序列 $\\{a_i\\}$，通项公式 $a_i=i\\times(-1)^i$，$q$ 个询问，求区间和。\nSolution 找规律即可，规律不写了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; int main() { int q; cin \u0026gt;\u0026gt; q; while (q--) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int len = y - x + 1; if (x == y) cout \u0026lt;\u0026lt; (x \u0026amp; 1 ? -x : x) \u0026lt;\u0026lt; endl; else { int p = len / 2 * (x \u0026amp; 1 ? 1 : -1); if (len \u0026amp; 1) p += y \u0026amp; 1 ? -y : y; cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; } } } C Description 有一个 $n\\times m$ 的国际象棋棋盘（每个格子颜色白或黑），先将一个子矩形染成白色，再将一个子矩形染成黑色，问最后有几个白格子和几个黑格子。$n,m\\leq10^9$。\nSolution 只算黑色格子即可，乱算一算，最后再把重叠部分算进去。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { long long n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; long long x1, x2, y1, y2, x3, y3, x4, y4; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; x3 \u0026gt;\u0026gt; y3 \u0026gt;\u0026gt; x4 \u0026gt;\u0026gt; y4; long long black = n * m / 2; long long dx1 = x2 - x1 + 1, dy1 = y2 - y1 + 1; black -= dx1 * dy1 / 2; if (dx1 * dy1 % 2) if ((x1 + y1) \u0026amp; 1) black--; long long dx2 = x4 - x3 + 1, dy2 = y4 - y3 + 1; black += dx2 * dy2 / 2; if (dx2 * dy2 % 2) if ((x3 + y3) % 2 == 0) black++; long long x5 = std::max(x3, x1), x6 = std::min(x2, x4), y5 = std::max(y1, y3), y6 = std::min(y2, y4); if (x5 \u0026lt;= x6 \u0026amp;\u0026amp; y5 \u0026lt;= y6) { long long dx0 = x6 - x5 + 1, dy0 = y6 - y5 + 1; black += dx0 * dy0 / 2; if (dx0 * dy0 % 2) { if ((x5 + y5) % 2) { black++; } } } long long white = n * m - black; cout \u0026lt;\u0026lt; white \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; black \u0026lt;\u0026lt; endl; } } D Description 有一个 $2^n\\times2^n$ 的正方形，进行 $k$ 次切割操作，每次把一个正方形切成 $4$ 个等大的小正方形。\n需要找到一条在切割后正方形边长全部相同且四连通的从左下角到右上角的路径，判断能不能找到，如果能找到，输出这条路径上正方形边长以 $2$​ 为底的对数。\n$n\\leq10^9,k\\leq10^{18}$。\nSolution 能算出来把一个 $2^n\\times 2^n$ 的正方形切成最小的切割次数 $a_n$ 满足递推式 $a_n=4\\times a_{n-1}+1$​。\n显然我们只需要打通一条路就行，其他的随便切。\n那么当 $n\u0026gt;31$，肯定无解。\n我们可以枚举这条路径上正方形边长，设边长为 $2^i$，那么我们只需要找到可以的最小切割次数和最大切割次数，如果 $k$ 在这两个数的闭区间里，那么一定有解。\n最小切割次数怎么算呢？我们只切最边上的路径，第一次切 $1$ 次，第二次切 $3$ 次，第三次切 $7$ 次……，所以最小切割次数 $mi_i=\\sum_{j=1}^{n-i}mi_j$。\n最大切割次数怎么算呢？我们先切成最小的方块，然后减去多切的。最多切割次数 $f_i=a_n-a_i\\times(2^{n-i+1}-1)$。\n就这样。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; typedef long long ll; ll a[40], mi[40], mx[40]; int solve(int n, ll k) { for (int i = 0; i \u0026lt; n; i++) { if (a[n] - a[i] * ((1ll \u0026lt;\u0026lt; (n - i + 1)) - 1) \u0026gt;= k \u0026amp;\u0026amp; mi[n - i - 1] \u0026lt;= k) return i; } return -1; } int main() { int T; cin \u0026gt;\u0026gt; T; for (int i = 1; i \u0026lt;= 31; i++) a[i] = 4 * a[i - 1] + 1; for (int i = 0; i \u0026lt;= 31; i++) mi[i] = (1ll \u0026lt;\u0026lt; (i + 1)) - 1 + mi[i - 1]; while (T--) { long long n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; if (n \u0026gt; 31) { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n - 1 \u0026lt;\u0026lt; endl; continue; } if (k \u0026gt; a[n]) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; continue; } int ans = solve(n, k); if (ans == -1) cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } E Description $n\\times m$ 的字符矩阵，求满足一下条件子矩形个数：将每一行重新排列后满足每一行和每一列都是回文串。$n\\leq250$。\nSolution 每一行的要求可以很好判断，因为可以随便重排，满足至多只有一个字符出现两次即可。然后把每一行当成一个字符做 manacher，就行了。复杂度 $O(nm^2|\\sum|)$​​，能过。如果比较每一行用 hash 来判断，那就可以优化到 $O(nm^2)$​​。\nshr 神说可以用组合数暴力算，我不懂，他 tql。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 510; char s[maxn][maxn]; int n, m, cnt[maxn][30], odd[maxn], d[maxn]; long long ans = 0; inline bool cmp(int a, int b) { if (odd[a] \u0026gt; 1 || odd[b] \u0026gt; 1) return false; for (int i = 0; i \u0026lt; 26; i++) if (cnt[a][i] != cnt[b][i]) return false; return true; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%s\u0026#34;, s[i] + 1); for (int l = 1; l \u0026lt;= m; l++) { memset(cnt, 0, sizeof(cnt)), memset(odd, 0, sizeof(odd)); for (int r = l; r \u0026lt;= m; r++) { for (int i = 1; i \u0026lt;= n; i++) { char ch = s[i][r] - \u0026#39;a\u0026#39;; cnt[2 * i - 1][ch]++; if (cnt[2 * i - 1][ch] \u0026amp; 1) odd[2 * i - 1]++; else odd[2 * i - 1]--; } memset(d, 0, sizeof(d)); cnt[2 * n + 1][0] = -1; for (int i = 1, l = 0, r = 0; i \u0026lt;= 2 * n; i++) { if (odd[i] \u0026gt; 1) continue; if (i \u0026lt;= r) d[i] = std::min(r - i + 1, d[l + r - i]); while (cmp(i - d[i], i + d[i])) d[i]++; if (i + d[i] \u0026gt;= r) r = i + d[i] - 1, l = i - d[i] + 1; ans += d[i] / 2; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } F Description 有 $n$ 个集合，$k$ 条线段，每条线段由 $l,r,p$ 描述，分别表示其左端点，右端点，所在集合。\n$m$ 个询问，每次给出 $a,b,x,y$，问编号在 $[a,b]$ 之间所有的集合是否都存在一条满足 $x\\leq l\\leq r\\leq y$ 的线段。\n$n,m\\leq10^5$，$k\\leq3\\times10^5$，强制在线。\nSolution 看到强制在线，像是能用线段树维护的信息，我们想到主席树（）（）（）\n以上扯淡，分析一下，如果直接存线段的信息会发现集合信息很难维护。\n我们考虑存集合并转化一下要求的东西。\n如果一个集合满足要求，那么它左端点大于等于 $l$ 的线段中右端点最小值必定小于等于 $y$。\n如果多个集合呢？就是这些集合上面这个东西的最大值小于等于 $y$。\n那么我们线段树里维护的东西就确定了：叶子中是这个集合中 $r$ 的最小值，非叶子结点是它所管辖区间中上述值的最大值。\n那么怎么满足线段树中只有左端点大于等于 $l$ 的线段呢？我们用一棵主席树，把线段按照 $l$ 从大到小插入进去就行了。\nCode #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::cerr; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; const int maxk = 3e5 + 10; int root[maxk], n, m, k, inf = 1 \u0026lt;\u0026lt; 30; struct Tree { static const int maxn = ::maxn \u0026lt;\u0026lt; 6; int ls[maxn], rs[maxn], tot, mx[maxn]; Tree() { for (int i = 0; i \u0026lt; maxn; i++) mx[i] = inf; } int clone(int k) { tot++; mx[tot] = mx[k], ls[tot] = ls[k], rs[tot] = rs[k]; return tot; } inline void push_up(int k) { mx[k] = std::max(mx[ls[k]], mx[rs[k]]); } int build(int l, int r, int k) { if (!k) k = ++tot, mx[tot] = inf; if (l == r) { mx[k] = inf; return k; } int mid = (l + r) / 2; ls[k] = build(l, mid, ls[k]), rs[k] = build(mid + 1, r, rs[k]); push_up(k); return k; } int modify(int l, int r, int x, int y, int k) { k = clone(k); if (l == r) { mx[k] = std::min(mx[k], y); return k; } int mid = (l + r) / 2; if (x \u0026lt;= mid) ls[k] = modify(l, mid, x, y, ls[k]); else rs[k] = modify(mid + 1, r, x, y, rs[k]); push_up(k); return k; } int query(int l, int r, int x, int y, int k) { if (x \u0026lt;= l \u0026amp;\u0026amp; y \u0026gt;= r) return mx[k]; int res = 0, mid = (l + r) / 2; if (x \u0026lt;= mid) res = std::max(res, query(l, mid, x, y, ls[k])); if (y \u0026gt; mid) res = std::max(res, query(mid + 1, r, x, y, rs[k])); return res; } } t; struct Segment { int l, r, p; bool operator\u0026lt;(const Segment \u0026amp;b) const { return l \u0026gt; b.l; } } a[maxk]; int tot; int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= k; i++) scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a[i].l, \u0026amp;a[i].r, \u0026amp;a[i].p); std::sort(a + 1, a + 1 + k); root[0] = t.build(1, n, root[0]); for (int i = 1; i \u0026lt;= k; i++) root[i] = t.modify(1, n, a[i].p, a[i].r, root[i - 1]); while (m--) { int p, q, x, y; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;p, \u0026amp;q, \u0026amp;x, \u0026amp;y); int pos = std::upper_bound(a + 1, a + 1 + k, (Segment){x, 0, 0}) - a - 1; int ans = t.query(1, n, p, q, root[pos]); puts(ans \u0026lt;= y ? \u0026#34;yes\u0026#34; : \u0026#34;no\u0026#34;); fflush(stdout); } } ","permalink":"https://luoyisu.github.io/posts/cf-contest1080/","summary":"\u003cp\u003e似乎仍然不是很难。\u003c/p\u003e","title":"Codeforces Round 524 (Div. 2)"},{"content":"似乎不是很难，但似乎又很难。\nA Description 有两个数 $n,k$，在 $1\\sim n$ 中选择最多的数使得不存在两个和为 $k$ 的数。\nSolution 显然比 $k$ 大的数全都要选，显然 $k$ 不能选，显然比 $k$ 小的数只能选一半。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::endl; using std::cout; int T, n, k; int main() { cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; int ans = n - k + k / 2; if (ans \u0026lt;= 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; continue; } cout \u0026lt;\u0026lt; n - k + k / 2 \u0026lt;\u0026lt; endl; for (int i = n; i \u0026gt; k; i--) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (int i = k - 1; i \u0026gt;= (k - 1) / 2 + 1; i--) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } } B Description 有一个每天有 $h$ 个小时，每个小时有 $m$ 分钟的星球，给出一个时间，求下一个能在镜子中照出合法时间的时间。\nSolution 只有 $0,1,2,5,8$ 组成的时间是合法的，预处理一下然后模拟。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cout; using std::cin; using std::endl; const int maxn = 10010; const int number[] = {0, 1, 2, 5, 8}; bool ok[maxn]; int n, m, x[10]; inline int hash(int a, int b, int c, int d) { return a * 1000 + b * 100 + c * 10 + d; } void init() { for (int a = 0; a \u0026lt; 5; a++) for (int b = 0; b \u0026lt; 5; b++) for (int c = 0; c \u0026lt; 5; c++) for (int d = 0; d \u0026lt; 5; d++) ok[hash(number[a], number[b], number[c], number[d])] = 1; x[0] = 0, x[1] = 1, x[2] = 5, x[5] = 2, x[8] = 8; } inline int hash2(int a, int b) { return a * 100 + b; } inline bool check(int a, int b) { if (!ok[hash2(a, b)]) return false; int p = x[a % 10] * 10 + x[a / 10], q = x[b % 10] * 10 + x[b / 10]; return p \u0026lt; m \u0026amp;\u0026amp; q \u0026lt; n; } void work(int a, int b) { while (1) { if (check(a, b)) { printf(\u0026#34;%02d:%02d\\n\u0026#34;, a, b); return; } b++; if (b == m) b = 0, a++; if (a == n) a = 0; } } int main() { int T; cin \u0026gt;\u0026gt; T; init(); char ch; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; ch \u0026gt;\u0026gt; b; work(a, b); } } C Description 有一个长度为 $n$ 只含小写字母的字符串和一个数 $k$。求一个字符串，满足这个字符串字典序比原字符串大且每个字符出现的次数都能被 $k$​​ 整除，要求满足以上要求的字典序最小的字符串。$n\\leq1000$。\nSolution 发现和原字符串前缀相同的位数越多字典序就可能越小，于是从大到小枚举从哪一位开始不一样，然后枚举这一位填什么字符，看剩下的位置能不能满足要求。\n具体判断能不能满足要求需要看把所有字符都填到恰好被 $k$ 整除需要几个，然后看这些的和是否不大于剩下的位数。\n填的时候先把能随便填的都填上 a，剩下的地方从 a 到 z 依次填就行。\n建议想好再写。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cout; using std::cin; using std::endl; const int maxn = 1e5 + 10; char s[maxn]; int T, n, k; int b[30]; void output(int x, int y) { s[x] = y + \u0026#39;a\u0026#39;; for (int i = 1; i \u0026lt;= x; i++) cout \u0026lt;\u0026lt; s[i]; int res = n - x; for (int i = 0; i \u0026lt; 26; i++) res -= (k - b[i] % k) % k; for (int i = 0; i \u0026lt; res; i++) cout \u0026lt;\u0026lt; \u0026#39;a\u0026#39;; for (int i = 0; i \u0026lt; 26; i++) { b[i] %= k; for (int j = 0; j \u0026lt; (k - b[i] % k) % k; j++) cout \u0026lt;\u0026lt; char(i + \u0026#39;a\u0026#39;); } cout \u0026lt;\u0026lt; endl; } void solve() { int sum = 0; for (int i = n; i \u0026gt;= 1; i--) { b[s[i] - \u0026#39;a\u0026#39;]--; for (int j = s[i] + 1 - \u0026#39;a\u0026#39;; j \u0026lt; 26; j++) { b[j]++; sum = 0; for (int p = 0; p \u0026lt; 26; p++) sum += (k - b[p] % k) % k; if (sum \u0026lt;= n - i) { output(i, j); return; } b[j]--; } } } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; T; while (T--) { memset(b, 0, sizeof(b)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; (s + 1); for (int i = 1; i \u0026lt;= n; i++) b[s[i] - \u0026#39;a\u0026#39;]++; int ok = 1; for (int i = 0; i \u0026lt; 26; i++) if (b[i] % k) { ok = 0; break; } if (ok) { cout \u0026lt;\u0026lt; (s + 1) \u0026lt;\u0026lt; endl; continue; } else if (n % k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } solve(); } } D Description 有一个 $n$ 个数的正整数序列，$q$ 次操作，每次把一个数乘上 $x$，问每次操作后整个序列的 gcd 对 $10^9+7$ 取模的结果。\nSolution 我们只需要求出所有质因子最低次数的幂即可。\n对每个质因子维护一个 multiset，乘的时候把这个数增加的质因子加进去就行。\n然后把答案乘一个 $p^x$ 即可，其中 $x$​​ 是增加的幂次。\n乱维护即可。。。\n注意质因数分解需要做到 $O(\\log n)$，为此需要预处理每个数最小质因子。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; const int maxn = 2e5 + 10, mod = 1e9 + 7; const int maxp = 18000; typedef long long ll; namespace IO { const int mxsiz = 1 \u0026lt;\u0026lt; 20; char inbuf[mxsiz], *p1, *p2; char outbuf[mxsiz], *op = outbuf; struct endio { endio(){}; ~endio() { fwrite(outbuf, 1, op - outbuf, stdout); } } useless_var; inline char gc() { return p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = inbuf) + fread(inbuf, 1, mxsiz, stdin), p1 == p2) ? EOF : *p1++; } #define isdigit(x) (x \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;9\u0026#39;) inline int read() { int x = 0, f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x * f; } template \u0026lt;typename T\u0026gt; inline void read(T \u0026amp;x) { x = 0; int f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; x *= f; } #undef isdigit inline bool ischar(char x) { return x \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;z\u0026#39;; } inline char readchar() { char ch = gc(); while (!ischar(ch)) ch = gc(); return ch; } inline void push(char ch) { if (op - outbuf == mxsiz) fwrite(outbuf, 1, mxsiz, stdout), op = outbuf; *op++ = ch; } template \u0026lt;typename T\u0026gt; inline void work_wt(T x) { if (x \u0026gt; 9) work_wt(x / 10); push(x % 10 + \u0026#39;0\u0026#39;); } template \u0026lt;typename T\u0026gt; inline void write(T x) { if (x \u0026lt; 0) x = -x, push(\u0026#39;-\u0026#39;); work_wt(x); } inline void writestr(char *s) { int n = strlen(s); for (int i = 0; i \u0026lt; n; i++) push(s[i]); } inline void endln() { push(\u0026#39;\\n\u0026#39;); } inline void space() { push(\u0026#39; \u0026#39;); } template \u0026lt;typename T\u0026gt; inline void writeln(T x) { write(x), endln(); } } using namespace IO; int vis[maxn], p[maxp], tot, n, mi[maxn], q; std::multiset\u0026lt;int\u0026gt; S[maxp]; std::map\u0026lt;int, int\u0026gt; mp[maxn], P; ll ans = 1; void init(int n) { mi[1] = 2; for (int i = 2; i \u0026lt;= n; i++) { if (!vis[i]) p[++tot] = i, P[i] = tot, mi[i] = i; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; p[j] * i \u0026lt;= n; j++) { vis[i * p[j]] = 1, mi[i * p[j]] = p[j]; if (i % p[j] == 0) break; } } } ll qpow(ll a, int x) { ll res = 1; for (; x; x \u0026gt;\u0026gt;= 1, a = a * a % mod) if (x \u0026amp; 1) res = res * a % mod; return res; } void modify(int x, int pos) { if (x == 1) return; while (x \u0026gt; 1) { int i; i = P[mi[x]]; int cnt = 0; while (x % p[i] == 0) x /= p[i], cnt++; if (cnt == 0) continue; auto lst = *S[i].begin(); int flag = S[i].size() == n - 1; if (mp[pos][i] != 0) S[i].erase(S[i].find(mp[pos][i])), S[i].insert(cnt + mp[pos][i]); else S[i].insert(cnt); mp[pos][i] += cnt; if (S[i].size() \u0026lt; n) continue; else ans = ans * qpow(p[i], flag ? *S[i].begin() : *S[i].begin() - lst) % mod; } } signed main() { init(2e5); n = read(), q = read(); int x; for (int i = 1; i \u0026lt;= n; i++) { x = read(); modify(x, i); } while (q--) { int x, i; i = read(), x = read(); modify(x, i); writeln(ans); } } E Description 给定两个位数为 $n$ 的二进制数 $a,b$。$g(x,y)$ 为 $[x,y]$ 所有数异或起来的结果，$f(l,r)$ 为所有满足 $l\\leq x\\leq y\\leq r$ 中 $g(x,y)$ 的最大值，求 $f(a,b)$。$n\\leq10^6$​。\nSolution 不会？打表！\n发现当 $a,b$​ 位数不同时，答案是 $2^n-1$​。\n否则当 $a=b$ 或 $b=a+1$ 或 $b$ 是奇数时，答案是 $b$。\n否则答案是 $b+1$。\n证明？不会！\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; using std::cin; using std::endl; using std::cout; using std::cerr; std::string a, b; std::string add(std::string x) { int n = x.size(); std::string res = x; int pos = n - 1; for (; pos \u0026gt;= 0; pos--) if (res[pos] == \u0026#39;1\u0026#39;) { res[pos] = \u0026#39;0\u0026#39;; } else break; res[pos] = \u0026#39;1\u0026#39;; return res; } int main() { int n; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if (a[0] != b[0]) { for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; 1; cout \u0026lt;\u0026lt; endl; return 0; } if (a == b || add(a) == b || b.back() == \u0026#39;1\u0026#39;) cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; add(b) \u0026lt;\u0026lt; endl; } F Description 这是一道交互题。\n有一个 $n\\times m$ 的矩阵，里面是正整数。（$n,m$ 给出）。\n你可以询问两个长为 $w$，宽为 $h$ 的矩形是否完全相等。要求这两个矩形不能重叠也不能越界。\n你需要求出所有 $(x,y)$ 的数目，满足整个矩形能用 $(1,1)-(x,y)$ 的子矩阵完全平铺出来。\n询问次数最多 $3\\times\\log(n+m)$。\nSolution 很显然可以对行和列分别求解，然后把答案乘起来。\n实际上，我们只需要求出最小循环节——枚举 $n$​ 的质因子，然后试一下它的最小质因子行不行，如果可以就除以这个最小质因子然后接着算直到 $n=1$。算完最小循环节之后就能知道最多能分成几段，那么这个段数的所有因数都是合法的。\n也就是说我们需要在 $3$ 次询问以内判断一个串是否能被分成完全相同的若干个串。\n我们把每个完全相同的串看成一个字符，问题就转化为询问一个字符串所有字符是否都相等。\n设这个字符串长度为 $L$，当 $L=2$，直接问就行。\n否则串长度一定为奇数（因为是质数）我们询问 $([1,\\left\\lfloor\\dfrac{L}{2}\\right\\rfloor],[\\left\\lceil\\dfrac{L}{2}\\right\\rceil,L-1])$，再询问 $([1,\\left\\lfloor\\dfrac{L}{2}\\right\\rfloor],[\\left\\lceil\\dfrac{L}{2}\\right\\rceil+1,L])$，如果两个都完全相等，那么这个串里的字符都相等（自己想想就懂了）。\n于是就结束了。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1010; int n, m; int p[maxn * 2], vis[maxn * 2], tot, mi[maxn * 2]; int ansn, ansm; void init(int n = 2000) { mi[1] = 2; for (int i = 2; i \u0026lt;= n; i++) { if (!vis[i]) p[++tot] = i, mi[i] = i; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; p[j] * i \u0026lt;= n; j++) { vis[i * p[j]] = 1, mi[i * p[j]] = p[j]; if (i % p[j] == 0) break; } } std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; ::n \u0026gt;\u0026gt; m; } bool ask(int l, int r, int len, bool d) { if (d == 0) cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; len \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; len \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; int res; cin \u0026gt;\u0026gt; res; return res == 1 ? true : false; } bool queryn(int L, int len) { if (L == 2) return ask(1, len + 1, len, 1); int mid = L / 2 * len; return ask(1, mid + 1, mid, 1) \u0026amp;\u0026amp; ask(1, mid + 1 + len, mid, 1); } bool querym(int L, int len) { if (L == 2) return ask(1, len + 1, len, 0); int mid = L / 2 * len; return ask(1, mid + 1, mid, 0) \u0026amp;\u0026amp; ask(1, mid + 1 + len, mid, 0); } int work1() { int res = n; for (int i = n; i \u0026gt; 1; i /= mi[i]) if (queryn(mi[i], res / mi[i])) res /= mi[i]; int times = n / res; int ans = 0; for (int i = 1; i \u0026lt;= times; i++) if (times % i == 0) ans++; return ans; } int work2() { int res = m; for (int i = m; i \u0026gt; 1; i /= mi[i]) if (querym(mi[i], res / mi[i])) res /= mi[i]; int times = m / res; int ans = 0; for (int i = 1; i \u0026lt;= times; i++) if (times % i == 0) ans++; return ans; } int main() { init(); int ans = work1() * work2(); cout \u0026lt;\u0026lt; \u0026#34;! \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","permalink":"https://luoyisu.github.io/posts/cf-contest1493/","summary":"\u003cp\u003e似乎不是很难，但似乎又很难。\u003c/p\u003e","title":"Codeforces Round 705 (Div. 2)"},{"content":"还算良心的比赛。\nA Description 有两个序列 $a,b$​，定义 $f(x,l,r)$​ 为 $x$​ 序列中 $[l,r]$​ 的数或起来的结果，求所有 $l,r$​ 中，$f(a,l,r)+f(b,l,r)$​ 的最大值。\nSolution 发现或起来之后数不会变小，那直接全或起来就行。\nCode n = int(input()) a = map(int, input().split()) b = map(int, input().split()) x = 0; y = 0 for i in a: x |= i for i in b: y |= i print(x + y) B Description 有一个 $n\\times m$​ 的矩阵，$k$​ 次操作，每次可以把一行或一列涂成一个颜色，求最后的矩阵。$n\\times m,k\\leq10^5,n\\leq5000,m\\leq5000$​。\nSolution 对于每个行和列直接维护最后一次修改是什么颜色和这次修改的时间即可，最后直接找时间更晚的颜色输出。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 5010; int col[maxn], row[maxn], tc[maxn], tr[maxn]; int main() { std::ios::sync_with_stdio(false); int n, m, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) { int opt, x, c; cin \u0026gt;\u0026gt; opt \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; if (opt == 1) row[x] = c, tr[x] = i; else col[x] = c, tc[x] = i; } for (int i = 1; i \u0026lt;= n; i++, cout \u0026lt;\u0026lt; endl) for (int j = 1; j \u0026lt;= m; j++) cout \u0026lt;\u0026lt; (tr[i] \u0026gt; tc[j] ? row[i] : col[j]) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } C Description 有一个长度为 $n$ 序列 $\\{a_i\\}$，有 $m$​ 个人依次进行一次操作，每次操作会把序列的一个前缀升序或降序排序，求最后得到的序列。$n\\leq2\\times10^5$\nSolution 注意到如果上一次操作的区间比这一次小，那么上一次操作没有意义，因此我们只需要找到单调递减的一组操作：用单调栈维护。\n维护一个从后到前的答案栈。\n然后把原序列排个序，升序排序就是把剩下的不会被下一次操作影响的数从大到小压进栈里，降序排序就是从小到大。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2e5 + 10; int top = 0; int a[maxn], n, m; struct opt { int i, t; opt() { i = t = 0; } opt(int i_, int t_) { i = i_, t = t_; } } p[maxn]; std::stack\u0026lt;int\u0026gt; stk; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= m; i++) { int x, pos; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; pos; while (top \u0026amp;\u0026amp; pos \u0026gt;= p[top].i) top--; p[++top] = (opt){pos, x}; } int r = n; while (r \u0026gt; p[1].i) stk.push(a[r--]); std::sort(a + 1, a + 1 + p[1].i); int lpos = 1, rpos = p[1].i; int res = 0; for (int i = 1; i \u0026lt;= top; i++) { int d = p[i].i - (i == top ? 0 : p[i + 1].i); if (p[i].t == 1) for (int j = 0; j \u0026lt; d; j++) stk.push(a[rpos--]); else for (int j = 0; j \u0026lt; d; j++) stk.push(a[lpos++]); } while (!stk.empty()) cout \u0026lt;\u0026lt; stk.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;, stk.pop(); cout \u0026lt;\u0026lt; endl; } D Description 定义一个字符串压缩后得到的字符串是把连续相同的字符用数字+字符的形式表示。\n给出两个压缩后的字符串 A、B（长度分别为 $n$，$m$），求 B 在 A 中出现了几次。\n$n,m\\leq2\\times10^5$​。\nSolution 这显然是个 KMP，我们把 B 去除掉第一位和最后一位和 A 匹配，然后看一下第一位和最后一位是否也能匹配即可，特判一下 $m\u0026lt;3$ 的情况。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2e5 + 10; struct node { char ch; long long len; bool operator==(const node \u0026amp;b) const { return ch == b.ch \u0026amp;\u0026amp; len == b.len; } bool operator!=(const node \u0026amp;b) const { return !(*this == b); } void print() { cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; } } a[maxn], b[maxn]; char s[20]; int n, m, tota, totb; long long ans; void solve1() { for (int i = 1; i \u0026lt;= n; i++) if (a[i].ch == b[1].ch \u0026amp;\u0026amp; a[i].len \u0026gt;= b[1].len) ans += a[i].len - b[1].len + 1; } void solve2() { for (int i = 1; i \u0026lt; n; i++) if (a[i].ch == b[1].ch \u0026amp;\u0026amp; a[i + 1].ch == b[2].ch \u0026amp;\u0026amp; a[i].len \u0026gt;= b[1].len \u0026amp;\u0026amp; a[i + 1].len \u0026gt;= b[2].len) ans++; } int nxt[maxn]; node tmpb[maxn]; int tmpm; void get_nxt() { for (int i = 2; i \u0026lt; m; i++) tmpb[i - 1] = b[i]; tmpm = m - 2; for (int i = 2, j = 0; i \u0026lt;= tmpm; i++) { while (j \u0026amp;\u0026amp; tmpb[i] != tmpb[j + 1]) j = nxt[j]; if (tmpb[i] == tmpb[j + 1]) j++; nxt[i] = j; } } void solve() { get_nxt(); for (int i = 2, j = 0; i \u0026lt; n; i++) { while (j \u0026amp;\u0026amp; a[i] != tmpb[j + 1]) j = nxt[j]; if (a[i] == tmpb[j + 1]) j++; if (j == tmpm) { int pos = i - tmpm + 1; if (a[pos - 1].ch == b[1].ch \u0026amp;\u0026amp; a[pos - 1].len \u0026gt;= b[1].len \u0026amp;\u0026amp; a[pos + m - 2].ch == b[m].ch \u0026amp;\u0026amp; a[pos + m - 2].len \u0026gt;= b[m].len) ans++; j = nxt[j]; } } } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; a[0].ch = b[0].ch = \u0026#39;#\u0026#39;, a[0].len = b[0].len = 1; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; s; int len = strlen(s), x = 0; for (int i = 0; i \u0026lt; len - 2; i++) x = x * 10 + s[i] - \u0026#39;0\u0026#39;; if (s[len - 1] == a[tota].ch) a[tota].len += x; else a[++tota] = {s[len - 1], x}; } for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; s; int len = strlen(s), x = 0; for (int i = 0; i \u0026lt; len - 2; i++) x = x * 10 + s[i] - \u0026#39;0\u0026#39;; if (s[len - 1] == b[totb].ch) b[totb].len += x; else b[++totb] = {s[len - 1], x}; } n = tota, m = totb; if (m == 1) solve1(); else if (m == 2) solve2(); else solve(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } E Description 给出一个长度为 $n$​ 的序列 $\\{a_i\\}$​，定义它的权值是 $\\sum\\limits_{i=1}^ni\\times a_i$​，你可以将序列中一个数移动一次，求能得到的最大的权值。$n\\leq2\\times10^5$。​\nSolution 我们只需要最大化操作后增加的权值即可。\n设 $f_i$​ 表示把第 $i$​ 个数移动后能得到的最大权值增加量，$sum_i$​ 为序列的前缀和。\n$f_i=\\max\\limits_0^n\\{(j-i)\\times a_i+sum_i-sum_j\\}$，直接枚举 $j$​，是 $O(n^2)$。\n发现这是个斜率优化的形式。\n$sum_j=j\\times a_i+(sum_i-i\\times a_i-f_i)$。\n那么 $y=sum_j,x=j,k=a_i,b=sum_i-i\\times a_i-f_i$​。\n我们要最小化截距，维护一个下凸包即可。\n这个题一开始所有的 $j$​ 都是可以用的，于是我们的下凸包是固定的，用单调栈维护。\n斜率没有单调性，我们直接在单调栈上二分即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cout; using std::cin; using std::endl; const int maxn = 2e5 + 10; typedef long long ll; int a[maxn], n; ll sum[maxn]; struct node { ll x, y; node() { x = y = 0; } node(ll x_, ll y_) { x = x_, y = y_; } } p[maxn]; int top = 0; inline double slope(const node \u0026amp;x, const node \u0026amp;y) { return (double)(double(y.y - x.y)) / (double(y.x - x.x)); } node solve(ll x) { int l = 2, r = top, ans = 1; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (slope(p[mid - 1], p[mid]) \u0026lt;= double(x)) ans = mid, l = mid + 1; else r = mid - 1; } return p[ans]; } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; ll res = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], sum[i] = sum[i - 1] + a[i], res += 1ll * a[i] * i; top = 1; for (int i = 1; i \u0026lt;= n; i++) { node now(i, sum[i]); while (top \u0026gt; 1 \u0026amp;\u0026amp; slope(p[top - 1], p[top]) \u0026gt;= slope(p[top], now)) top--; p[++top] = now; } ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { auto now = solve(a[i]); ans = std::max(ans, -now.y + now.x * a[i] - 1ll * i * a[i] + sum[i]); } cout \u0026lt;\u0026lt; res + ans \u0026lt;\u0026lt; endl; } ","permalink":"https://luoyisu.github.io/posts/cf-contest631/","summary":"\u003cp\u003e还算良心的比赛。\u003c/p\u003e","title":"Codeforces Round 344 (Div. 2)"},{"content":"好像又是没有数据结构和数学题的一天。\nA Description 有 A、B 两个人要竞选，有 $n$ 个人，每个人有 $k$ 票，其中给 B 投 $a_i$​ 票，剩下的投 A。问要使 A 的票数大于 B，$k$ 最小是多少。\nSolution $$ nk-\\sum a_i\u0026gt;\\sum a_i\\Rightarrow k\u0026gt;\\frac{2\\times\\sum a_i}{n} $$\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; int read() { int x; cin \u0026gt;\u0026gt; x; return x; } const double eps = 1e-8; int main() { int n, sum = 0, mx = 0; cin \u0026gt;\u0026gt; n; for (int i = 1, x; i \u0026lt;= n; i++) x = read(), sum += x, mx = std::max(mx, x); int ans = 2 * sum / n + 1; cout \u0026lt;\u0026lt; std::max(ans, mx) \u0026lt;\u0026lt; endl; } B Description 有一个长度为 $n$ 序列 $\\{a_i\\}$，求满足以下条件的序列 $\\{x_i\\}$ 的数目：$a_i=x_{(i-1)\\ \\bmod\\ k}+a_{i-1}$。其中 $k$ 是序列 $\\{x_i\\}$ 的长度。\nSolution 发现如果没有取模的限制，要求的就是差分数组，有了这个限制也就是说要找到他的循环节，那么构建一下 KMP 中的 $next$ 数组跳一跳就行。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; int read() { int x; cin \u0026gt;\u0026gt; x; return x; } const int maxn = 1010; int nxt[maxn], a[maxn], b[maxn], n; std::vector\u0026lt;int\u0026gt; ans; void get_nxt() { for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026amp;\u0026amp; b[i] != b[j]) j = nxt[j]; if (b[i] == b[j]) j++; nxt[i + 1] = j; } } void solve() { int now = n; while (now) { ans.push_back(n - nxt[now]); now = nxt[now]; } cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; for (int i : ans) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 0; i \u0026lt; n; i++) b[i] = a[i + 1] - a[i]; get_nxt(); solve(); } C Description 有一个只有 a 和 b 的字符串，从前往后扫一遍，在每一位你可以选择将其前缀翻转，问如何操作得到字符串字典序最小。\nSolution 假如我们得到了当前这一位之前的操作方案，且这一位是 a，我们显然需要把这个 a 翻转到前面去。那么我们把前一位翻转一下，再把这一位翻转一下即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; int read() { int x; cin \u0026gt;\u0026gt; x; return x; } const int maxn = 1010; char s[maxn]; int ans[maxn]; int main() { cin \u0026gt;\u0026gt; s; int n = strlen(s); for (int i = 1; i \u0026lt; n; i++) if (s[i] == \u0026#39;a\u0026#39;) ans[i] ^= 1, ans[i - 1] ^= 1; for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } D Description 有 $m$ 个长度为 $n$ 的 $1\\sim n$​ 的排列。你可以对一个排列删除任意长度的前缀或后缀（可以不删或只删前缀或只删后缀），但不能删空。最终使得到的排列全都相同，求删除的方案数。$m\\leq10,n\\leq10^5$​​。\nSolution 对于第一个排列中的一个子序列，发现它合法等价于其他所有排列中也存在这个子序列，那么我们只需要考虑第一个排列中的所有合法子序列长度即可。\n对于一个长度为 $n$ 的合法子序列，他对答案的贡献是 $n+\\dfrac{(n\\times(n-1))}{2}=\\dfrac{n\\times(n+1)}{2}$​​，即任意选一个或任意选两个。\n求所有子序列的长度可以用类似双指针的算法实现。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;utility\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; namespace IO { // 为了简短代码省略了 } using namespace IO; const int maxn = 1e5 + 10, maxm = 15; int b[maxm][maxn]; int a[maxm][maxn]; int n, m; long long len[maxn]; bool check(int x, int y) { for (int i = 2; i \u0026lt;= m; i++) if (a[i][b[i][x] + 1] != y) return false; return true; } int main() { n = read(), m = read(); for (int i = 1; i \u0026lt;= m; i++) for (int j = 1; j \u0026lt;= n; j++) a[i][j] = read(), b[i][a[i][j]] = j; int l = 1, r = 1; for (; l \u0026lt;= n; l = r) { len[l] = 1; r++; while (r \u0026lt;= n \u0026amp;\u0026amp; check(a[1][r - 1], a[1][r])) r++, len[l]++; } long long ans = 0; for (int i = 1; i \u0026lt;= n; i++) ans += 1ll * len[i] * (len[i] + 1) / 2; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } E Description 有 $n$​ 个人，给出 $m$​ 组互相不喜欢的人，每个人与他喜欢的人都要组队一次，组队之后要挑战两个任务 A、B，每个人对 A、B 有一个不擅长程度 $x_i,y_i$​​​​​，组队时每人挑战其中一个任务，一次组队的不擅长程度是做两个任务的人对应的不擅长程度之和，并希望最小化这次组队的不擅长程度。\n需要求出每个人所有组队的不擅长程度之和。\n$n\\leq3\\times10^5,m\\leq3\\times10^5$​。​\n（建议参考原题面和样例三，我尽力讲明白了）\nSolution 对于每次组队 $(x,y)$，不擅长程度是 $\\min(x_i+y_j,x_j+y_i)$，也就是说每次组队的和只有两种，且选哪种是很确定的，我们考虑一个贪心。\n选 $x_i+y_j$​​ 当且仅当 $x_i+y_j\u0026lt;x_j+y_i\\Leftrightarrow x_i-y_i\u0026lt;x_j-y_j$​​，那么我们按照 $x_i-y_i$​​​ 从小到大排序，对于一个人，他和前面的人组队一定取 $x_i+y_j$​​，和后面的人组队一定取 $x_j+y_i$。\n对 $x_i,y_i$​ 搞一个前缀和就能很方便统计答案。有边的提前减掉就行。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;utility\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; namespace IO { // 省略了 } using namespace IO; const int maxn = 3e5 + 10; typedef long long ll; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } struct node { int i, j, pos; ll ans; bool operator\u0026lt;(const node \u0026amp;b) const { return i - j \u0026lt; b.i - b.j; } } a[maxn]; bool cmppos(const node \u0026amp;a, const node \u0026amp;b) { return a.pos \u0026lt; b.pos; } int n, m; ll down[maxn], up[maxn], ans[maxn]; int main() { n = read(), m = read(); for (int i = 1; i \u0026lt;= n; i++) a[i].i = read(), a[i].j = read(), a[i].pos = i; for (int i = 0; i \u0026lt; m; i++) add(read(), read()); for (int i = 1; i \u0026lt;= n; i++) for (int j : e[i]) a[i].ans -= std::min(a[i].i + a[j].j, a[i].j + a[j].i); std::sort(a + 1, a + 1 + n); for (int i = 1; i \u0026lt;= n; i++) down[i] = down[i - 1] + a[i].i, up[i] = up[i - 1] + a[i].j; for (int i = 1; i \u0026lt;= n; i++) { a[i].ans += 1ll * (i - 1) * a[i].j + down[i - 1]; a[i].ans += 1ll * (n - i) * a[i].i + up[n] - up[i]; } std::sort(a + 1, a + 1 + n, cmppos); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; a[i].ans \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } F Description 有 $n$ 个数的集合 $\\{a_i\\}$，求它的最小子集的大小，使其中数的最大公约数是 $1$。$n\\leq3\\times10^5,a_i\\leq3\\times10^5$。\nSolution 能发现答案最大是 $7$，一个数最多只有 $6$ 个公约数。那么我们可以从小到大枚举答案。\n然后就不会了，看了题解：\n存在性问题可以转化为求方案数。\n$f(i,j)$ 表示选了 $i$ 个数，当前 gcd 是 $j$​ 的方案数。\n$f(i,j)=C_{cnt_j}^i-\\sum f(i,k)$​，其中 $cnt_j$ 表示是 $j$ 倍数的数的个数，$k$ 是 $j$ 的倍数。\n解释一下：所有倍数减去不是最大公约数的。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;utility\u0026gt; using std::cin; using std::cout; using std::endl; using std::cerr; typedef long long ll; const int maxn = 3e5 + 10; const int N = 3e5; ll fac[maxn], ifac[maxn], f[10][maxn], cnt[maxn], mod = 1e9 + 7; int n; ll qpow(ll a, ll x) { ll res = 1; for (; x; x \u0026gt;\u0026gt;= 1, a = a * a % mod) if (x \u0026amp; 1) res = res * a % mod; return res; } void init(int n = 3e5) { fac[0] = 1; for (int i = 1; i \u0026lt;= n + 1; i++) fac[i] = fac[i - 1] * i % mod; ifac[n + 1] = qpow(fac[n + 1], mod - 2); for (int i = n; i \u0026gt;= 0; i--) ifac[i] = ifac[i + 1] * (i + 1) % mod; } inline ll C(int n, int m) { return m \u0026lt; 0 || n \u0026lt; 0 || n \u0026lt; m ? 0 : fac[n] * ifac[m] % mod * ifac[n - m] % mod; } inline void upd(ll \u0026amp;x, ll y) { x -= y, x += mod, x %= mod; } int main() { n = read(); init(); for (int x, i = 1; i \u0026lt;= n; i++) { cnt[read()]++; } for (int i = 1; i \u0026lt;= N; i++) for (int j = i + i; j \u0026lt;= N; j += i) cnt[i] += cnt[j]; for (int i = 1; i \u0026lt; 10; i++) { for (int j = N; j \u0026gt;= 1; j--) { f[i][j] = C(cnt[j], i); for (int k = j + j; k \u0026lt;= N; k += j) upd(f[i][j], f[i][k]); } if (f[i][1] \u0026gt; 0) { writeln(i); return 0; } } writeln(-1); } G 不会，好像要后缀数组。\n","permalink":"https://luoyisu.github.io/posts/cf-contest1043/","summary":"\u003cp\u003e好像又是没有数据结构和数学题的一天。\u003c/p\u003e","title":"Codeforces Round 519"},{"content":"一个 LCT\nDescription 游戏一开始，Lostmonkey 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $k_i$，当绵羊达到第 $i$ 个装置时，它会往后弹 $k_i$ 步，达到第 $i+k_i$个装置，若不存在这个装置，则绵羊被弹飞。\n绵羊想知道当它从第 $i$​ 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey 可以修改某个弹力装置的弹力系数。任何时候弹力系数均为正整数。\nSolution1 我们让每个装置向弹射到的地方连一个边，那么答案就是这个点到根的路径的长度。\n因为要加边、删边且一直是一棵树，我们使用 LCT 维护。\n具体怎么维护呢？\n我们发现，我们不需要把一段路径单独拎出来处理，只需要查询一个点到这个辅助树对应的原树上的根的距离即可。\n并且不能随便换原树的根。\n那好办了，回想一下我们为什么要换根：因为 $access$ 只能打通一个点到根的路径，所以当我们想查询一条路径的时候需要换根，但这个题根是固定的，不需要这么做。\n当查询点 $x$ 的时候，我们直接 $access(x),splay(x)$，然后答案就是 $siz(x)$。\n加边怎么办呢？我们直接 $access(x),splay(x)$，然后连一条虚边即可（实链剖分的灵活性体现出来了，这个虚边就有一点有向边的意思在里面）。\n删边怎么办呢？也是一样的。\n发现我们实际上少写了很多函数，代码又简洁常数又小。\nCode1 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2e5 + 10; struct LCT { int ch[maxn][2], rev[maxn], father[maxn], ans[maxn], val[maxn], siz[maxn]; inline int \u0026amp;ls(int x) { return ch[x][0]; } inline int \u0026amp;rs(int x) { return ch[x][1]; } inline bool get(int x) { return x == rs(father[x]); } inline bool isroot(int x) { return x != ch[father[x]][0] \u0026amp;\u0026amp; x != ch[father[x]][1]; } inline void push_up(int x) { siz[x] = siz[ls(x)] + siz[rs(x)] + 1; } inline void push_down(int x) { if (!rev[x]) return; if (ls(x)) std::swap(ls(ls(x)), rs(ls(x))), rev[ls(x)] ^= 1; if (rs(x)) std::swap(ls(rs(x)), rs(rs(x))), rev[rs(x)] ^= 1; rev[x] = 0; } inline void update(int x) { if (!isroot(x)) update(father[x]); push_down(x); } inline void rotate(int x) { int y = father[x], z = father[y], d = get(x); if (!isroot(y)) ch[z][y == ch[z][1]] = x; ch[y][d] = ch[x][d ^ 1]; if (ch[x][d ^ 1]) father[ch[x][d ^ 1]] = y; ch[x][d ^ 1] = y, father[y] = x, father[x] = z; push_up(y), push_up(x); } inline void splay(int x) { update(x); for (int f; f = father[x], !isroot(x); rotate(x)) if (!isroot(f)) rotate(get(x) == get(f) ? f : x); } inline int access(int x) { int p = 0; for (; x; p = x, x = father[x]) splay(x), rs(x) = p, push_up(x); return p; } } lct; int p[maxn]; int main() { std::ios::sync_with_stdio(false); int n, m; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { int x; cin \u0026gt;\u0026gt; x; if (i + x \u0026gt; n) continue; else lct.father[i] = i + x; } cin \u0026gt;\u0026gt; m; while (m--) { int pos, x; cin \u0026gt;\u0026gt; pos \u0026gt;\u0026gt; x; x++; if (pos == 1) { lct.access(x), lct.splay(x); cout \u0026lt;\u0026lt; lct.siz[x] \u0026lt;\u0026lt; endl; } else { int k; cin \u0026gt;\u0026gt; k; lct.access(x), lct.splay(x); lct.ls(x) = lct.father[lct.ls(x)] = 0; if (x + k \u0026lt;= n) lct.father[x] = x + k; lct.push_up(x); } } } Solution2 很无脑的一个做法，我不喜欢，但有必要学。\n建一个超级源点 $n+1$，弹射出去的时候在这个点和超级源点之间建边，查询的时候用 $link(x,n+1)$​ ，然后答案是 $siz(n+1)-1$。\n优点：高度模块化，比较无脑。\n缺点：我不喜欢，且代码长，常数大。\nCode2 我的实现很丑，看个乐。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #define mem(x) memset(x, 0, sizeof(x)) using std::cin; using std::cout; using std::endl; const int maxn = 2e5 + 10; inline int read() { char ch = getchar(); int x = 0; while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar(); return x; } struct LCT { int ch[maxn][2], rev[maxn], father[maxn], siz[maxn], val[maxn]; inline int \u0026amp;ls(int x) { return ch[x][0]; } inline int \u0026amp;rs(int x) { return ch[x][1]; } inline bool get(int x) { return x == rs(father[x]); } inline bool isroot(int x) { return x != ch[father[x]][0] \u0026amp;\u0026amp; x != ch[father[x]][1]; } inline void push_up(int x) { siz[x] = siz[ls(x)] + siz[rs(x)] + 1; } inline void push_down(int x) { if (!rev[x]) return; if (ls(x)) std::swap(ls(ls(x)), rs(ls(x))), rev[ls(x)] ^= 1; if (rs(x)) std::swap(ls(rs(x)), rs(rs(x))), rev[rs(x)] ^= 1; rev[x] = 0; } inline void update(int x) { if (!isroot(x)) update(father[x]); push_down(x); } inline void rotate(int x) { int y = father[x], z = father[y], d = get(x); if (!isroot(y)) ch[z][y == ch[z][1]] = x; ch[y][d] = ch[x][d ^ 1]; if (ch[x][d ^ 1]) father[ch[x][d ^ 1]] = y; ch[x][d ^ 1] = y, father[y] = x, father[x] = z; push_up(y), push_up(x); } inline void splay(int x) { update(x); for (int f; f = father[x], !isroot(x); rotate(x)) if (!isroot(f)) rotate(get(x) == get(f) ? f : x); } int access(int x) { int p = 0; for (; x; p = x, x = father[x]) splay(x), rs(x) = p, push_up(x); return p; } void makeroot(int x) { x = access(x), std::swap(ls(x), rs(x)), rev[x] ^= 1; } int find(int x) { access(x), splay(x), push_down(x); while (ls(x)) x = ls(x), push_down(x); splay(x); return x; } void split(int x, int y) { makeroot(x), access(y), splay(y); } void link(int x, int y) { makeroot(x), splay(x); if (find(y) == x) return; father[x] = y; } void cut(int x, int y) { makeroot(x); if (find(y) == x \u0026amp;\u0026amp; father[y] == x \u0026amp;\u0026amp; !ls(y)) ls(x) = father[y] = 0, push_up(x); } } lct; int p[maxn]; int main() { int n = read(); for (int i = 1; i \u0026lt;= n; i++) { int x = read(); lct.link(i, i + x \u0026gt; n ? n + 1 : i + x); p[i] = i + x \u0026gt; n ? n + 1 - i : x; } int m = read(); while (m--) { int pos = read(), x = read(); x++; if (pos == 1) { lct.split(x, n + 1); cout \u0026lt;\u0026lt; lct.siz[n + 1] - 1 \u0026lt;\u0026lt; endl; } else { int k = read(); lct.cut(x, x + p[x]); lct.link(x, x + k \u0026gt; n ? n + 1 : x + k); p[x] = x + k \u0026gt; n ? n + 1 - x : k; } } } 总结 注意题目的性质，可以考虑挖掘题目的一些性质，魔改数据结构入手，也可以考虑对数据结构进行一些扩展。\n","permalink":"https://luoyisu.github.io/posts/luogu3203/","summary":"\u003cp\u003e一个 LCT\u003c/p\u003e","title":"luogu3203"},{"content":"好像不是非常难。\nA Description 给一个字符串，将所有形如 ogo + gogogogo... 的串变为 ***，输出字符串。\nSolution 模拟。\nCode 尝试用 python 水过去（）\nn = int(input()) s = input() l = 0 while l \u0026lt; n: pos = s.find(\u0026#39;ogo\u0026#39;, l) if pos == -1: break print(s[l:pos], end = \u0026#39;\u0026#39;) l = pos while l \u0026lt; n - 2 and s[l + 1:l + 3] == \u0026#39;go\u0026#39;: l += 2 print(\u0026#39;***\u0026#39;, end = \u0026#39;\u0026#39;) l += 1 print(s[l:]) B Description 有一个 $n\\times m$​ 的舞台，给出每个点有没有人，在空的地方可以放灯，往上下左右其中一个方向打光。一个灯光合法当且仅当这个方向有人，位置相同方向不同的灯光算不同的灯光，求合法灯光总数。\nSolution 对每个方向做一个前缀和，然后算一下就行。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::cout; using std::cin; using std::endl; const int maxn = 1e3 + 10; int up[maxn][maxn], down[maxn][maxn], left[maxn][maxn], right[maxn][maxn]; int a[maxn][maxn], n, m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; a[i][j]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) left[i][j] = left[i][j - 1] + a[i][j]; for (int j = m; j \u0026gt;= 1; j--) right[i][j] = right[i][j + 1] + a[i][j]; } for (int j = 1; j \u0026lt;= m; j++) { for (int i = 1; i \u0026lt;= n; i++) up[i][j] = up[i - 1][j] + a[i][j]; for (int i = n; i \u0026gt;= 1; i--) down[i][j] = down[i + 1][j] + a[i][j]; } int ans = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) if (!a[i][j]) { ans += up[i][j] ? 1 : 0; ans += left[i][j] ? 1 : 0; ans += down[i][j] ? 1 : 0; ans += right[i][j] ? 1 : 0; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } C Description 你在 $0$ 处，需要在 $t$ 时间之前沿直线开车到达距离为 $s$ 的电影院，路上有 $k$ 个加油站，经过一个加油站时会免费加满油，有 $n$ 辆车，每辆车有价钱和油箱容量，初始时油箱会满油，一升油可以在 2min 中走 1km，也可以在 0.5min 中走 0.5km。问最少需要花多少钱。\nSolution 不难发现油箱容量是有单调性的，二分出最小的能满足题意的油箱容量（check 只需要模拟即可）。\n然后找一个油箱不小于它的价钱最小的车即可。注意若 $s\u0026gt;t$，肯定无解。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cout; using std::endl; using std::cin; const int maxn = 2e5 + 10; struct car { int c, v; } cars[maxn]; int n, k, s, t; int a[maxn]; bool check(int x) { int now = 0, time = 0; for (int i = 1; i \u0026lt;= k; i++) { int dis = a[i] - now; if (dis * 2 \u0026lt;= x) time += dis, now = a[i]; else if (x \u0026gt;= dis) time += dis * 2 - (x - dis), now = a[i]; else return false; } return time \u0026lt;= t; } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; cars[i].c \u0026gt;\u0026gt; cars[i].v; for (int i = 1; i \u0026lt;= k; i++) cin \u0026gt;\u0026gt; a[i]; a[++k] = s; if (s \u0026gt; t) { puts(\u0026#34;-1\u0026#34;); return 0; } std::sort(a + 1, a + 1 + k); int l = 1, r = s + 1, ans = r; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (check(mid)) r = mid - 1, ans = mid; else l = mid + 1; } int mi = 1 \u0026lt;\u0026lt; 30; for (int i = 1; i \u0026lt;= n; i++) if (cars[i].v \u0026gt;= ans) mi = std::min(mi, cars[i].c); if (mi == 1 \u0026lt;\u0026lt; 30) puts(\u0026#34;-1\u0026#34;); else cout \u0026lt;\u0026lt; mi \u0026lt;\u0026lt; endl; } D Description 有 $a$ 艘船，每艘船长度为 $b$，总共有 $n$​ 个位置，其中给出 $k$ 个已经进行过射击且没有船的位置，问最少打几次一定能打到船并输出方案。（建议看原题面加强理解）\nSolution 一个地方可能有船当且仅当有连续 $b$ 个 $0$，对于这种地方，我们打最后面就行。\n然后处理出可能有船的所有地方，根据雀巢原理（？），设所有可能有船的地方有 $x$ 个，我们只需要打其中 $x-a+1$ 个地方即可。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 2e5 + 10; char s[maxn]; int n, a, b, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; std::vector\u0026lt;int\u0026gt; ans; int now = 0; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;1\u0026#39;) now = 0; else { now++; if (now == b) now = 0, ans.push_back(i + 1); } } cout \u0026lt;\u0026lt; ans.size() - a + 1 \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; ans.size() - a + 1; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } E Description 有一颗 $n$ 个点的树，给出每个点的祖先数，并指定一个点是根。问最少有几个点的祖先数是错的。\nSolution 考虑一个点的祖先数一定是他父亲的祖先数加上一，那么所有点的祖先数排序之后一定是一个连续的非严格单调递增的序列。\n我们从小到大枚举祖先数，当没有任何一个点的祖先数是当前这个点时，我们把一个祖先数最大的点改过来就行，直到所有点都处理完。注意处理一下根。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cout; using std::cin; using std::endl; const int maxn = 2e5 + 10; int a[maxn], b[maxn], n, s, ans; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; if (i == s) ans += a[i] \u0026gt; 0; else b[a[i]]++; } int cnt = 1; for (int i = 1; cnt \u0026lt; n; i++) { if (!b[i]) cnt++, ans++; else cnt += b[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } F Description 有 $n$​ 个数。A、B 两个人轮流取数，A 从左取，B 从右取。A 先取。假如上一个人取了 $k$ 个数，那么这个人只能取 $k$ 或 $k+1$​ 个数。初始时 $k=1$。当取不了或取完时，游戏结束。A 想最大化他取的数的和 $a$，B 想最小化他去的数 $b$​。求这两个数差的最大值。$n\\leq4000$​​，空间 512MB。\nSolution 我以前对博弈论有个误解，以为只要是玩游戏就是博弈论，今天才知道博弈论是研究谁必胜的，这种最优化问题和 $SG$ 函数没关系。\n最优化，考虑一个 DP，$f(l,r,k,0/1)$​ 表示当前左面该取 $l$，右面该取 $r$，当前的 $k$，轮到 A/B 取的答案。\n状态数看起来是 $O(n^3)$​ 的，转移是 $O(1)$ 的。但实际上发现 $k$ 是 $O(\\sqrt n)$ 级别的，又发现对于一个确定的 $l$，可能的 $r$ 总数是 $O(k)=O(\\sqrt n)$ 级别的，也就是说合法的状态数总共只有 $O(n^2)$​ 个。转移挺简单的，但是需要注意一些细节。\n那么我们可以使用记忆化搜索来找到答案。\n注意直接开数组会 MLE，我们可以把所有可行的状态哈希一下用哈希表存储。（新学到的点）\nCode 不知道为什么，用 unordered_map 会 TLE，手写就不会，看来还是慎用比较好。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 4e4 + 10, maxm = 5e7 + 10, mod = 10000019; int a[maxn], n, sum[maxn]; inline int s(int l, int r) { return l \u0026gt; r ? 0 : sum[r] - sum[l - 1]; } struct node { int l, r, k, pos; node() {} node(int l_, int r_, int k_, int pos_) : l(l_), r(r_), k(k_), pos(pos_) {} }; long long hash(const node \u0026amp;x) { return (long long)((long long)800000 * x.l + 200 * x.r + x.k * 2 + x.pos); } struct hash_map { struct data { long long u; int v, nex; }; data e[mod \u0026lt;\u0026lt; 1]; int h[mod], cnt; int hash(long long u) { return u % mod; } int \u0026amp;operator[](long long u) { int hu = hash(u); for (int i = h[hu]; i; i = e[i].nex) if (e[i].u == u) return e[i].v; return e[++cnt] = (data){u, -1, h[hu]}, h[hu] = cnt, e[cnt].v; } hash_map() { cnt = 0; memset(h, 0, sizeof(h)); } } mp; int dp(int l, int r, int k, int pos) { if (r - l + 1 \u0026lt; k) return 0; else if (r - l + 1 == k) return s(l, r) * (pos == 1 ? -1 : 1); int nowst = hash(node(l, r, k, pos)); if (mp[nowst] != -1) return mp[nowst]; if (pos == 0) { int tmp = dp(l + k, r, k, pos ^ 1) + s(l, l + k - 1); if (l + k \u0026lt;= r) tmp = std::max(tmp, dp(l + k + 1, r, k + 1, pos ^ 1) + s(l, l + k)); return mp[nowst] = tmp; } else { int tmp = dp(l, r - k, k, pos ^ 1) - s(r - k + 1, r); if (r - k \u0026gt;= l) tmp = std::min(tmp, dp(l, r - k - 1, k + 1, pos ^ 1) - s(r - k, r)); return mp[nowst] = tmp; } } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], sum[i] = sum[i - 1] + a[i]; cout \u0026lt;\u0026lt; dp(1, n, 1, 0) \u0026lt;\u0026lt; endl; } ","permalink":"https://luoyisu.github.io/posts/cf-contest738/","summary":"\u003cp\u003e好像不是非常难。\u003c/p\u003e","title":"Codeforces Round 380 (Div. 2)"},{"content":"时间比较近的比赛果然难度大一些。。。\nA Description 有一个 $(n+1)\\times(m+1)$​ 的点图，问最少断掉几条边能使​剩下的点全联通且没有环。（建议看原题面）\nSolution 答案是 $n\\times m$，一个构造性证明：蛇形就行。\nB Description 给出一个序列 $\\{a_i\\}$ ，求最大的 $m$ 和任意的 $c$，满足 $a_i=(a_{i-1}+c)\\bmod m$​。（需要判断无解和 $m\\rightarrow\\infty$）​\nSolution 可以发现相邻的两个数差一定是 $c-m$ 或 $c$​，那么扫一遍就能知道 $c$ 和 $m$，然后再扫一遍看看合不合法就行。\nC Description 有 $n$ 个人， $m$ 天，你每天需要从给定的一些人中选一个，且每个人最多只能选 $\\lceil \\dfrac m2\\rceil$ 次，判断有没有解并给出一个方案。\nSolution 从前往后一天一天选。当一天只能选一个人，这个人必须就选了，先预处理这些天。剩下的天我们直接选当前已经选过的次数最少的人。\n证明感性一下，想要卡掉这个做法需要每天两个人一直出现，但是这样也只能让选一个人的次数达到 $\\dfrac m2$，所以卡不掉。\nCode 没必要看，实在是丑。。。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cout; using std::endl; using std::cin; const int maxn = 2e5 + 10; std::vector\u0026lt;int\u0026gt; a[maxn]; int used[maxn / 2], times[maxn / 2], ans[maxn]; int main() { int T; cin \u0026gt;\u0026gt; T; times[0] = used[0] = 1 \u0026lt;\u0026lt; 30; while (T--) { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) a[i].clear(), ans[i] = 0; for (int i = 1; i \u0026lt;= n; i++) used[i] = times[i] = 0; int flag = 1; for (int x, i = 1; i \u0026lt;= m; i++) { int t; cin \u0026gt;\u0026gt; t; while (t--) cin \u0026gt;\u0026gt; x, a[i].push_back(x), times[x]++; if (a[i].size() == 1) used[a[i][0]]++, times[a[i][0]]--, ans[i] = a[i][0], flag \u0026amp;= used[a[i][0]] \u0026gt; (m + 1) / 2 ? 0 : 1; } for (int i = 1; i \u0026lt;= m; i++) { if (a[i].size() == 1) continue; int mx = 0; for (int p : a[i]) if (used[p] \u0026lt; used[mx]) mx = p; used[mx]++, ans[i] = mx; if (used[mx] \u0026gt; (m + 1) / 2) { flag = 0; break; } } if (!flag) { puts(\u0026#34;NO\u0026#34;); continue; } puts(\u0026#34;YES\u0026#34;); for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } } D Description 给出 $n$​ 首歌，和他们的类型值，从头循环播放，如果当前的歌和前一首歌的类型值互质，把当前这首歌删掉，切到下一首歌去，求删除的歌的序列。\nSolution 用一个链表模拟即可，第一次扫一遍把要删除的组加进一个队列里，然后取出队首，执行删除，再判断一下需不需要接着删就行。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; using std::cin; using std::cout; using std::endl; inline int gcd(int x, int y) { return y == 0 ? x : gcd(y, x % y); } const int maxn = 1e5 + 10; typedef std::pair\u0026lt;int, int\u0026gt; pii; int nxt[maxn], a[maxn], used[maxn]; std::vector\u0026lt;int\u0026gt; ans; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], nxt[i] = i + 1; nxt[n] = 1; std::queue\u0026lt;pii\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) if (gcd(a[i], a[nxt[i]]) == 1) q.push(pii(i, nxt[i])), i++; while (!q.empty()) { auto now = q.front(); q.pop(); int pos = now.first, npos = now.second; if (used[pos] || used[npos]) continue; used[npos] = 1; ans.push_back(npos); nxt[pos] = nxt[npos]; if (gcd(a[pos], a[nxt[pos]]) == 1) q.push(pii(pos, nxt[pos])); } cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (int i : ans) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; ans.clear(), memset(used, 0, sizeof(used)); } } E Description 给出 $n$​​ 个楼房的高度和美丽值，把所有楼房划分成连续的若干组，最大化 每组高度最小的楼房的美丽值 的和。$n\\leq3\\times10^5$​。\nSolution 显然有个 DP，$f_i=\\max\\{f_j+val(j+1,n)\\}$​，其中 $val(l,r)$​ 表示 $[l,r]$​​ 内最矮楼房的美丽值。然后发现一个楼房到下一个比它更矮的楼房这段区间内， $val$ 都是固定的，可以维护一个单调栈。\n算法一 对于每个楼房，进栈时把他能影响到的 $f$ 的值全部加它的美丽值，出栈的时候减掉。使用线段树维护， $f_i$ 就是当前所有已经加进线段树的点的最大值。然后把 $f_i$ 加进去。细节有点多。。。。。\nCode1 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using std::cout; using std::endl; using std::cin; const int maxn = 3e5 + 10; typedef long long ll; const ll inf = 1ll \u0026lt;\u0026lt; 60; struct node { ll lzy, mx; node() {} } t[maxn * 4]; inline int ls(int x) { return x * 2; } inline int rs(int x) { return x * 2 + 1; } inline void push_up(int k) { t[k].mx = std::max(t[ls(k)].mx, t[rs(k)].mx); } inline void push_down(int k) { if (!t[k].lzy) return; t[ls(k)].lzy += t[k].lzy, t[rs(k)].lzy += t[k].lzy; t[ls(k)].mx += t[k].lzy, t[rs(k)].mx += t[k].lzy; t[k].lzy = 0; } void modify_add(int l, int r, int x, int y, ll v, int k) { if (l \u0026gt;= x \u0026amp;\u0026amp; r \u0026lt;= y) { t[k].lzy += v; t[k].mx += v; return; } int mid = (l + r) / 2; push_down(k); if (x \u0026lt;= mid) modify_add(l, mid, x, y, v, ls(k)); if (y \u0026gt; mid) modify_add(mid + 1, r, x, y, v, rs(k)); push_up(k); } void modify(int l, int r, int x, ll v, int k) { if (l == r) { //t[k].lzy = 0; t[k].mx = v; //cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; return; } int mid = (l + r) / 2; //push_down(k); if (x \u0026lt;= mid) modify(l, mid, x, v, ls(k)); else modify(mid + 1, r, x, v, rs(k)); push_up(k); } ll query(int l, int r, int x, int y, int k) { if (x \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= y) { return t[k].mx; } int mid = (l + r) / 2; ll res = -inf; if (x \u0026lt;= mid) res = std::max(res, query(l, mid, x, y, ls(k))); if (y \u0026gt; mid) res = std::max(res, query(mid + 1, r, x, y, rs(k))); return res; } struct Q { int i, val, b; Q() { i = b = 0, val = -1; } Q(int i_, int val_, int b_) : i(i_), val(val_), b(b_) {} } q[maxn]; int n, h[maxn], b[maxn]; ll f[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; b[i]; int r = 1; h[0] = -1; for (int i = 1; i \u0026lt;= n; i++) { while (r \u0026amp;\u0026amp; q[r].val \u0026gt;= h[i]) { modify_add(0, n, q[r - 1].i, q[r].i - 1, -q[r].b, 1); r--; } q[++r] = Q(i, h[i], b[i]); modify_add(0, n, q[r - 1].i, i - 1, b[i], 1); f[i] = query(0, n, 0, i - 1, 1); modify(0, n, i, f[i], 1); } //for (int i = 1; i \u0026lt;= n; i++) // cout \u0026lt;\u0026lt; f[i] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f[n] \u0026lt;\u0026lt; endl; } 算法二 同样是单调栈，直接上代码吧。。。维护之前的答案折腾一下，很难描述。看题解得来的做法。\nCode2 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::cout; using std::cin; using std::endl; const int maxn = 3e5 + 10; typedef long long ll; int h[maxn], b[maxn], n; ll f[maxn]; struct Q { int i, h; ll val, ans; } q[maxn]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; b[i]; int r = 0; q[0].ans = -1ll \u0026lt;\u0026lt; 60; for (int i = 1; i \u0026lt;= n; i++) { ll t = f[i - 1]; while (r \u0026amp;\u0026amp; q[r].h \u0026gt; h[i]) { t = std::max(t, q[r].val); r--; } q[++r] = {i, h[i], t, 0ll}; f[i] = q[r].ans = std::max(q[r - 1].ans, t + b[i]); // 前一部分是之前的答案，有更小的楼房，直接放在一组里，后面是新开一组的答案 } cout \u0026lt;\u0026lt; f[n] \u0026lt;\u0026lt; endl; } F Description 有一个 $n$​ 个点的带权无向图（$n\\leq600$​），给出若干个三元组 $(u,v,l)$​​，问有多少条边满足：\n在任意一个三元组中 $u$​ 到 $v$​ 的路径上；\n这个路径的长度不大于 $l$。\nSolution 发现一条边 $(x,y)$​​ 满足要求当且仅当存在一个三元组 $(u,v,l)$​​ 满足 $dis(u,x)+w(x,y)+dis(y,w)\\leq l(u,v)$​​​。\n首先枚举 $O(n^4)$ 肯定是对的，但是会 TLE，想个办法优化枚举。。。\n换个形式：$dis(u,x)+w(x,y)\\leq l(u,v)-dis(y,v)$​。\n我们枚举 $u,y$，这样左面只和 $x$ 有关，右面只和 $v$ 有关，考虑接着枚举 $x$，我们发现，因为存在 $v$ 即可，所以一个 $x$ 满足要求等价于 $dis(u,x)+w(x,y)\\leq(l(u,v)-dis(y,v))_{max}$。右面可以枚举 $u,v,y$ 在 $O(n^3)$ 时间内预处理出来，答案可以枚举 $u,v,x$ 求出来，那么我们在 $O(n^3)$​ 的时间内解决了这个问题。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 610; typedef long long ll; ll dis[maxn][maxn], mx[maxn][maxn]; ll p[maxn][maxn]; int ok[maxn][maxn]; struct edge { int y, w; }; std::vector\u0026lt;edge\u0026gt; e[maxn]; inline void add(int x, int y, int w) { e[x].push_back({y, w}), e[y].push_back({x, w}); } int n, m, q; int main() { memset(dis, 1, sizeof(dis)); memset(p, 128, sizeof(p)), memset(mx, 128, sizeof(mx)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) p[i][j] /= 2, mx[i][j] /= 2, dis[i][j] /= 2; for (int i = 1, x, y, w; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; w, dis[x][y] = dis[y][x] = w, add(x, y, w); cin \u0026gt;\u0026gt; q; for (int i = 1, x, y, l; i \u0026lt;= q; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; l, p[x][y] = p[y][x] = l; for (int k = 1; k \u0026lt;= n; k++) for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) dis[i][j] = std::min(dis[i][j], dis[i][k] + dis[k][j]); for (int i = 1; i \u0026lt;= n; i++) dis[i][i] = 0, add(i, i, 0); for (int u = 1; u \u0026lt;= n; u++) for (int y = 1; y \u0026lt;= n; y++) for (int v = 1; v \u0026lt;= n; v++) //if (p[u][v]) mx[u][y] = std::max(mx[u][y], (ll)p[u][v] - dis[y][v]); for (int u = 1; u \u0026lt;= n; u++) for (int y = 1; y \u0026lt;= n; y++) for (auto k : e[y]) { int x = k.y, w = k.w; if (w + dis[x][u] \u0026lt;= mx[u][y]) ok[x][y] = ok[y][x] = 1; } int ans = 0; for (int i = 1; i \u0026lt; n; i++) for (int j = i + 1; j \u0026lt;= n; j++) if (ok[i][j]) ans++; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","permalink":"https://luoyisu.github.io/posts/cf-contest1484/","summary":"\u003cp\u003e时间比较近的比赛果然难度大一些。。。\u003c/p\u003e","title":"Codeforces Round 709 (div2)"},{"content":"因为是久远的比赛，没有什么特别难的题。\n没有 DP 好评（）\nA Description 有 $n$ 个大人 $m$ 个小孩，一枚车票一元钱，一个大人可以带很多小孩，一个大人能免费带一个小孩上车，每个小孩都必须有一个大人带。问最少/最多需要花多少钱。\nSolution 又水又毒瘤，不写了，看代码。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::cin; using std::endl; using std::cout; int main() { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if (a == 0 \u0026amp;\u0026amp; b != 0) // 有小孩没大人 puts(\u0026#34;Impossible\u0026#34;); else if (b == 0) // 有大人没小孩 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; std::max(a, b) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a + b - 1 \u0026lt;\u0026lt; endl; // 最少就是尽量一个大人带一个小孩，最大就是一个大人带所有小孩 } B Description 平面上有两个圆，输出一个能连接这两个圆的圆的最小半径。\nSolution 分两个圆相离、内含、相交（相切）算一下就行，具体看代码。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using std::cin; using std::endl; using std::cout; inline double pow2(double x) { return x * x; } inline void updmi(double \u0026amp;a, double b) { a = std::min(a, fabs(b) / 2.0); } inline void out(double x) { printf(\u0026#34;%.15lf\\n\u0026#34;, x); } int main() { double x1, y1, r1, x2, y2, r2; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; r2; double dis = sqrt(pow2(x1 - x2) + pow2(y1 - y2)); if (r1 \u0026lt; r2) std::swap(r1, r2); if (dis \u0026gt; r1 + r2) // 相离，即样例的那两个图 out((dis - r1 - r2) / 2.0); else if (r2 + dis \u0026lt; r1) // 内含，圆的直径是大半径减小半径减两个圆圆心的距离 out((r1 - r2 - dis) / 2.0); else // 相交或相离，显然答案是 0 out(0.0); } C Description 给出若干个 pair 和 int，你需要把它输出成合法的 c++ 语法，如 pair pair int int int 输出 pair\u0026lt;pair\u0026lt;int,int\u0026gt;,int\u0026gt;，如果无解输出 Error occurred。\nSolution 类似一个表达式转化，对于一个 pair 递归两次就行，注意直接用 string 会 TLE，最好先判断一下有没有解。（我这个做法贼蠢，看个乐就行）\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; using std::cin; using std::endl; using std::cout; const int maxn = 1e6 + 10; int a[maxn]; char s[10]; int n, m; void work(int \u0026amp;i) { if (a[i] == 0) cout \u0026lt;\u0026lt; \u0026#34;int\u0026#34;; if (a[i] == 1) { cout \u0026lt;\u0026lt; \u0026#34;pair\u0026lt;\u0026#34;; work(++i); cout \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; work(++i); cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34;; } } bool check(int \u0026amp;i) { if (i == n) return a[i] == 0 ? 1 : 0; if (i == 1 \u0026amp;\u0026amp; a[i] == 0) return 0; if (a[i] == 0) return 1; bool tmp = 1; if (a[i] == 1) { tmp = check(++i); if (tmp == 0) return 0; tmp = check(++i); if (tmp == 0) return 0; } return 1; } int main() { cin \u0026gt;\u0026gt; m; while (cin \u0026gt;\u0026gt; s) a[++n] = s[0] == \u0026#39;p\u0026#39; ? 1 : 0; if (n != m + m - 1) { puts(\u0026#34;Error occurred\u0026#34;); return 0; } int i = 1; bool ok = check(i); if (!ok || i \u0026lt; n) { puts(\u0026#34;Error occurred\u0026#34;); return 0; } i = 1; work(i); cout \u0026lt;\u0026lt; endl; } D Description 给定一个长度为 $n$ 的序列 $a_i$ 和 $k$，求满足出现次数最多的数的出现次数小于 $k$​ 的连续子序列的数目。\nSolution 由于是连续的子序列，而且发现选的数越多越可能满足，考虑双指针。\n对于每个 $l$，我们找到最小的能满足这个条件的 $r$​，然后后面的就随便选了，把它对答案的贡献加进去，就完事了。\n至于怎么找 $r$ 呢，我们用一个 map 存每个数的出现次数就行了。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; using std::cout; using std::endl; using std::cin; const int maxn = 4e5 + 10; typedef long long ll; int n, a[maxn], k; ll ans; std::map\u0026lt;int, int\u0026gt; mp; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; int l = 1, r = 2; mp[a[1]]++; for (; l \u0026lt;= n; l++) { while (r \u0026lt;= n \u0026amp;\u0026amp; mp[a[r - 1]] \u0026lt; k) mp[a[r]]++, r++; if (mp[a[r - 1]] \u0026gt;= k) ans += n - r + 2; mp[a[l]]--; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } E Description 给定一个点数为 $n$ 的完全图，从中删除 $m$ 条边，求得到的图的联通块。$n\\leq5\\times10^5,m\\leq10^6$。\nSolution 发现一个事情：相对于一个很大的完全图，删除的边数实在少得可怜。量化一下发现最多只能让约 $\\dfrac{m}{n}$​​​ 个点成为一个独立的联通块。\n这实在是小的可怜。也就是说大部分点实际上是连通的。\n考虑到当能删完的时候，$n\\approx1500$，那么我们直接找一个在删除的边中出现次数最小的点，把与它相连的点全都取出来当成一个联通块。\n剩下的点爆搜一下连通块就行。我的实现非常暴力而且恶心，使用了 map 复杂度大概是 $O(n+(\\dfrac{m}{n})^2\\log\\dfrac{m}{n})$​​。最大的点跑得很慢。\n事实上我不知道我这个复杂度到底对不对，反正是卡常卡过去了\u0026hellip;\n看到有用并查集的做法能做到 $O(n+m)$​，值得一学。。。\nCode #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;map\u0026gt; using std::cout; using std::endl; using std::cin; const int maxn = 5e5 + 10; namespace IO { const int mxsiz = 1 \u0026lt;\u0026lt; 20; char inbuf[mxsiz], *p1, *p2; char outbuf[mxsiz], *op = outbuf; struct endio { endio(){}; ~endio() { fwrite(outbuf, 1, op - outbuf, stdout); } } useless_var; inline char gc() { return p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = inbuf) + fread(inbuf, 1, mxsiz, stdin), p1 == p2) ? EOF : *p1++; } #define isdigit(x) (x \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;9\u0026#39;) // 防止忘记打 \u0026lt;cctype\u0026gt; 头文件 inline int read() { int x = 0, f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; return x * f; } template \u0026lt;typename T\u0026gt; inline void read(T \u0026amp;x) { x = 0; int f = 1; char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == \u0026#39;-\u0026#39;) f = -1; for (; isdigit(ch); ch = gc()) x = x * 10 + ch - \u0026#39;0\u0026#39;; x *= f; } #undef isdigit inline bool ischar(char x) { return x \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;z\u0026#39;; } inline char readchar() { char ch = gc(); while (!ischar(ch)) ch = gc(); return ch; } inline void push(char ch) { if (op - outbuf == mxsiz) fwrite(outbuf, 1, mxsiz, stdout), op = outbuf; *op++ = ch; } template \u0026lt;typename T\u0026gt; inline void work_wt(T x) { if (x \u0026gt; 9) work_wt(x / 10); push(x % 10 + \u0026#39;0\u0026#39;); } template \u0026lt;typename T\u0026gt; inline void write(T x) { if (x \u0026lt; 0) x = -x, push(\u0026#39;-\u0026#39;); work_wt(x); } inline void writestr(char *s) { int n = strlen(s); for (int i = 0; i \u0026lt; n; i++) push(s[i]); } inline void endln() { push(\u0026#39;\\n\u0026#39;); } inline void space() { push(\u0026#39; \u0026#39;); } template \u0026lt;typename T\u0026gt; inline void writeln(T x) { write(x), endln(); } } using namespace IO; int times[maxn], n, mm, tot, used[maxn], arcscc[maxn], m; std::vector\u0026lt;int\u0026gt; scc[maxn]; std::vector\u0026lt;int\u0026gt; e[maxn], e2[maxn / 10]; std::map\u0026lt;int, int\u0026gt; mp[maxn]; std::vector\u0026lt;int\u0026gt; not_used; std::vector\u0026lt;int\u0026gt; now; int p[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } inline void add2(int x, int y) { e2[x].push_back(y), e2[y].push_back(x); } void dfs(int x, int q) { arcscc[not_used[x - 1]] = q; if (x != m + 1 \u0026amp;\u0026amp; not_used[x - 1] != n + 1) scc[q].push_back(not_used[x - 1]); for (int v : e2[x]) if (!arcscc[not_used[v - 1]]) dfs(v, q); } int main() { n = read(), mm = read(); // 这里的 mm 是原题的 m，我因为变量名冲突改了一下 for (int x, y, i = 1; i \u0026lt;= mm; i++) x = read(), y = read(), times[x]++, times[y]++, add(x, y); int mi = 1e9, pos = 0; for (int i = 1; i \u0026lt;= n; i++) if (times[i] \u0026lt; mi) mi = times[i], pos = i; scc[++tot].push_back(pos), used[pos] = 1, arcscc[pos] = 1; for (int v : e[pos]) used[v] = 1; for (int i = 1; i \u0026lt;= n; i++) if (!used[i] \u0026amp;\u0026amp; i != pos) scc[tot].push_back(i), arcscc[i] = 1; else if (used[i]) not_used.push_back(i); // 以上是找到出现次数最小的点并将与他相连的点删掉 for (int i : not_used) { int cnt = 0; for (int v : e[i]) if (arcscc[v] == 0) mp[i][v] = mp[v][i] = 1; else cnt++; if (cnt == scc[1].size()) mp[i][n + 1] = mp[n + 1][i] = 1; } m = not_used.size(); // 删掉之后原图剩余点数 not_used.push_back(n + 1); // 除了剩余的点，刚刚删除的点也作为一个联通块加进去 for (int i = 1; i \u0026lt;= not_used.size(); i++) now.push_back(i), p[i] = not_used[i - 1]; for (int i = 1; i \u0026lt; m + 1; i++) for (int j = i + 1; j \u0026lt;= m + 1; j++) if (!mp[p[i]][p[j]]) add2(i, j); // 重新建图 dfs(m + 1, 1); for (int i = 1; i \u0026lt;= m; i++) if (!arcscc[not_used[i - 1]]) dfs(i, ++tot); writeln(tot); for (int i = 1; i \u0026lt;= tot; i++) { write(scc[i].size()), space(); for (int j : scc[i]) write(j), space(); endln(); } return 0; } ","permalink":"https://luoyisu.github.io/posts/cf-contest120/","summary":"\u003cp\u003e因为是久远的比赛，没有什么特别难的题。\u003c/p\u003e\n\u003cp\u003e没有 DP 好评（）\u003c/p\u003e","title":"Codeforces Round 120 (Div. 2) 题解"},{"content":"看到 OI Wiki 上有关 KMP 的一个不算惊为天人但也有点意思的做法，水一水。\n众所周知 KMP 是为了解决字符串匹配问题的，有一个长度为 $n$ 的模式串 $t$ 和一个文本串 $s$。\n我们构造一个字符串 $t+\\#+s$​​​​，其中 $\\#$​​​​ 是既不在 $t$​​​​ 中也不在 $s$​​​​ 中的一个字符。\n求这个字符串的前缀数组（即 $nxt$ 函数），那么在该字符串中 $nxt[i]=n$​ 的位置就是一个匹配。\nchar a[maxn]; // 字符串从 1 开始 char b[maxn]; int n, m; int nxt[maxn]; void solve() { for (int i = 2, j = 0; i \u0026lt;= n + 1 + m; i++) { while (j \u0026amp;\u0026amp; a[i] != a[j + 1]) j = nxt[j]; if (a[i] == a[j + 1]) j++; nxt[i] = j; } for (int i = n + 2; i \u0026lt;= n + 1 + m; i++) if (nxt[i] == n) cout \u0026lt;\u0026lt; i - 2 * n \u0026lt;\u0026lt; endl; } ","permalink":"https://luoyisu.github.io/posts/kmp-explore/","summary":"\u003cp\u003e看到 \u003cstrong\u003eOI Wiki\u003c/strong\u003e 上有关 KMP 的一个不算惊为天人但也有点意思的做法，水一水。\u003c/p\u003e","title":"KMP 的一个不常见做法"},{"content":"懒得写那么多题解，于是就有了这个文章。\n难度评级 D：很简单，也没怎么调。很可能不会出现在这个文章里。\nC：会做，但是出了一些不是特别傻的 bug。\nB：勉强会做 / 写代码是遇到了问题。\nA：不会，看了题解很容易就弄懂了。\nS：完全不会，反复看题解和代码才懂。\n可能用加减号来更细化一些，+表示难，-表示简单。\nChapter 1 递推 E 练习1 划分数列 给定一个长度为 $n$ 的数列，要求划分最少的段数，使得每一段要么单调不降，要么单调不升。\n难度：D+\n有点贪心的感觉，可以发现如果能接上肯定比不接好，和每一段越长越好。\n预处理 $up_i,down_i$​ 表示以 $i$​ 为结尾的最长不降/不升段的开始位置，然后答案 $f_i=\\min(f_{up_i-1},f_{down_i-1})+1$​。\nG 练习2 无限序列 我们按以下方式产生序列：\n开始时序列是： 1 ； 每一次变化把序列中的 1 变成 10 ，0 变成 1。 经过无限次变化，我们得到序列 1011010110110101101...。\n总共有 $Q$ 个询问（ $Q\\leq5000$） ，要回答在区间 $[a,b]$​ 间有多少个1（$1\\leq a\\leq b\\leq2^{63}$​）。\n难度：D+\n手玩发现第 $i$ 次变化后得到的序列是 $i-1$ 次变化后的序列 + $i-2$ 次变化后的序列，于是这就是个斐波那契。\n对于每个询问，转换成前缀和，然后不停二分即可。要注意二分时要找到第一个不大于它的，所以用 std::lower_bound() 时要注意。\n{% spoiler Code %}\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using std::cout; using std::endl; const int maxn = 100 + 10, n = 100; typedef unsigned long long ll; inline ll read() { ll x = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - \u0026#39;0\u0026#39;, ch = getchar(); return x; } void write(ll x) { if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } ll f[maxn], ans[maxn]; ll solve(ll x) { if (x == 0) return 0; ll res = 0; while (x) { int pos = std::lower_bound(f, f + 1 + n, x + 1) - f; pos--; if (pos \u0026lt; 0) return res; res += ans[pos]; x -= f[pos]; } return res; } int main() { f[0] = ans[0] = 1, f[1] = 2, ans[1] = 1; for (int i = 2; i \u0026lt;= n; i++) f[i] = f[i - 1] + f[i - 2], ans[i] = f[i - 1]; int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { ll x, y; x = read(), y = read(); write(solve(y) - solve(x - 1)); puts(\u0026#34;\u0026#34;); } } {% endspoiler %}\nChapter 2 二分 F 练习3 攻击法坛 题面\n难度：C\n二分 $L$，然后用 DP 来 check，$f(i,j)=\\max(nxt1_{f(i-1,j)+1},nxt2_{f(i,j-1)+1})$。其中 $f(i,j)$ 表示用 $i$ 个第一种法杖和 $j$​ 个第二种法杖能覆盖的最远的法坛，$nxt1_i,nxt2_i$​ 分别表示在第 $i$ 个祭坛处用第一种/第二种法杖能覆盖的最远的法坛。特别地，$nxt1_{n+1}=nxt2_{n+1}=n$。注意使用次数限制需要和 $n$​ 取一个最小值。\nChapter 19 倍增 H 练习3 图上查询 一个 $n$ 个点 $n$ 条边的 有向图，对每个点求出从它出发经过 $k$ 条边，这些边的权值和以及这些边的权值最小值。\n难度：D+\n一开始没看到有向图，就纳闷了，这玩意基环树？？？然后越想越不对劲，感觉是有向图这个题就不对了啊。\n看了题解发现是有向图。。。。。。。然后这个有向图每个点的出度都是 $1$，那么倍增一下就行。\n然后写着写着又忘记这个有向图有环了，可以无限走下去，于是挂了好几遍。。。\n确实要注意一下。\nChapter 22 数位DP C 例题3 数字计数 [ZJOI2010] 给定两个正整数 $l$ 和 $r$，求在 $[l,r]$ 中的所有整数中，每个数码各出现了多少次。\n难度：B+\n第一道自己做的数位DP\u0026hellip;\n虽说是数位DP，但我似乎并不是正统数位DP，更像是一种推式子的递推。\n做每道推式子的计数都很费劲啊。。。实际上这题并不难。\n设 $f(i,1/0)$​ 表示从低到高第 $i$​​ 位，是/否紧贴上界，当前数码出现总次数。$cnt(i,1/0)$​ 表示由低到高 $i$​​ 位，是/否紧贴上界，总共有几个数。$p_i$ 表示从低到高第 $i$ 位数。\n对于数码 $1\\sim9$ 显然有 $cnt(i,0)=cnt(i+1,0)\\times10+p_i$，$cnt(i,1)=cnt(i+1,1)$，$f(i,1)=f(i+1,1)+[p_i=x]$​。其中 $x$ 为当前要算的数码。\n考虑 $f(i,0)$​，先给出来式子：$f(i,0)=f(i+1,0)\\times10+cnt(i+1,0)+f(i+1,1)\\times p_i+[p_i\u0026gt;x]$。\n解释一下：上一位所有含当前数码的数在这一位可以随便填一个数，所以乘一个 $10$；之前所有数后面都可以填一个当前数码，所以要加上 $cnt(i+1,0)$；之前紧贴上界的数可以填一个小于 $p_i$ 的数，如果当前数码比 $p_i$ 小，那么在刚刚填的时候还会填进去一个当前数码，要算进去。\n{% spoiler Code %}\n在该开 long long 的地方记得开。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 20; typedef long long ll; ll f[maxn][2], cnt[maxn][2]; int p[maxn], len; ll dp(int x) { cnt[len + 1][1] = 1; for (int i = len; i \u0026gt;= 1; i--) { cnt[i][0] = cnt[i + 1][0] * 10 + p[i]; cnt[i][1] = cnt[i + 1][1]; f[i][1] = f[i + 1][1] + (p[i] == x ? 1 : 0); f[i][0] = f[i + 1][0] * 10 + cnt[i + 1][0] + f[i + 1][1] * p[i]; if (p[i] \u0026gt; x) f[i][0]++; } ll tmp = 0; if (x == 0) for (int i = 1; i \u0026lt;= len; i++) tmp = tmp * 10 + 1; return f[1][0] + f[1][1] - tmp; } ll solve(ll x, int i) // 此处没开 long long，导致 WA 了一遍。。。 { len = 0; while (x) p[++len] = x % 10, x /= 10; memset(cnt, 0, sizeof(cnt)), memset(f, 0, sizeof(f)); return dp(i); } int main() { ll a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = 0; i \u0026lt;= 9; i++) cout \u0026lt;\u0026lt; solve(b, i) - solve(a - 1, i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } {% endspoiler %}\n","permalink":"https://luoyisu.github.io/posts/ybtoj-simple-solutions/","summary":"\u003cp\u003e懒得写那么多题解，于是就有了这个文章。\u003c/p\u003e","title":"YbtOJ 简要题解合集"},{"content":"前言 为什么我去学了模拟退火呢？\n因为 CSP2021T1 和 NOIP2021T3 都能用模拟退火得到很高的分数，但是我却只打了最简单的暴力。失去了很多分数。\n本着补全科技树的想法，我稍微学了一下模拟退火。\n下文参考了 OI Wiki。\n注：未完工。\n前置知识——随机数 众所周知计算机的随机数是伪随机数。\n那么我们首先需要让他变得随机一些。\n下面依次介绍几个 C++ 库中生成随机数的方法。\n（因为不是非常常用，我怕我忘记，所以有这部分内容。）\nrand() 需要 \u0026lt;cstdlib\u0026gt; 库。\n用法：直接调用 rand() 返回一个 $[0,\\text{RAND\\_MAX}]$​​ 的随机数，Linux 下这个上界是 $2^{31}-1$​​​​。\n随机种子：用 srand() 修改，否则使用默认种子。\n优点：好记，常见。\n缺点：慢，不是非常随机。\nstd::mt19937 需要 \u0026lt;random\u0026gt; 库。\n用法：这是个类，可以用 std::mt19937 myrand() 来声明一个。重载了括号运算符，实际使用时和 rand() 一样，随机数范围同 unsigned int 范围。\n优点：快，更强一些。\n缺点：不太好记。\n还有个 std::mt19937_64，范围同 unsigned long long。\n简介 假设有一个很莫名其妙的函数，要求它的极值，模拟退火算法可以帮助我们找到答案。（但不一定是函数）\n首先，假设我们有一个局部最优解。\n假设我们随机到了另一个状态，它更优，我们肯定更新最优解。\n如果它更劣呢？我们不能把它忽略，因为这样就丧失了找到整体最优解的机会；但也不能直接就跳过去，这样局部最优解就找不到了。\n那么我们就以一定概率去接受这个新状态。\n定义当前温度 $T$，有一个已知状态，通过已知状态随机得到一个新状态，两者差为 $\\Delta E$（$\\Delta E \\geq0$），那么发生状态转移（更新答案）的概率为： $$ P(\\Delta E)= \\begin{cases} 1\u0026amp;\\text{新状态更优}\\\\ e^\\frac{-\\Delta E}{T}\u0026amp;\\text{新状态更劣} \\end{cases} $$ 解释一下：显然我们需要让差越大转移的概率越低，而且温度越低转移到劣解的概率越低。\n实现 有三个参数 $T_0,d,T_{end}$。分别为初始温度（一个较大的数），降温系数（接近 $1$ 的数），终止温度（接近 $0$ 的正数）。\n首先让当前温度 $T=T_0$，然后尝试转移一次，接着让 $T\\leftarrow T\\times d$，直到 $T\u0026lt;T_{end}$。得到最优解。\n在找到最优解之后可以再用初始很低的温度再稍微跑一跑模拟退火，可能会找到更优解。\n关于这三个参数，需要自己根据样例调整。（或者和暴力对拍）\n小技巧——卡时 clock() 函数返回程序运行时间，于是可以这么写：\nwhile ((double)clock() / CLOCKS_PER_SEC \u0026lt; 0.95) SA(); 后面的 0.95 是自定义的一个数，要小于时限。\n这样可以多执行几遍模拟退火，增加准确性。\nNOIP2021 方差 题面不说了。\n这个题正解不是模拟退火，不过可以用模拟退火得到 $60+$​ 分，而且非常简单，超值。\n需要注意的是不能每次对差分数组随机一个排列，这样没意义，不满足模拟退火的下一个状态要从这一个状态转移来的要求。\n所以直接随机选一个执行操作即可。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;random\u0026gt; using std::cout; using std::endl; const int maxn = 1e4 + 10; typedef long long ll; int a[maxn], n, b[maxn]; ll sumpow, sum; ll calc() { sumpow = 0, sum = 0; for (int i = 1; i \u0026lt;= n; i++) sumpow += b[i] * b[i], sum += b[i]; return sumpow * n - sum * sum; } inline double rnd01() { return (double)rand() / RAND_MAX; } inline void modify(int pos) { b[pos] = b[pos - 1] + b[pos + 1] - b[pos]; } ll ans = 1e18; std::mt19937 rng; void SA() { double T0 = 100000, d = 0.99997, Tend = 0.00001; for (int i = 1; i \u0026lt;= n; i++) b[i] = a[i]; ll nowans = 1e18; while (T0 \u0026gt; Tend) { int pos = rng() % (n - 2) + 2; modify(pos); ll res = calc(); ans = std::min(ans, res); if (res \u0026lt;= nowans) nowans = res; else if (exp((double)(nowans - res) / T0) \u0026gt; rnd01()) nowans = res; else modify(pos); T0 *= d; } } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); rng = std::mt19937(time(0)); srand(time(0)); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); while ((double)clock() / CLOCKS_PER_SEC \u0026lt; 0.85) SA(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } ","permalink":"https://luoyisu.github.io/posts/simulated-annealing/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e为什么我去学了模拟退火呢？\u003c/p\u003e\n\u003cp\u003e因为 CSP2021T1 和 NOIP2021T3 都能用模拟退火得到很高的分数，但是我却只打了最简单的暴力。失去了很多分数。\u003c/p\u003e\n\u003cp\u003e本着补全科技树的想法，我稍微学了一下模拟退火。\u003c/p\u003e\n\u003cp\u003e下文参考了 \u003ca href=\"https://oi-wiki.org/misc/simulated-annealing/\"\u003e\u003cstrong\u003eOI Wiki\u003c/strong\u003e\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e注：未完工。\u003c/p\u003e","title":"模拟退火学习笔记"},{"content":"NOIP2021 凄凉。\nDay -1 没干啥，写了几个板子，本来想写个平衡树和扫描线的，但是懒得写了。。\nDay 1 早上有点冷，还有点困。。。也许是因为最近几天都很疲惫。\n考试前愉快假人，很欢乐。\n进考场之后打了打头文件，写了个快读，建了文件夹和源代码。\n然后就开始了。\n一个个看。\nT1 似乎就是个魔改线性筛，稍微想了想就开始写了，然后因为没有完全想清楚折腾了一会才搞好。\n开考将近一个小时的时候过了所有样例，看了一下极限情况，没问题，溜了。\n开局不错。\nT2 是个计数，DP，感觉还得套一下什么玩意，不想思考了，溜了溜了。。。\nT3 似乎可做，稍微思考了一下发现不管怎么变，差值就是那些，操作本质就是交换差值。但是接下来就不会了，于是把这个性质应用一下能得 $20$​ 分。\nT4 暴力是小模拟，然后有一些性质可以写。又思考了一下感觉有点线段树合并的感觉，又感觉可以用时光倒流+并查集水几个性质。\n先乱写了个 T2 的暴力，$0\\sim20$ 分，又写了个 T3 暴力，$20$ 分。\n然后全力肝 T4，写了个 $O(nmq)$ 的暴力，然后发现跑的挺快，但是有样例过不去。。。\n调了半天无果，最后几分钟又写了一个性质。。。\nT4 不知道能得多少分。。。$0\\sim36$，看数据强度了。\n按照平均来估，预计 $100+10+20+12=142$，实际就不知道了。。。\n总结 其实潜意识里也知道 T2 不是特别难，但是我就是不想思考，这种对计数深深的恐惧我不知道是怎么回事，DP 必须要掌握啊，各种 DP 都是。。其实 T2 搞个和状压一样的东西能很轻松水 $50$​ 分。而且真的很简单，我可能就是不想思考了。。。\nT3 不会没办法，T4 没调出来是个巨大的失误。。。其实 T4 认真写暴力能拿到很多很多分。。。至少就有 $44$​，但是我挂的就很莫名其妙。。。\nT4 写挂肯定有运气原因（因为真不难），但当时确实就是莫名写挂了，还是太菜了。。。\n后来发现当时真是有点上头，T2 暴力码量肯定不大，结果去莽码量巨大的 T4 了。。。有勇无谋了属于是。\n其实那个 DP 真的很简单，没想出来是不是因为过于害怕 DP 了。。。\n后话 实在没忍住，到民间数据测了一下 T1，没挂，那就没事了。\n我放心了，安心等官方成绩。\n","permalink":"https://luoyisu.github.io/posts/noip2021/","summary":"\u003ch1 id=\"noip2021\"\u003eNOIP2021\u003c/h1\u003e\n\u003cp\u003e凄凉。\u003c/p\u003e","title":"NOIP2021 游记\u0026总结"},{"content":"Description 给定一棵树，每个点有一个权值，求每个点所有后代中权值比它大的点的个数。\n$n\\leq10^5$\n不怎么难，就是看对数据结构的掌握程度。。\n算法一 对每个点维护一个权值线段树，从下往上合并，每次合并该结点所有儿子即可。$O(n\\log n)$​​，时间空间常数都很大。\nCode 我觉得指针比数组清晰一些，虽然也伴随着一点小风险（访问空指针）。\n代码还是很清晰的，不难写。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::cout; using std::endl; const int maxn = 1e5 + 10; struct Node { int sum; Node *ls, *rs; Node() : sum(0), ls(nullptr), rs(nullptr) {} void push_up() { sum = (ls == nullptr ? 0 : ls-\u0026gt;sum) + (rs == nullptr ? 0 : rs-\u0026gt;sum); } } a[maxn \u0026lt;\u0026lt; 5], *root[maxn]; int tot; Node *modify(int l, int r, int x, Node *p) { if (p == nullptr) p = \u0026amp;a[++tot]; if (l == r) { (p-\u0026gt;sum)++; return p; } int mid = (l + r) / 2; if (x \u0026lt;= mid) p-\u0026gt;ls = modify(l, mid, x, p-\u0026gt;ls); else p-\u0026gt;rs = modify(mid + 1, r, x, p-\u0026gt;rs); p-\u0026gt;push_up(); return p; } int query(int l, int r, int x, int y, Node *p) { if (p == nullptr) return 0; if (l \u0026gt;= x \u0026amp;\u0026amp; r \u0026lt;= y) return p-\u0026gt;sum; int mid = (l + r) / 2; int res = 0; if (x \u0026lt;= mid) res += query(l, mid, x, y, p-\u0026gt;ls); if (y \u0026gt; mid) res += query(mid + 1, r, x, y, p-\u0026gt;rs); return res; } Node *merge(int l, int r, Node *a, Node *b) { if (a == nullptr) return b; if (b == nullptr) return a; if (l == r) { a-\u0026gt;sum += b-\u0026gt;sum; return a; } int mid = (l + r) / 2; a-\u0026gt;ls = merge(l, mid, a-\u0026gt;ls, b-\u0026gt;ls), a-\u0026gt;rs = merge(mid + 1, r, a-\u0026gt;rs, b-\u0026gt;rs); a-\u0026gt;push_up(); return a; } int ans[maxn], val[maxn], b[maxn], n; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y); } void dfs(int x) { for (int v : e[x]) { dfs(v); root[x] = merge(1, n, root[x], root[v]); } ans[x] = query(1, n, val[x] + 1, n, root[x]); root[x] = modify(1, n, val[x], root[x]); } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;val[i]), b[i] = val[i]; for (int i = 2, x; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;x), add(x, i); std::sort(b + 1, b + 1 + n); for (int i = 1; i \u0026lt;= n; i++) root[i] = \u0026amp;a[++tot], val[i] = std::lower_bound(b + 1, b + 1 + n, val[i]) - b; dfs(1); for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d\\n\u0026#34;, ans[i]); } 算法二 对每个点维护一个平衡树，然后从下向上启发式合并，对每个点查询排名，减一下就是答案。$O(n\\log^2n)$​​，虽然复杂度比较高但常数很小，实际上比上面的线段树合并快 $\\text{70ms}$​。空间没啥常数。\nCode 忽然想起 pb_ds，稍微学了点写了一些。不得不说是真省事，而且红黑树也是真快。（我估计比不少手写 splay/treap 的快）\n这代码就更清晰了（）\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using std::cout; using std::endl; const int maxn = 2e5 + 10; inline bool cmp(int x, int y) { return x \u0026lt; y; } __gnu_pbds::tree\u0026lt;int, __gnu_pbds::null_type, std::less\u0026lt;int\u0026gt;, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update\u0026gt; S[maxn], *root[maxn]; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y); } int n, a[maxn], ans[maxn]; void dfs(int x) { auto mx = root[x]; for (int v : e[x]) { dfs(v); if (root[v]-\u0026gt;size() \u0026gt; mx-\u0026gt;size()) mx = root[v]; } root[x] = mx; for (int v : e[x]) { if (root[v] != root[x]) { for (int it : *root[v]) root[x]-\u0026gt;insert(it); root[v]-\u0026gt;clear(); } } ans[x] = root[x]-\u0026gt;size() - root[x]-\u0026gt;order_of_key(a[x]); root[x]-\u0026gt;insert(a[x]); } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]), root[i] = \u0026amp;S[i]; for (int i = 2, x; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;x), add(x, i); dfs(1); for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d\\n\u0026#34;, ans[i]); } 算法三 搞个 dfs 序出来，然后就变成序列题目，可以用类似逆序对的方法做，树状数组常数很小。\n或者分块，我还看到有主席树的qwq。\n","permalink":"https://luoyisu.github.io/posts/luogu3605/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e给定一棵树，每个点有一个权值，求每个点所有后代中权值比它大的点的个数。\u003c/p\u003e\n\u003cp\u003e$n\\leq10^5$\u003c/p\u003e","title":"洛谷P3605 [USACO17JAN]Promotion Counting P"},{"content":"Description 给定一个仅包含 a~h 的字符串。\n有一个 $n$​​​​ 个结点的无向图，编号为 $0$​​​​​ 到 $n−1$​​​​​​ 结点 $i$​​​ 与结点 $j$​​ 间有边相连当且仅当 $|i-j|=1$​ 或 $S_i=S_j$。\n求这个无向图的直径和有多少对点间的最短距离与直径相同。\n$n\\leq10^5$\nSolution 难是真的难，我看题解才懂，然后写代码时候挂了，又看了代码才过。。。\n是个状压的妙用，思维难度不小。\n先一步一步来。\n很显然一个字母的边最多走一遍（因为走多遍和走一遍效果是一样的，而且不优）。\n那么发现直径最大是 $15$，即 aabbccddeeffgghh 这个字符串，证明就用上面这个结论就行了，很显然。\n然后考虑两点间最短路 $dis(i,j)$​。\n下面记 a~h 为 $8$ 种颜色。分别为 $c_0\\sim c_7$，$f(i,c)$ 表示 第 $i$ 个点到 $c$​ 颜色 的最短路长度，$T$ 为总颜色数。\n想一想之后能得到：$dis(i,j)=\\min(|i-j|,\\min\\limits_{0\\leq k\\leq7}\\{f(i,k)+f(j,k)+1\\})$​​。挺显然的，画个图或者想一想就明白了。\n$f$​ 数组可以枚举颜色然后 BFS 得到，$O(Tn)$，然后最短路直接暴力枚举是 $O(Tn^2)$​ 的，得优化，然后我就不会了。\n接下来就是看题解才会的东西了（）\n看上面那个式子，对于每个点 $i$，在链上往前走 $15$ 个点，这些点到 $i$ 的最短路可能是全在链上，也可能不在，而再往前，就一定要走相同字母连出来的边了。\n于是对于这 $15$ 个点，暴力算一下最短路。\n对于剩下的点，$dis(i,j)=\\min\\limits_{0\\leq k\\leq7}\\{f(i,k)+f(j,k)+1\\}$​。我们枚举点 $i$​ 和颜色 $k$​，需要快速得到前面所有点 $f(j,k)$ 的值以及个数。\n不知道怎么做了，回头看一看有没有什么性质。\n然后就定义 $g(a,b)$​​​ 表示从颜色 $a$​​​ 到颜色 $b$​​​ 的最短路长度。\n发现 $g(c_i,c_j)\\leq f(i,j)\\leq g(c_i,c_j)+1$​​。这个很显然，要么是直接走过去，要么先走到最近的，再走一条相同字符的边。\n变个形，$f(i,j)-g(c_i,c_j)=0/1$。\n那么我们发现每个点对后面答案的贡献只与其颜色和上面的 $f(i,j)$​​ 是两种情况的某一种有关，那么可以把每种颜色的状态作为状态压缩一下，记录每种颜色和这个状态的个数，在每个点枚举所有颜色和状态，就能知道前面所有点 $f(j,k)$​​ 的值对应的个数了。\n这个 $g$ 也在 BFS 时候顺便求一下就行。\n计算一下复杂度，预处理 $O(Tn)$，后面是 $O(T^22^Tn)$，算一下，发现达到了 $10^9$ 级别。2s 时限的话也许能过（？）。\n我直接莽完交的时候最大的点跑了 $\\text{1996ms}$，总时长 $\\text{1.11min}$​，真尬住了。。\n后来加了个剪枝，快多了，最大的点只需要 $\\text{468ms}$​。（见代码）\n似乎有点抽象，上代码（）\nCode 有一些细节，颜色和点别弄混了。。。下标套下标有时候容易出错。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using std::cout; using std::endl; const int maxn = 1e5 + 10, maxt = 8, maxs = 1 \u0026lt;\u0026lt; maxt; char s[maxn]; int f[maxn][maxt + 1], g[maxt][maxt], cnt[maxt][maxs + 10]; int n, t = 8, used[maxt], a[maxn]; std::vector\u0026lt;int\u0026gt; p[maxt]; bool visi[maxn], visc[maxt]; int ans = 0; long long tot = 0; inline void updmi(int \u0026amp;a, int b) { a = std::min(a, b); } inline void updans(int dis, int cnt) { if (cnt == 0) return; if (dis == ans) tot += cnt; else if (dis \u0026gt; ans) ans = dis, tot = cnt; } int main() { scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;n, s + 1); for (int i = 1; i \u0026lt;= n; i++) a[i] = s[i] - \u0026#39;a\u0026#39;, p[a[i]].push_back(i); memset(f, 1, sizeof(f)), memset(g, 1, sizeof(g)); std::queue\u0026lt;int\u0026gt; q; for (int i = 0; i \u0026lt; t; i++) { memset(visi, 0, sizeof(visi)), memset(visc, 0, sizeof(visc)); g[i][i] = 0, visc[i] = 1; for (int v : p[i]) q.push(v), visi[v] = 1, f[v][i] = 0; while (!q.empty()) { int now = q.front(); q.pop(); if (now \u0026gt; 1 \u0026amp;\u0026amp; !visi[now - 1]) f[now - 1][i] = f[now][i] + 1, visi[now - 1] = true, q.push(now - 1); if (now \u0026lt; n \u0026amp;\u0026amp; !visi[now + 1]) f[now + 1][i] = f[now][i] + 1, visi[now + 1] = true, q.push(now + 1); if (!visc[a[now]]) { visc[a[now]] = 1, g[a[now]][i] = f[now][i]; for (int v : p[a[now]]) if (!visi[v]) f[v][i] = f[now][i] + 1, visi[v] = true, q.push(v); } } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = std::max(1, i - 15); j \u0026lt; i; j++) { int dis = i - j; for (int c = 0; c \u0026lt; t; c++) updmi(dis, f[j][c] + f[i][c] + 1); updans(dis, 1); } if (i \u0026gt; 16) { int nowst = 0; for (int j = 0; j \u0026lt; t; j++) nowst = (nowst \u0026lt;\u0026lt; 1) | (f[i - 16][j] - g[a[i - 16]][j]); cnt[a[i - 16]][nowst]++; for (int j = 0; j \u0026lt; t; j++) { for (int k = 0; k \u0026lt; (1 \u0026lt;\u0026lt; t); k++) { if (cnt[j][k] == 0) // 此处剪枝优化是很大的。 continue; int dis = 1 \u0026lt;\u0026lt; 30; for (int q = 0; q \u0026lt; t; q++) updmi(dis, f[i][q] + g[q][j] + ((k \u0026gt;\u0026gt; (t - q - 1)) \u0026amp; 1) + 1); updans(dis, cnt[j][k]); } } } } printf(\u0026#34;%d %lld\\n\u0026#34;, ans, tot); } 一点闲话 谁知道如何能想到这个 $g$ 啊，我想不到这个点。。\n","permalink":"https://luoyisu.github.io/posts/cf718e/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e给定一个仅包含 \u003ccode\u003ea\u003c/code\u003e~\u003ccode\u003eh\u003c/code\u003e 的字符串。\u003c/p\u003e\n\u003cp\u003e有一个 $n$​​​​ 个结点的无向图，编号为 $0$​​​​​ 到 $n−1$​​​​​​ 结点 $i$​​​ 与结点 $j$​​ 间有边相连当且仅当 $|i-j|=1$​ 或 $S_i=S_j$。\u003c/p\u003e\n\u003cp\u003e求这个无向图的直径和有多少对点间的最短距离与直径相同。\u003c/p\u003e\n\u003cp\u003e$n\\leq10^5$\u003c/p\u003e","title":"CF718E"},{"content":"概述 啥都不会，滚出。\n期望 $0+100+0+20=120$，实际 $0+20+0+20=40$​。至于为什么挂了这么多，看下文。\n赛时 T1 概率+博弈论，再见吧。。。\nT2 看着也不简单。\nT3 计算几何？？？？？\nT4 又是个什么鬼玩意？？？？？？\n稍微思考了一下除了 T2 以外的题，似乎都不可做。\n那没啥说的，做 4h T2吧。\n于是开始做。\n分类呗，6个木条正方形，1122 或者 1113。\n1122 很快就搞出来了，双指针随便算一下就行。\n这个 1113 就很离谱。。。。\n随便搞了搞之后发现会算重复。。。。\n想了很久，忽然意识到去重不是容斥原理干的事吗。。。\n于是开始往死里容斥。\n想了很久可算是搞出来了，过了几组手造小数据。也不想对拍了，随便吧。。。\n又发现 T4 有 $20$ 分是个斐波那契，给写了。\nT3 其实也能写点暴力，但我不想思考也不想打代码了，就这样吧。。。\n感觉四道全是数学题。。。\n赛后 我吐了，我 T2 忘记自己拷贝的一个数组没有排序了。。。导致 $90$ 挂成了 $20$​，再在两个地方开 long long 就 $100$ 了。。。\n结果我挂成了和最暴力的暴力一个分，我吐了。。。\n总结 没啥好总结的，也许 T3 暴力还是应该想想怎么做。。。。\nemmmm，其实 T1 不是那么难——遇到最大最小值可以考虑转化成函数然后三分。但我确实不会。。。\nT3、4 都是我不懂的知识，告辞。\n还是应该对拍，手造数据不靠谱（我手造的数据都是排好序的。。。）\n附专治低血压代码：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using std::cout; using std::endl; const int maxn = 5010, maxi = 1e7 + 10; typedef long long ll; int a[maxn], b[maxi], n, m, t[maxn]; ll C(ll n, ll m) { if (m \u0026gt; n) return 0; ll res = 1; for (int i = n; i \u0026gt;= n - m + 1; i--) res *= i; for (int i = m; i \u0026gt;= 2; i--) res /= i; //cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return res; } bool ok[maxi * 2]; ll work1() { ll res = 0; for (int i = 1; i \u0026lt;= m; i++) { if (b[a[i]] \u0026gt;= 2) { ll cnt = 0, tot = 0; // cnt 对数；tot 总数 for (int l = 1, r = i - 1; l \u0026lt;= r; r--) { while (l \u0026lt;= r \u0026amp;\u0026amp; a[r] + a[l] \u0026lt; a[i]) l++; if (l \u0026gt; r || a[l] + a[r] != a[i]) continue; if (l == r) { tot += C(b[a[l]], 4); tot += C(b[a[l]], 2) * cnt; break; } if (b[a[l]] \u0026gt;= 2 \u0026amp;\u0026amp; b[a[r]] \u0026gt;= 2) tot += C(b[a[l]], 2) * C(b[a[r]], 2); tot += b[a[l]] * b[a[r]] * cnt; cnt += b[a[l]] * b[a[r]]; } //if (tot != 0) //cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; tot \u0026lt;\u0026lt; endl; res += C(b[a[i]], 2) * tot; } } return res; } int mp[maxi + 50]; /* 1 2 3 得到 6 -\u0026gt; 重复计算 3 次 total = 全部 - 有两个相同 + 三个相同(1) */ ll work2() { //for (int i = 1; i \u0026lt; m; i++) // for (int j = i + 1; j \u0026lt;= m; j++) // if (a[i] + a[j] \u0026lt; maxi) // cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[j] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b[a[i]] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b[a[j]] \u0026lt;\u0026lt; endl, mp[a[i] + a[j]] += b[a[i]] * b[a[j]], ok[a[i] + a[j]] = 1; //for (int i = 1; i \u0026lt;= 6; i++) // cout \u0026lt;\u0026lt; mp[i] \u0026lt;\u0026lt; endl; ll res = 0; for (int i = 1; i \u0026lt;= m; i++) { if (b[a[i]] \u0026gt;= 3) { int tot = 0; // 1 for (int j = 1; j \u0026lt;= n; j++) { if (t[j] \u0026gt; a[i]) break; // 把此处 break 改为 continue 可获得 90 分 int d = 0; // 2 if (t[j] * 2 \u0026lt;= a[i]) { d = b[a[i] - t[j] * 2]; if (t[j] * 3 == a[i]) d--; } tot += mp[a[i] - t[j]] - d; } // 再把上方 1 2 都改为 long long 可获得 100 分 res += tot / 3 * C(b[a[i]], 3); } } return res; } int main() { freopen(\u0026#34;stick.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;stick.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]), b[a[i]]++, t[i] = a[i]; // 写这个代码的人，数组 t 你没排序啊！！！ for (int i = 1; i \u0026lt; n; i++) for (int j = i + 1; j \u0026lt;= n; j++) if (a[i] + a[j] \u0026lt; maxi) mp[a[i] + a[j]]++; std::sort(a + 1, a + 1 + n); m = std::unique(a + 1, a + 1 + n) - a - 1; //for (int i = 1; i \u0026lt;= m; i++) // cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b[a[i]] \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; endl; printf(\u0026#34;%lld\\n\u0026#34;, work1() + work2()); return 0; } ","permalink":"https://luoyisu.github.io/posts/211116%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e啥都不会，滚出。\u003c/p\u003e\n\u003cp\u003e期望 $0+100+0+20=120$，实际 $0+20+0+20=40$​。至于为什么挂了这么多，看下文。\u003c/p\u003e","title":"211116模拟赛"},{"content":"所谓可并堆，就是可以合并的堆。\n本文介绍配对堆和左偏树。\n未完工。\n什么是可并堆 什么是堆我就不解释了。\n上面说了，可并堆就是可以合并的堆。\n最基础的操作有：快速查询最大/最小值、插入一个值、删除最大/最小值、合并两个堆。\n如果用二叉堆的话，可以在 $O(\\log^2n)$​​ 的复杂度内启发式合并堆，但下文说的两个数据结构可以更快地实现。\n配对堆 配对堆，英文 pairing heap。配对堆，顾名思义就是两两配对的堆。\n其复杂度都是势能分析后的均摊的结果，所以不能可持久化。\n声明：这个数据结构的复杂度我不会证明。\n定义 配对堆是一个多叉树，每个点有一个权值，满足每个点的权值都小于其所以儿子的权值。（注：本文只考虑小根堆）\n存储的时候使用孩子兄弟表示法，即对每个点记录他的最左面的儿子，以及他右面的兄弟。\nstruct Node { int val; Node *son, *bro; }; 查询最小值 返回根的权值即可。$O(1)$​。\n合并 把根权值较大的堆变为另一个堆的一个儿子即可。（画个图就知道代码非常显然了）\nNode *merge(Node *a, Node *b) // 传入两个堆的根，返回合并后堆的根 { if (a == nullptr) // 如果有一个是空节点，直接返回另一个 return b; if (b == nullptr) return a; if (a-\u0026gt;val \u0026gt; b-\u0026gt;val) // 保证 a 是合并后堆的根 swap(a, b); b-\u0026gt;bro = a-\u0026gt;son; // a 儿子要变为 b 的兄弟 a-\u0026gt;son = b; // a 儿子变为 b return a; } 单次显然是 $O(1)$，势能分析后仍然是 $O(1)$。\n插入 把这个数看成一个堆然后和原堆合并即可。\n删除最小值（重点） 考虑删除之后，我们需要把一个森林合并成一个树。\n我们显然可以把儿子任意一个一个合并，但会导致复杂度退化到 $O(n)$​。\n于是有一个很乱搞的优化：将两个堆从左往右两两合并，再从右往左依次合并，复杂度会均摊为 $O(\\log n)$。\n搞一个函数来合并一个点的所有兄弟：\nNode *merges(Node *x) // 输入根，返回合并后的根 { if (x == nullptr || x-\u0026gt;bro == nullptr) return x; Node *a = x-\u0026gt;bro, *b = a-\u0026gt;bro; x-\u0026gt;bro = a-\u0026gt;bro = nullptr; // 拆散 return merge(merge(x, a), merges(b)); } 不太好形容，画了个图：\n需要注意的是：该递归实现已经满足了顺序要求，如果要修改成非递归，要注意顺序。\n于是删除实际上非常简单：\nNode *pop() { return root = merges(root-\u0026gt;son); } 删除给定结点 注：下文我没有进行过测试，是我口胡的产物。\n首先对一个点记录他的前一个结点 father（不是树形结构的父亲），然后操作都需要稍微修改一下来维护这个东西。\n接着把这个点对应的子树分离出来，然后执行 pop 操作，最后和原树合并一下。\n不怎么好实现，不建议，而且时间复杂度感觉并不是很好。\n左偏树 待填。\n","permalink":"https://luoyisu.github.io/posts/mergeable-heap/","summary":"\u003cp\u003e所谓可并堆，就是可以合并的堆。\u003c/p\u003e\n\u003cp\u003e本文介绍配对堆和左偏树。\u003c/p\u003e\n\u003cp\u003e未完工。\u003c/p\u003e","title":"可并堆学习笔记"},{"content":"概述 啥都不会。\n期望 $0+0+20+20=40$​，实际没挂分。\n赛时 T1 数学题，推了推并打表无果，跳（我居然根据打的表能回忆起来平方和公式？？？）；\nT2 不知道是什么题，像是乱搞题，但没搞出来，跳；\nT3 又是个计数的DP，似乎有点结论之类的，不太懂，跳；\nT4 根本不懂，跳。\n然后发现啥都不会，试图做 T1，无果。\n发现 T3 有 $20$ 分全排列暴力，写了；\n又发现 T4 乱搞能得 $20$ 分，也写了。\n尝试做 T2，不太懂，乱写了份代码交上去。\n接着去做 T1，还是不懂。\n直接跑路。。。。\n赛后 发现 T1 真是个数学题，，，，不会就是不会。。。\nT2 确实是个乱搞，没想出来其实亏了（可能是被这题得分取所有测试点最小值打压了积极性）。\nT3 题解看起来比我想的简单一点，但还是不会。\nT4 不会，做题的时候想到题解的第一步（查分约束之前）就想不下去了。\n总结 面对啥都不会的比赛，首先心态要好（）\n默念我不会大家也不会（虽然这很可能是错觉）\n然后把简单的暴力写完之后可以冲着最可做的题一直莽下去，感觉也只能这么办了（比如今天 T2，如果往死里想未必就想不出来）\n","permalink":"https://luoyisu.github.io/posts/211114%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e啥都不会。\u003c/p\u003e\n\u003cp\u003e期望 $0+0+20+20=40$​，实际没挂分。\u003c/p\u003e","title":"211114模拟赛"},{"content":"概述 期望 $100+100+40+0=240$，实际同期望，难得没有挂分。。。\n赛时 有上一次的经验，应该是按难度升序排列。\n先看 T1，这种给个字符串，然后来一堆莫名其妙的操作，再问你最后字符串的题大部分都是降智题（因为我上次就被降智了），我尝试切掉。\n花几分钟写了个暴力找规律，然后发现这个规律挺对的，看到数据范围 $5\\times10^5$​，也不想着优化了，写了个普通快读，直接 sort 就完事了。\n想对拍，然后发现自己不会生成随机字符串，有点尴尬，去看下一道题了。\nT2 数学题。俗话说得好：遇到数学先打表。然后我就光速用 python 打了个 $n\\leq5000$ 的表。\n对着表来回折腾没看出来啥，先跳了。\n看 T3，不明所以的 DP+计数，去看 T4，不明所以的 DP+计数。\n一看到取模就头疼。\n回来看 T2 了。\n注意到对于一组解 $(x,y)(x\u0026lt;y)$，还存在另一组解 $(y,z)(y\u0026lt;z)$。于是考虑怎么从这组解得到下一组。\n还是不懂，把打表的内容增加了一列 $k$，发现这两组解的 $k$ 相同。。。\n于是意识到这是个二次方程的两个根。\n于是会做了：把解一个一个算出来，把较大数不超过 $10^{18}$ 的所有解存下来，每个询问二分查找一下就行。\n然后写了个程序，过样例之后忽然意识到爆 long long 的问题。\n我不是很懂爆 long long 到底会发生什么，不太放心，于是写了个 __int128_t。。。\n发现两个程序输出还真不一样，折腾了一下不知道怎么回事，就把 __int128_t 的程序交上去了。。。\n这时候才过去 $\\text{1.5h}$，感觉机会很大（）\n去看 T3，愣是不会。。。。去看 T4，似乎要套容斥然后各种计数，不想搞。。。\n然后开始躺平。\n后来主要去想 T3 了，但还是没想出来。T4 暴力也不会。\n看还有半个多小时，写了 T3 的指数级 $30$ 分暴力，然后打表发现有 $10$ 分是卡特兰数，就顺便骗走了。\n然后就跑路。。。\n赛后 没啥可说的，和想的差不多，T4 没有输出大样例导致少了 $10$ 分，又忘记骗分了。。。\n发现 T3 有结论，T4 还是不懂。。。\n看到别人 T2 $60$ 分忽然意识到表可以打得大一些，毕竟解不是很多（用C语言打，打到 $10^5$ 应该没问题），不过打小表还是 python 强。\n附 python 打表代码，，，，\nfor i in range(1, 5001): for j in range(1, 5001): if (i * i + j * j) % (i * j + 1) == 0 and i \u0026lt;= j: print(i, j, (i * i + j * j) / (i * j + 1)) 总结 DP 实在太差了！！！尤其是计数。。。。一生之痛。。。。\n数学题打表确实很重要。\n不能被降智（指奇怪的字符串题）。\n","permalink":"https://luoyisu.github.io/posts/211113%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e期望 $100+100+40+0=240$，实际同期望，难得没有挂分。。。\u003c/p\u003e","title":"211113模拟赛"},{"content":"Description 给一个无向图，$n$​​​ 个点 $m$​​ 条边，给定一个 01 序列，如果 $a_i=1$​，要求走到这个点奇数次，否则，要求走到这个点偶数次，请你任选起点，输出满足要求的经过点的序列和序列长度，序列长度不能超过 $4n$。\nSolution 没思路的时候看到 CF 标签上的 \u0026ldquo;DFS\u0026rdquo;，于是考虑乱搞，然后就搞出来了。\n首先任选一个要求走奇数遍的一个点进行 DFS。我们先不考虑图的形状，找一棵 DFS 树出来，然后遍历，如果回溯的时候发现这个点的奇偶性不对，我们走到它的父亲，再走回来，这样奇偶性就对了。然后一算：遍历 $2n$，处理一个奇偶性错误需要走 $2$ 个点，上界 $4n$​，于是这道题就做完了。\n注意到不一定是个联通图，那么考虑如果一个联通块内全是偶数，我们直接不走即可；如果存在奇数，那么必须走。\n那么当有超过一个联通快内有奇数时，无解。\n小问题：如果选择的根奇偶性不对，我们先正常改，然后把答案减掉 $3$ 即可（即不走回到根节点）。\nCode 存答案的时候建议用 vector 而不是数组，我一开始忘记了 $4n$ 这回事导致 RE。\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; int a[maxn], ans[maxn * 4], father[maxn], vis[maxn], m, n, now[maxn]; int cnt = 0; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } void dfs(int x, int fa) { vis[x] = 1, father[x] = fa; ans[++cnt] = x, now[x] ^= 1; for (int v : e[x]) { if (vis[v]) continue; dfs(v, x); ans[++cnt] = x, now[x] ^= 1; } if (now[x] != a[x]) { ans[++cnt] = fa; ans[++cnt] = x; now[x] ^= 1, now[fa] ^= 1; } } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0, x, y; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y, add(x, y); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) if (a[i] == 1) { dfs(i, 0); break; } for (int i = 1; i \u0026lt;= n; i++) if (!vis[i] \u0026amp;\u0026amp; a[i]) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } if (ans[cnt - 1] == 0 \u0026amp;\u0026amp; cnt \u0026gt;= 3) cnt -= 3; cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= cnt; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; (i == cnt ? \u0026#34;\\n\u0026#34; : \u0026#34; \u0026#34;); } ","permalink":"https://luoyisu.github.io/posts/cf453c/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e给一个无向图，$n$​​​ 个点 $m$​​ 条边，给定一个 01 序列，如果 $a_i=1$​，要求走到这个点奇数次，否则，要求走到这个点偶数次，请你任选起点，输出满足要求的经过点的序列和序列长度，序列长度不能超过 $4n$。\u003c/p\u003e","title":"CF453C"},{"content":"Description 一个竞赛图的度数集合是由该竞赛图中每个点的出度所构成的集合。 现给定一个 $m$ 个元素的集合，第 $i$ 个元素是 $a_i$。判断其是否是一个竞赛图的度数集合,如果是，找到点数最小的满足条件的竞赛图。\n$1\\le m\\le 31$，$0\\le a_i\\le 30$，$a_i$ 互不相同。\nSolution 这题好难啊，参考了别人的题解\u0026amp;代码。\n首先，题目中提到的兰道定理：将出度数组 $d$ 升序排序。$1≤i≤n$​​ 时，$\\sum^i_{j=1}d_i\\leq \\dfrac{i(i−1)}{2}$​。当且仅当 $i=n$ 时取等。\n这可以用来判定竞赛图。\n然后在本题中，套进去，可以得到 $n_{max}=61$。\n然后考虑得到点数以及每个点的出度——跑一个完全背包。\n$f(i,j,k)$ 表示集合中前 $j$ 个元素能否构成一个 $i$ 个点 $k$ 条边的竞赛图。\n转移非常简单，$f(i,j,k)=f(i-1,j,k-a_j) \\operatorname{or}f(i-1,j-1,k-a_{j-1})$。\n实际转移用刷表更好写。\n然后 DFS 回溯一下，可以得到每个点的出度。\n接下来是如何构造竞赛图：\n有一个比较贪心的思路：每次找一个剩余出度最少的点，向其他点依次连边，直到剩余出度为 $0$，接着让没被连边的点和它连一条边，最后删掉这个点。\n正确性感性理解即可，还算直观。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 61, maxm = 1832; int f[maxn + 3][maxn + 3][maxm + 3]; int pos[maxn + 3][maxn + 3][maxm + 3]; int n, a[maxn + 3], ans[maxn + 3]; void find_ans(int i, int j, int k) { if (i == 0) return; ans[i] = a[j], k -= a[j]; if (f[i - 1][j][k]) find_ans(i - 1, j, k); else find_ans(i - 1, j - 1, k); } bool cmp(int x, int y) { return ans[x] \u0026lt; ans[y]; } int e[maxn + 3][maxn + 3]; int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; std::sort(a + 1, a + 1 + n); f[1][1][a[1]] = 1; for (int i = 1; i \u0026lt;= maxn; i++) for (int j = 1; j \u0026lt;= n; j++) for (int k = i * (i - 1) / 2; k \u0026lt;= maxm; k++) if (f[i][j][k]) f[i + 1][j][k + a[j]] = f[i + 1][j + 1][k + a[j + 1]] = 1; int res = 0; for (int i = n; i \u0026lt;= maxn; i++) if (f[i][n][i * (i - 1) / 2]) { res = i; break; } if (!res) { cout \u0026lt;\u0026lt; \u0026#34;=)\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; find_ans(res, n, res * (res - 1) / 2); int pos[maxn]; for (int i = 1; i \u0026lt;= res; i++) pos[i] = i; for (int i = 1; i \u0026lt;= res; i++) { std::sort(pos + i, pos + 1 + res, cmp); for (int j = i + 1; j \u0026lt;= i + ans[pos[i]]; j++) e[pos[i]][pos[j]] = 1; for (int j = i + ans[pos[i]] + 1; j \u0026lt;= res; j++) e[pos[j]][pos[i]] = 1, ans[pos[j]]--; } for (int i = 1; i \u0026lt;= res; i++, cout \u0026lt;\u0026lt; endl) for (int j = 1; j \u0026lt;= res; j++) cout \u0026lt;\u0026lt; e[i][j]; return 0; } ","permalink":"https://luoyisu.github.io/posts/cf850d/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e一个竞赛图的度数集合是由该竞赛图中每个点的出度所构成的集合。 现给定一个 $m$ 个元素的集合，第 $i$ 个元素是 $a_i$。判断其是否是一个竞赛图的度数集合,如果是，找到点数最小的满足条件的竞赛图。\u003c/p\u003e\n\u003cp\u003e$1\\le m\\le 31$，$0\\le a_i\\le 30$，$a_i$ 互不相同。\u003c/p\u003e","title":"CF850D"},{"content":"两道CF题。\nCF483C Description 构造一个长度为 $n$ 的排列，使得集合 $\\{|p_i-p_{i+1}|\\}$ 的大小为 $k$。$n\\leq10^5$。\nSolution 构造题，乱搞。\n考虑大小是 $1$ 非常好构造，$1,2,3,4,\u0026hellip;,n$。（似乎没啥用）\n于是考虑构造集合中元素是 $1,2,\u0026hellip;,k$ 的一个排列。注意到 $n$ 很大的时候可以让差全部为 $1$，所以在前面构造一下就行。\n即前两个数差为 $k$，第二个和第三个差为 $k-1$，以此类推（\n手算：大小是 $2$ 可以用以下方式简单构造 $1,3,2,4,5,6,\u0026hellip;,n$，大小是 $3$ 也很简单：$1,4,2,3,5,6,\u0026hellip;,n$。\n然后构造一个 $1,k+1,2,k,3,k-1\u0026hellip;$ 的排列就好了，具体实现还是用的差递减来构造。（话说这个构造很眼熟啊，似乎和洛谷上一道构造题的第一问很像）\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using std::cin; using std::cout; using std::endl; const int maxn = 1e5 + 10; int n, k; int a[maxn]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; a[1] = 1; int i; for (i = 2; k \u0026gt;= 1; k--, i++) { if (i \u0026amp; 1) a[i] = a[i - 1] - k; else a[i] = a[i - 1] + k; } for (; i \u0026lt;= n; i++) a[i] = i; for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } CF508D Description 给出 $n$ 个长度为 $3$ 的字符串，求一个长度为 $n+2$ 的字符串，使其所有长度为 $3$ 的子串能与给定串一一对应。$n\\leq10^5$。\nSolution 这个模型以前见过，只需要搞欧拉路即可。（已经当定理背下来了）\n要硬说的话，会想到两种建模：每个单词作为顶点，然后在点之间连有向边，找哈密顿路。这显然不行。。。\n然后就是很好的建模了，把每个字母作为点，单词作为有向边，这样就变成找欧拉路，能高效求解。。。\n这个模型目前还没见到其他应用，不过也记下来，万一有用呢。。。\n回到本题，把两个字符当成一个点就行。\n坑点：这题有大小写字母，还有数字，注意 ASCII 码的顺序：数字\u0026lt;大写字母\u0026lt;小写字母。我懒得写正经哈希，就直接乱搞了，不注意 ASCII 码顺序就容易 RE。。。\nCode 我代码又慢又丑。。。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using std::cin; using std::cout; using std::endl; using std::string; const int maxn = 100000; inline int change(char a, char b) { return (a - \u0026#39;0\u0026#39;) * 100 + (b - \u0026#39;0\u0026#39;); } inline string p(int x) { string s = \u0026#34; \u0026#34;; s[1] = char(x % 100 + \u0026#39;0\u0026#39;); s[0] = char(x / 100 + \u0026#39;0\u0026#39;); return s; } int rd[maxn], cd[maxn]; std::vector\u0026lt;int\u0026gt; e[maxn]; inline void add_(int x, int y) { e[x].push_back(y), rd[y]++, cd[x]++; } inline void add(const string \u0026amp;x) { add_(change(x[0], x[1]), change(x[1], x[2])); } std::stack\u0026lt;int\u0026gt; ans; int n; void dfs(int x) { while (e[x].size()) { int v = e[x].back(); e[x].pop_back(); dfs(v); } ans.push(x); } int main() { std::ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { string s; cin \u0026gt;\u0026gt; s; add(s); } int cnt1 = 0, cnt2 = 0, ok = 1; int u = -1; for (char c = \u0026#39;0\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++) for (char c2 = \u0026#39;0\u0026#39;; c2 \u0026lt;= \u0026#39;z\u0026#39;; c2++) { int x = change(c, c2); if (abs(rd[x] - cd[x]) \u0026gt; 1) { ok = 0; break; } else if (cd[x] - rd[x] == 1) cnt1++, u = x; else if (rd[x] - cd[x] == 1) cnt2++; } if (!(cnt1 + cnt2 == 0 || (cnt1 == 1 \u0026amp;\u0026amp; cnt2 == 1))) ok = 0; if (!ok) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; return 0; } if (u != -1) dfs(u); else { for (char c = \u0026#39;0\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++) for (char c2 = \u0026#39;0\u0026#39;; c2 \u0026lt;= \u0026#39;z\u0026#39;; c2++) if (cd[change(c, c2)]) u = change(c, c2); dfs(u); } if (ans.size() != n + 1) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p(ans.top())[0] \u0026lt;\u0026lt; p(ans.top())[1]; ans.pop(); while (!ans.empty()) { cout \u0026lt;\u0026lt; p(ans.top())[1]; ans.pop(); } cout \u0026lt;\u0026lt; endl; } } ","permalink":"https://luoyisu.github.io/posts/cf483ccf508d/","summary":"\u003cp\u003e两道CF题。\u003c/p\u003e","title":"CF483C\u0026CF508D"},{"content":"概述 期望 $100+100+100+20=320$，实际 $100+100+80+20=300$。没怎么挂。\n赛时 按照计划，打算把每道题都想一想。\n于是看到 T1，是个数学题，尝试乱推无果，注意到 $n\\leq 10^{18}$，那就有趣了，往矩阵快速幂上靠（（（\n然后稍微一推发现是个带水题，直接开写。\n然后矩阵板子写挂了，然后发现是构造函数没 memset，改完就过样例了。时间还有，写了个线性递推来对拍。差不多在开始考试将近一个小时时搞好了。\n去看 T2，完全图三元环，正着乱搞无果，于是考虑转化，用所有减去不合法。\n所有的三元环随便就推+找规律蒙出来了，然后不合法的乱推了一下找找规律似乎也找出来了。快速写完，然后写了个 $O(n^3)$​ 暴力对拍。没拍出来错误，放心了（\n然后发现 T1 拍出来问题了，仔细一看是正解的特判 $n=1$ 和 $n=2$ 的情况写反了，我谔谔，赶忙改过来，然后接着拍 $n=1\\sim5$，没啥问题，放心了（\n这时候才过去两个小时，感觉优势很大（（（\nT3 不是很好做，T4 更不懂，都没读懂题更别说暴力了。\n先莽 T3，想了很久，找规律发现实际上只需要选择 $n+m-1$ 个点，然后想到了一个大概是 $O(nm(n+m)\\log (nm))$ 的纯粹乱搞做法，这个能过 $50$​ 分。\n看时间很充裕，接着想正解（（（\n瓶颈在找点上，再优化一下，想了一个莫名其妙的做法：直接把所有点都加到堆里，然后取出来看这一行和这一列有没有必要选，可以 $O(nm\\log(nm))$​​，想过有点悬，然后发现这个做法取出来判断不是很好实现，又画了画图发现选一个点实际上就是在行和列之间加边。。。\n那不如直接枚举行和列，就能搞到 $O((n+m)^2)$​。。。。\n写完之后也不想写暴力了，分数应该还算可以，想莽一下 T4。\n然后思考许久发现我是真不会。。。。。\n注意到有 $20$ 分是 $n\\leq8$，于是花了 $20\\text{min}$ 手算了一波跑路了。。。。\n赛后 T3 MLE 挂了 $20$​ 分，看来 long long 不能随便用啊= =，还好没爆零，这必须得注意。。\n然后发现会TLE，需要稍微卡卡常（取模，long long）\n发现 T4 大数据中有一个是样例，我没输出，于是没拿到这 $10$​ 分。。。\n发现 T3 是个最小生成树，第二次遇到这种题了，得注意对这种怪异题目的图论建模+套算法。\nT4 真不会，不冤。。。\n总结 该骗分还是得骗分，不骗白不骗。。。\n空间得算准了。。。。。。。。\n这次没爆零还算可以，但是要是有一天因为 MLE 爆零，那我估计就得难受死了。。。。。\n换句话说，对于空间复杂度和时间复杂度都是 $O(n^2)$​ 的算法，要注意空间的问题，毕竟此类题目一般 $n=5000$​​，很容易 MLE。。。\n要注意 vector 的空间常数，存完全图时不如邻接矩阵。\n当复杂度逼近 $10^8$ 时要注意常数。如果可能，减少取模以及 long long 的使用。\n今天因为想正解比较顺利，没有怎么写暴力，不过看来对拍还是很重要的。。。\n莫名其妙题目的图论建模！不管是转化为图论模型还是补集转化，总之转化思想很重要。。。\n","permalink":"https://luoyisu.github.io/posts/211109%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e期望 $100+100+100+20=320$，实际 $100+100+80+20=300$。没怎么挂。\u003c/p\u003e","title":"211109模拟赛"},{"content":"概述 不说了，非常凄凉。。。\n感觉今天可以被认为是个小转折点，于是多写点（（（（（\n赛时 T1 不会，T2 有点感觉，T3 能写暴力，T4 不是很懂。\n写了个 T3 暴力背包DP，感觉能优化，稍微想了想无果，于是扔了。\n转过头看 T2，发现有个 $O(n^2)$ 暴力 DP 很好写，但是我想到了一个很假的贪心，就直接去莽了，结果花费了大量的时间。\n去看 T4，有点心烦意乱没法好好分析它的程序，随手写了个暴力走人。\n又去 T1，乱搞能搞出来 $30$ 分暴力，不过不怎么好写，就去想正解了。\n觉得就是找空盘搞 DP，就开始思考正解，但我实在是不擅长这种题，不会啊啊啊啊啊。\n发现没有时间了，转手写了个 $10$ 分暴力跑路。\n然后发现时间严重不足，T2 的暴力没时间写了。。。\n就这么很悲凉地结束了。\n总结 暴力该写还是得写，比如 T2。。。尤其是不花费什么时间的时候——我已经调完了哈希判回文串，只需要套个 DP 上去就能改造成 $O(n^2)$ 暴力水过去 $60$ 分。\n实际上 T2 比较偏结论，我往这方面思考过，但是没有发现真正的性质，还是不够深入啊。\nT3 暴力写的也有点慢了。。。思考深度不够，其实正解思路不是特别复杂。仍然是 DP 状态的转化。平均值转为和优化为平均值转为与平均值的差。\nT4 把题目理解错了，以为每次修改之后会恢复到原序列，导致完全不需要动脑的 $30$ 分暴力没了。\n同时通过这道题也可以看出，我对这种给定代码判断它在干啥的题很不擅长，也许需要好好总结一下到底应该怎么做。。。\n然后这道题考试时候都没怎么思考，，，连数据范围给的提示都忽略了。。。\nT1 暴力还写挂了，实在是悲剧。。。随手写的，确实是有点心急。事实上 T1 确实是个 DP 类计数，我一看到”方案数“和”取模“就头疼。。。。\n下面再稍微说一下心理吧。\n今天 T3 T2 都有点上头，以为有所谓的“感觉”就上头想切掉，结果 T3 还好，拿到了应有的暴力，T2 就是真没了。。。\n想着切题也许是好的，但实在不能太过于上头，如果同时想到了暴力以及“正解”，尤其是像今天这种二者分歧不是特别大的时候，还是应该先写暴力！两个都写了然后对拍不香吗？？？为什么我总是直接去莽正解了。。。。\n然后是对于题目难度的判断，其实今天 T1 反而是在我的水平看来是比较难的题，我没有判断出来，导致以为自己被“降智”，其实真就是不会。（也没有非常多时间思考）\n按理来说面对不会的题应该写个暴力跑路，但是因为 T1 $30$ 分的暴力不是非常好写，我想到离散化等等，还不一定能过，就去思考正解了，这其实是个错误，遇到这种题也许先混暴力比较好，也能更专心思考。\n有关 T4，得认真分析，数据范围也不能忽略，其实不是那么难。\n每次模拟赛都感觉时间不够，打字慢显然是因素之一——我打字指法一直是完全错误的。。\n再就是对一些基础的东西不熟练吧，比如今天的哈希判回文串，我其实是会的，思想也很好地掌握了，但是打的时候愣是出 bug 了，虽然顺利调出来了但终究是浪费了时间。\n再深挖一下，我暴力和正解很难都写，也许很大的一个原因就是因为自己代码能力差，导致没有时间。。。\n以后的比赛必须在暴力和正解之间找一个平衡，比如说一道题分配一些时间，时间到了之后就去写当时能想到的最高分，如果想了正解就很有必要打暴力对拍；或者说除了考虑最高分，还考虑时间的性价比，先写性价比高的分数。以前的模拟赛都没有完全量化时间和分数来写题，感觉以后量化一下也许是个可取的策略。\n至于这个时间具体是多少也许得反复尝试了，平时做题也可以试试？\n","permalink":"https://luoyisu.github.io/posts/211108%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e不说了，非常凄凉。。。\u003c/p\u003e\n\u003cp\u003e感觉今天可以被认为是个小转折点，于是多写点（（（（（\u003c/p\u003e","title":"211108模拟赛总结"},{"content":"Description 给定一个长度为 $n$ 的序列 $\\{a_i\\}$，可以选择一个子序列将其反转，求能获得的最大不下降子序列。\n$n\\leq 50$。\nSolution 观察一下反转的性质，实际上就相当于将这个子序列两边对调，且不会有交错和并列，与区间 DP 能很好地搭配——选择反转两个数，他们之间的区间可以接着反转。\n那么考虑 $f_{i,j}$ 表示区间 $[i,j]$ 的答案，其中只考虑是否反转 $a_i,a_j$。\n考虑如何由小区间得到大区间的解，回忆 LIS 的 $O(n^2)$ 做法，与值有关，那么再加两维状态：$f_{i,j,l,r}$ 表示区间 $[i,j]$，值域 $[l,r]$ 的答案。\n那么就可以方便的转移了。\n首先，大值域显然可以由小值域得来，即 $f_{i,j,l,r}=\\max(f_{i,j,l+1,r},f_{i,j,l,r-1})$。\n为表述方便，记 $[\\text{bool}]=\\begin{cases}1\u0026amp;\\text{if bool = TRUE} \\\\ 0\u0026amp;\\text{if bool = FALSE}\\end{cases}$​​。\n当不反转 $a_i$​​，$a_j$​​ 时，$f_{i,j,l,r}=\\max(f_{i+1,j,l,r}+[a_i=l],f_{i,j-1,l,r}+[a_j=r])$​​。\n当反转 $a_i$，$a_j$ 时，$f_{i,j,l,r}=f_{i+1,j-1,l,r}+[a_i=l]+[a_j=r]$。\n把上面的方程都取个 $\\text{max}$，就得到这个状态的答案了。\n初始状态就把区间长度为 $1$ 的合法状态都设成 $1$ 即可。\n一开始把不相等的情况也考虑进去了，后来发现是错的：不相等的情况在值域扩张的时候会被考虑到，没必要再进行讨论。（其实把细节稍微改一下也能做）\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; const int maxn = 55; int a[maxn], b[maxn]; int f[maxn][maxn][maxn][maxn]; int n; inline void upd_max(int \u0026amp;a, int b) { a = std::max(a, b); } inline int change(bool x) { return x ? 1 : 0; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]), b[i] = a[i]; std::sort(b + 1, b + 1 + n); int tot = std::unique(b + 1, b + 1 + n) - b - 1; for (int i = 1; i \u0026lt;= n; i++) a[i] = std::lower_bound(b + 1, b + 1 + tot, a[i]) - b; // 其实没必要离散化。 for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= a[i]; j++) for (int k = a[i]; k \u0026lt;= tot; k++) f[i][i][j][k] = 1; // DP的顺序需要考虑一下 for (int len = 2; len \u0026lt;= n; len++) { for (int i = 1; i \u0026lt;= n; i++) { int j = i + len - 1; if (j \u0026gt; n) continue; for (int len2 = 1; len2 \u0026lt;= tot; len2++) { for (int l = 1; l \u0026lt;= tot; l++) { int r = l + len2 - 1; if (r \u0026gt; tot) continue; if (l != tot) upd_max(f[i][j][l][r], f[i][j][l + 1][r]); upd_max(f[i][j][l][r], f[i][j][l][r - 1]); upd_max(f[i][j][l][r], f[i + 1][j][l][r] + change(a[i] == l)); upd_max(f[i][j][l][r], f[i][j - 1][l][r] + change(a[j] == r)); upd_max(f[i][j][l][r], f[i + 1][j - 1][l][r] + change(a[i] == r) + change(a[j] == l)); } } } } printf(\u0026#34;%d\\n\u0026#34;, f[1][n][1][tot]); } ","permalink":"https://luoyisu.github.io/posts/luogu3607/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e给定一个长度为 $n$ 的序列 $\\{a_i\\}$，可以选择一个子序列将其反转，求能获得的最大不下降子序列。\u003c/p\u003e\n\u003cp\u003e$n\\leq 50$。\u003c/p\u003e","title":"luogu3607 [USACO17JAN]Subsequence Reversal P"},{"content":"概述 预计 $100+100+0+20=220$，实际 $50+0+0+0=50$，挂成傻逼了。\n赛时 T1 傻逼题，几分钟就切了。\nT2 一眼想了个貌似能过的做法，写完跑路了。\nT3 不懂。\nT4 能想一个 $O(n^3k)$ 的做法，不是很想写了\u0026hellip;\n状态太差了，于是就这么躺平了（（（\n赛后 T1 写挂了，实在是惨，因为题目过于水有点大意了。。。\nT2 发现我复杂度分析错了以为能拿 $100$ 分，于是因为数组开大光荣由 $80\\rightarrow0$。。。\nT4 CE 了。\n总结 虽然是老生常谈了，没有足够强的大样例时还是应该自己造数据/对拍。\n分析复杂度一定要准确，不能一边梦游一边分析，更不能因此开大数组爆零！！\n写完代码一定要编译！！！！\n","permalink":"https://luoyisu.github.io/posts/211104%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%8C%82%E5%88%86%E8%AE%B0/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e预计 $100+100+0+20=220$，实际 $50+0+0+0=50$，挂成傻逼了。\u003c/p\u003e","title":"211104模拟赛挂分记"},{"content":"概述 期望 $0+100+0+70=170$，实际 $0+100+0+50=150$。还可以。\n被 SHR 神吊打了qwq。\n赛时 试图做 T1 发现不会，像个 DP，果然我 DP 不行。\nT2 似乎是个傻逼题，但是我又不会，于是打了个 $O(n^4)$ 暴力，然后造了几组 $n=500$ 的极限数据，发现跑的时间只需要 $\\text{0.03s}$，想了想不知道怎么卡掉，觉得似乎能玄学 AC？\nT3 不会，感觉是个 DP。\nT4 想了想贪心，写了个暴力，但是挂成傻逼了，调了很久。\n然后试图套个数据结构优化成正解，套失败了。。。\n然后 T1 的 $20$ 分阶乘暴力也没写。\n跑路跑路跑路。\n赛后 发现 T2 我暴力碾标算，太离谱了，不会分析复杂度（（（（（\n于是发现 T3 是个二分+模拟，没发现可太惨了（（（（（\nT4 调不动了（（（\n总结 不能被降智啊啊啊，不会的题还是快速写个暴力比较好。\n","permalink":"https://luoyisu.github.io/posts/211031%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e期望 $0+100+0+70=170$，实际 $0+100+0+50=150$。还可以。\u003c/p\u003e\n\u003cp\u003e被 SHR 神吊打了qwq。\u003c/p\u003e","title":"211031模拟赛"},{"content":"概述 本校出题。\n期望 $100+100+0+0=200$，实际 $100+0+0+0=100$​。\n赛时 T1 看了好久才懂，T2 是个分层图次短路，赶快写完跑路了。\nT3 很怪的 DP，不会，有点神仙。\nT4 只会暴力，不太想写。\n发现 T1 实际上的问题是比较简明的，是个推式子题。\n打完 T2，大力找了 T1 的规律，然后也没证明就跑路了。（还好规律简单）\n总结 T2 爆零了，果然还是不会次短路和分层图，学习ing。\nT4 是个结论题，学习了。\nT3 这种难度的 DP 我还是做不出来，DP 好难啊qwq。\n不过 T1 打表猜结论是好的，如果我会证明就更好了（\n","permalink":"https://luoyisu.github.io/posts/211028%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e本校出题。\u003c/p\u003e\n\u003cp\u003e期望 $100+100+0+0=200$，实际 $100+0+0+0=100$​。\u003c/p\u003e","title":"211028模拟赛"},{"content":"Description 有两个 $B$ 进制数 $L,R$，求区间 $[L,R]$ 中，将所有 $B$ 进制数看成一个字符串，所有字符串的所有连续子串对应 $B$ 进制数的和（十进制） $\\bmod 20130427$​。\nSolution 这个数位DP实在是太毒瘤了。。。\n看了看题解才搞懂，于是我来记录一下这道题。\n为方便，下面记 一个数所有连续子串的和 为其权值，记为 $w(n)$​​；一个数所有后缀的对应数字的和为 $s(n)$​；一个数字位数为 $len(n)$​​。​\n首先考虑有一个数 $p$，在其后面填一个数 $q$，得到新数 $\\overline{pq}$​ 的权值 $$ w(\\overline{pq})=w(p)+B\\times s(p)+len(\\overline{pq})\\times q $$ 这时我们发现，后半部分实际就是 $s(\\overline{pq})$，那么 $w(\\overline{pq})=w(p)+s(\\overline{pq})$，其中 $s(\\overline{pq})=B\\times s(p)+len(\\overline{pq})\\times q$，且 $len(\\overline{pq})=len(p)+1$​。\n上述过程都还算显然。于是我们找到了一个递推的思路。\n因为我们要对 $w$ 求和，如果枚举 $0\\sim B-1$，直接用以上的方法递推，复杂度会达到 $O(B(n+m))$。考虑优化：\n既然我们要求和，那么就直接记录答案，然后大力推式子。\n按照数位DP的传统思路，设 $f(i,0/1)$ 表示从高到低 $i$ 位，否/是 紧贴上界的 $\\sum{w}$。\n你就会发现式子开始变得不那么显然了起来。\n记录 $sum(n,0/1)=\\sum s(n,0/1)$；$sl(n,0/1)=\\sum len(n,0/1)$；$a(i,0/1)$​ 为 否/是 紧贴上界时数的个数。\n注意，当以上的第二维取 $1$ 时，要注意实际上在该位的取值只有一种（虽然有 $\\sum$​）。\n下面记 $p(i)$ 为当前的位数上的数字。我把低的位存在数组前面，所以第 $n$ 位由 $n+1$ 为转移来。\n那么 $f(n,1)=f(n+1,1)+sum(n,1)$，\n而 $sum(n,1)=sum(n+1,1)\\times B+p(n)\\times sl(n,1)$，\n其中 $sl(n,1)=sl(n+1,1)+a(n,1)$，$a(n,1)=a(n+1,1)$。\n上面这些式子都还算显然，接下来的转移就有点怪了。 $$ f(n,0)=f(n+1,0)\\times B+sum(n,0)+f(n+1,1)\\times p(n) $$ 前半部分就是我们之前推的式子，解释一下 $f(n+1,1)\\times p(n)$：$sum(n,0)$ 已经包括了前 $n$ 位数中所有不紧贴上界的后缀和的和，这也包括了在 $n+1$ 位之前紧贴上界，在第 $n$ 位不紧贴的数。而 $f(n+1,0)$ 是上一位不紧贴的答案。我们发现，上一位紧贴的全部答案都不在现在的后缀和中，也就是没有被计算进去，而这种没有被计算的数恰好有 $p(n)$ 个（$0\\sim p-1$）。所以有上式。\n接下来要求 $sum(n,0)$，这个式子是真的恶心。首先记 $pre(n)=\\sum_0^{n-1}$。\n当 $n$ 是最高位的时候 $t=0$，否则 $t=B$​​，这是为了处理前导零，具体作用你把它换成 $B$​ 就能明白了吧。 $$ \\begin{align*} sum(n,0)=\u0026amp;sum(n+1,1)\\times B\\times p(n)+pre(p(n))\\times sl(n,1)+\\\\ \u0026amp;sum(n+1,0)\\times B\\times B+pre(B)\\times(sl(n+1,0)+a(n+1,0))+\\\\ \u0026amp;pre(t) \\end{align*} $$ 解释暂时咕了\n然后是其中的 $sl(n,0)$： $$ sl(n,0)=t-1+sl(n+1,1)\\times p(n)+(sl(n+1,0)+a(n+1,0))\\times B $$\n对于上一位紧贴上界，现在有 $p(n)$​​ 个。\n解释暂时咕了\n对于 $a(n,0)$​，有下面一个还算显然的式子： $$ a(n,0)=t-1+a(n+1,0)\\times B+a(n+1,1)\\times p(n) $$\n这个式子不解释了。\n于是把以上式子写成代码，这题就做完了。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using std::cout; using std::endl; const int maxn = 1e5 + 10; const int mod = 20130427; typedef long long ll; ll f[maxn][2], sum[maxn][2], sl[maxn][2], a[maxn][2]; ll B, n, m; ll S[maxn], l[maxn], r[maxn]; ll solve(ll *p, ll l) { memset(f, 0, sizeof(f)), memset(sum, 0, sizeof(sum)); memset(sl, 0, sizeof(sl)), memset(a, 0, sizeof(a)); a[l][1] = 1; for (int i = l - 1; i \u0026gt;= 0; i--) { int t = i == l - 1 ? 0 : B; a[i][1] = a[i + 1][1]; a[i][0] = (t - 1 + a[i + 1][0] * B % mod + a[i + 1][1] * p[i] % mod) % mod; sl[i][1] = sl[i + 1][1] + a[i + 1][1]; sl[i][0] = (t - 1 + sl[i][1] * p[i] + (sl[i + 1][0] + a[i + 1][0]) * B % mod) % mod; sum[i][1] = (sum[i + 1][1] * B % mod + p[i] * sl[i][1]) % mod; sum[i][0] = (S[t] + sum[i + 1][1] * B * p[i] + S[p[i]] * sl[i][1] + sum[i + 1][0] * B % mod * B % mod + S[B] * (sl[i + 1][0] + a[i + 1][0])) % mod; f[i][1] = (f[i + 1][1] + sum[i][1]) % mod; f[i][0] = (f[i + 1][0] * B + sum[i][0] + f[i + 1][1] * p[i]) % mod; } return (f[0][1] + f[0][0]) % mod; } int main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;B); for (int i = 0; i \u0026lt; B; i++) S[i + 1] = S[i] + i; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;l[n - i - 1]); for (int i = 0; i \u0026lt; n; i++) { if (l[i] \u0026gt; 0) { l[i]--; break; } l[i] = B - 1; } if (l[n - 1] == 0) n--; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;m); for (int i = 0; i \u0026lt; m; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;r[m - i - 1]); printf(\u0026#34;%lld\\n\u0026#34;, (solve(r, m) - solve(l, n) + mod) % mod); return 0; } ","permalink":"https://luoyisu.github.io/posts/luogu3281/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e有两个 $B$ 进制数 $L,R$，求区间 $[L,R]$ 中，将所有 $B$ 进制数看成一个字符串，所有字符串的所有连续子串对应 $B$ 进制数的和（十进制） $\\bmod 20130427$​。\u003c/p\u003e","title":"luogu3281 [SCOI2013]数数"},{"content":"概述 估计 $100+0+0+100=200$​，实际 $0+0+0+0=0$​​。\n试图切题，然后挂了 $\\text{inf}$ 分。\n赛时 T1 样例锅了，不过感觉能做，乱搞了一个做法，过了自己造的样例，跑路了。\n花了不少时间。\nT2 不会，T3 有点思路，不过发现 T4 似乎很简单。\n想了一个贪心思路，能证明是对的。\n发现树剖能做，但我对树剖非常不熟练，于是想换个思路。\n然后发现虚树能做，然后尝试现场推虚树失败了。\n好吧，那就写树剖，于是回忆了一波树剖。\n开始写，非常不熟练导致写得很慢。\n然后写了个区间赋值，查询区间和的线段树上去。\n大概还剩半个多小时的时候把代码写完了，过样例之后非常害怕，写了个暴力想对拍。\n这暴力怎么这么难写啊！！！！！！！！！！！！\n等开始对拍已经就剩不到十分钟了，结果第一组就拍出来了错误。\n哈哈，不知道我哪里错了，草草交了代码跑路了。\n赛后 发现实际上 T3 似乎也不是非常难。\nT1 freopen 打错了，真好玩。\nT4 果然爆零了，甚至因为没打头文件 CE 了。。。\n总结 头文件和 freopen 这两个错误确实是有点尴尬。。。。\nT1 我做法似乎确实是假了。\n发现我 T4 树剖没写错，线段树写错了，改完就 AC 了。。。。。\n果然是着急了\u0026hellip;不管写什么都必须认真。\n最后改完发现我考试时候的思路总共能过 $130$ 分，wtcl。\n","permalink":"https://luoyisu.github.io/posts/211027%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%88%86%E9%9B%B6%E8%AE%B0/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e估计 $100+0+0+100=200$​，实际 $0+0+0+0=0$​​。\u003c/p\u003e\n\u003cp\u003e试图切题，然后挂了 $\\text{inf}$ 分。\u003c/p\u003e","title":"211027模拟赛爆零记"},{"content":"CSP2021-S2 没有大模拟我其实是很失望的。\nDay -1 待填。\nDay 1 上午 睡觉时间有点短，感觉今天状态不是很好，主要在颓废+睡觉。\n下午 一点多到了考点，于是发现不能进。在外面聊天，遇到 xxh 了，和他聊了聊，开心。\n于是发现都 $14:10$ 了还不进考场，站着感觉消耗了我 $\\text{inf}$ 多的体力。。。\n第一次来复赛，好紧张啊。\n中考的时候信心很足，这次则是完全没底。害怕。\n机房环境感觉还不错。键盘鼠标都很好用。又发现周围全是小学生， 更害怕了.jpg\n下面是正题\n考试 第一次见这么正经的 PDF，紧张再次加剧。\n又发现有 -O2，好耶！\n不过一般来说我看到题之后还是会进入状态（后面会发现我错了）。\n按照策略，打算尽力切 T1。\n发现 T1 不是大模拟，有点慌。\n又发现这是个最优化的题，是个贪心。\n想了个线段树的乱搞做法，感觉非常的真。\n快速写完，于是它挂了。\n于是它假了。\n想了想不知道怎么回事，发现时间不太够了。又发现 T1 暴力分很少。\n然后心态有些爆炸。\n流鼻血了，快速处理完，顺便稍微冷静了一下。\n感觉今天状态不是很好啊、、、、\n稍微看了看剩下的题，感觉都不怎么能做。\n稍微推了一下 T2，是个 计数DP，不大行。\nT3 T4都完全看不懂他在搞什么。\n发现剩下的题我都只会指数级别的暴力。\n这时还剩两小时。\n我决定放弃 T1 正解。\n快速打完 T2、T3 的暴力。\n发现 T4 暴力分实在是太少了。\n回去写了个不知道能不能拿到 $40$ 分的 T1 暴力。\n调完之后还剩将近一个小时。\n快速写了个 T4 的指数暴力，估计得不了分，但还是写一下吧。\n回去推 T1 未果。这时候心乱如麻了。\n又看了看 T3 的一个怪异的性质，很显然 T3 是个结论题，但我不会做。。。。\n乱搞了几个 T3 结论，发现都显然是错的。\n行。\n绷不住了。直接跑路。\n赛后 出考场的时候旁边的小朋友说我键盘敲得特别快，好强。我只能笑笑\u0026hellip;\n敲暴力当然敲得快啊。。。\n估计 $30+15+28+5=78$​​，我觉得估计得还算准。也许能压线一等？\n希望别挂，希望评测机跑得够快。\n感觉人均切了 T1，有点绷不住了。。。。\n不想了，坐等官方的分数。\n感觉这分数就是退役的节奏啊。\n总结 感觉策略上没太大的问题，发现切不了就果断转暴力。\n其实离切也没差多少了。。。。\n然后就是 DP，贪心 这两个算法必须得过关，这种类型的题也许需要不断总结不断做题不断思考。\n感觉自己确实是少了很多积淀，只会一些知识点却不能非常灵活地运用。\n下次写代码之前一定要认真想好。\n心态要好，睡觉必须早。\n这次很崩，也算是自己一个教训。\n不过众所周知 CSP 有分就行。接着备战 NOIP 了。\n感觉自己必须抓紧了，就我这聪明程度也不知道能走多远，只希望能搞一个不辜负自己的结果吧。\n希望自己不是被迫退役。\n","permalink":"https://luoyisu.github.io/posts/csp2021-s2/","summary":"\u003ch1 id=\"csp2021-s2\"\u003eCSP2021-S2\u003c/h1\u003e\n\u003cp\u003e没有大模拟我其实是很失望的。\u003c/p\u003e","title":"CSP2021-S2游记"},{"content":"Description 阿申准备报名参加 GT 考试，准考证号为 $N$ 位数 $X_1,X_2…X_n(0\\le X_i\\le9)$，他不希望准考证号上出现不吉利的数字。 他的不吉利数字 $A_1,A_2…A_m(0\\le A_i\\le 9)A_1,A_2…A_m(0≤A_i≤9)$ 有 $M$ 位，不出现是指 $X_1,X_2…X_n$ 中没有恰好一段等于 $A_1,A_2…A_m$，$A_1$ 和 $X_1$ 可以为 $0$。\nSolution 我过的挺玄学。\n先考虑 DP。$f_{i,j}$​ 表示准考证前 $i$​ 位数未出现不吉利数字，且当前已经与不吉利数字匹配 $j$​​ 位（即后 $j$ 位与不吉利数字前 $j$ 位相同）的方案数。\n一看就是个 KMP，构建出 $\\text{fail}$​ 数组，又发现 $n\\leq10^9$，往矩阵快速幂的方面去靠一靠。\n发现当已经匹配 $p$ 位时，下一位有 $9$ 种选择，于是枚举这九种选择，利用 $\\text{fail}$ 数组，可以快速转移到选择之后匹配到第几位。\n于是发现这是个刷表转移，把这个刷表转成矩阵就成为了初始矩阵。\n于是快速幂一下就做完了。\n但要注意构造矩阵时的细节。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using std::cout; using std::endl; const int maxn = 110, maxm = 22; int mod; int n, m, k; struct matrix { int n, m; long long a[maxn][maxn]; matrix() : n(0), m(0) { memset(a, 0, sizeof(a)); } matrix(int _n, int _m) : n(_n), m(_m) { memset(a, 0, sizeof(a)); } matrix(int _n, int _m, long long _a[maxn][maxn]) : n(_n), m(_m) { for (int i = 1; i \u0026lt;= _n; i++) for (int j = 1; j \u0026lt;= _m; j++) a[i][j] = _a[i][j]; } matrix operator*(const matrix b) { matrix res(n, b.m); for (int i = 1; i \u0026lt;= n; i++) for (int k = 1; k \u0026lt;= m; k++) for (int j = 1; j \u0026lt;= b.m; j++) res.a[i][j] += a[i][k] * b.a[k][j] % mod, res.a[i][j] %= mod; return res; } void print() { for (int i = 1; i \u0026lt;= n; i++, puts(\u0026#34;\u0026#34;)) for (int j = 1; j \u0026lt;= m; j++) printf(\u0026#34;%lld \u0026#34;, a[i][j]); } matrix qpow(int x) { return qpow(*this, x); } matrix qpow(matrix a, int x) { matrix res = a; x--; for (; x; x \u0026gt;\u0026gt;= 1) { if (x \u0026amp; 1) res = res * a; a = a * a; } return res; } } base; char s[maxm]; int fail[maxm]; int a[maxm][maxm]; void get_fail() { for (int i = 2, j = 0; i \u0026lt;= m; i++) { while (j \u0026amp;\u0026amp; s[j + 1] != s[i]) j = fail[j]; if (s[j + 1] == s[i]) j++; fail[i] = j; } } void init() { for (int i = 1; i \u0026lt;= m; i++) { for (char num = \u0026#39;0\u0026#39;; num \u0026lt;= \u0026#39;9\u0026#39;; num++) { int j = i - 1; while (j \u0026amp;\u0026amp; s[j + 1] != num) j = fail[j]; if (s[j + 1] == num) j++; if (j != m) base.a[i][j + 1]++; } } } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;mod); scanf(\u0026#34;%s\u0026#34;, s + 1); get_fail(); init(); base.n = m, base.m = m; //base.print(); matrix ans = base.qpow(n); long long res = 0; //ans.print(); for (int i = 1; i \u0026lt;= m; i++) res += ans.a[1][i], res %= mod; printf(\u0026#34;%lld\\n\u0026#34;, res); } ","permalink":"https://luoyisu.github.io/posts/loj10224/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e阿申准备报名参加 GT 考试，准考证号为 $N$ 位数 $X_1,X_2…X_n(0\\le X_i\\le9)$，他不希望准考证号上出现不吉利的数字。 他的不吉利数字 $A_1,A_2…A_m(0\\le A_i\\le 9)A_1,A_2…A_m(0≤A_i≤9)$ 有 $M$ 位，不出现是指 $X_1,X_2…X_n$ 中没有恰好一段等于 $A_1,A_2…A_m$，$A_1$ 和 $X_1$ 可以为 $0$。\u003c/p\u003e","title":"loj10224 [HNOI2008] GT考试"},{"content":"概述 啥都不会，只会暴力。\n估计 $60+60+20+0=140$，实际 $60+60+20+0=140$​。。。。。。\n赛时 T1 似乎是个傻逼题，但我被降智了，不会；\nT2 似乎不难，暴力也能拿很多分数；\nT3 是个推式子题，暴力只有 $20$ 分；\nT4 是个期望题，要是会期望就能拿很多暴力分数。\n然后有 $\\text{2h}$ 的时间不知道在干什么，想了 T1 的一个贪心不过假了。\n发现不行了就赶忙打了三个暴力跑路了。。。。。。\n算了算 T4，发现我不会期望。。。。\n最后半个小时发现 T1 就是个枚举题。于是一阵写，但没写完。。。\n赛后 发现 T2 也是降智题，哈哈。\n总结 不知道总结啥，考试要调整好状态，注意隐藏的数据范围。\n不能被降智了！！！！！\n","permalink":"https://luoyisu.github.io/posts/211017%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e啥都不会，只会暴力。\u003c/p\u003e\n\u003cp\u003e估计 $60+60+20+0=140$，实际 $60+60+20+0=140$​。。。。。。\u003c/p\u003e","title":"211017模拟赛"},{"content":"概述 今天的模拟赛还行。\n期望 $100+0+40+52=192$，实际 $100+0+20+52=172$​。还算可以。\n赛时 发现 T1、T3 都是期望，T2 看不懂，T4 是个树论。\n手玩 T1 样例，发现了一些规律，写了个 $O(n^2)$ 暴力，然后写了个 $O(n\\log n)$ 的线段树优化。\n$n=10^6$，我意识到线段树常数有点大，但是我又不会树状数组。于是我卡了卡常，发现在我的机子上开 O2 要跑 $600\\text{ms}$​，感觉能过，又快速写了个数据生成器对拍。没拍出来啥问题，好评。\n去做 T4，有 $32$ 分比较白给，然后想了一个多小时搞出来了 $20$​​​​ 的部分分。发现我还是不会写树状数组，于是又搞了个线段树上去。写完之后发现数据非常好造，于是快乐对拍，把 bug 都搞掉了。\n快结束了，T2 还是看不懂，快速推了 T3 $n=1$ 的式子，写完调完就溜了。最后几分钟又乱搞了 $20$ 分，不过似乎假了。\n总结 对拍是非常有必要的。\n一些简单的卡常技巧需要学会。\n不能什么都线段树，树状数组也是有用的。\n发现我不会期望，推式子能力也挺差的，老暴力选手了。。。。。\n","permalink":"https://luoyisu.github.io/posts/211016%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e今天的模拟赛还行。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期望\u003c/strong\u003e $100+0+40+52=192$，实际 $100+0+20+52=172$​。还算可以。\u003c/p\u003e","title":"211016模拟赛"},{"content":"概述 今天实惨，估计 $0+72+100+100=272$，实际 $0+0+0+100=100$​。\n被吊打了qwq。\n赛时 发现 T4 做过，$20\\text{min}$ 切了，这是好的。\n去做 T2，一个多小时写了个 $72$ 分的状压 DP，过了样例就溜了。\n去做 T3，瞎推了推式子发现一个贪心，瞎搞了个最小生成树上去。感觉切了，不过样例实在太水，感觉自己应该会挂。\n去做 T1，发现自己不会暴力，去看链的情况，发现有重边，我不会了。。。\n赛后 发现自己 T2、T3 全挂成了 $0$ 分。\n然后发现我 T3 做法和题解一样，甚至式子也一样，但因为各种细节处理挂了。行吧。\n总结 代码能力不够。\n样例过水的时候需要对拍，代码想好之后再写。\n不知道代码能力怎么提升，也许是写的题太少了？\n","permalink":"https://luoyisu.github.io/posts/211015%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e今天实惨，估计 $0+72+100+100=272$，实际 $0+0+0+100=100$​。\u003c/p\u003e\n\u003cp\u003e被吊打了qwq。\u003c/p\u003e","title":"211015模拟赛"},{"content":"概述 今天的题体感好一些，没有太强的无力感。\n估计 $30+80+65=175$，实际 $30+70+15=115$，真惨。\n膜拜 shr 大佬爆切 T3，$190pts$​ 并列 $\\text{Rank}1$​！！\n今天又是被 shr 和 樱雪 吊打的一天qwq\n赛时 一看 T1，似乎有点复杂，不太懂；又看 T2，能写 $50$ 分 DP；接着看 T3，没懂。\n看了看之后就去写 T2 了，$50\\text{min}$​​​ 写完+调完。感觉能用矩阵优化到 $80$ 分，剩下那 $20$ 分的通项公式不太敢想\u0026hellip;\n还是去写 T3 了，快速写了个高达 $0$​ 分的暴力找规律，发现了一个类似杨辉三角的东西，于是线推式子求组合数乱搞了 $50$ 分，然后觉得似乎能切，于是写起了正解。写完一个区间加单点查询的线段树之后，我忽然意识到这样并不能得 $100$ 分，想了想也不知道用到底怎么用数据结构维护。于是转去写了个 $k=1$ 的部分分。总共期望能得 $65$​​​ 分。\n写着写着忽然发现前 $50$ 分复杂度不是很对，有 TLE 的风险，但转念一想常数很小，应该没啥问题。\n然后想了想能不能递推组合数，然后发现会 MLE。\n感觉问题不大，写完 freopen 溜了。\n此时只剩一个小时左右了。\n去看 T1，快速写了个最简单的 $30$ 分，剩下 $30$ 的部分分似乎不是特别简单，放弃了，打算那剩下的时间推 T2 的矩阵。\n快速写了个矩阵的板子，然后想了想意识到怎么构造矩阵了，没多想就上手写了。\n写+调，最后剩 $5\\text{min}$ 的时候调完了。没时间多想了，赶快开始检查三道题有没有 SB 错误。\n赛后 听说苏大佬 T3 切了，我：？？？那玩意不简单的啊？？？\n于是发现人均 T1 写了 $60$​，感觉我又要垫底了。\n然后开始评测了，我 T3 前面的暴力全 TLE 了，哈哈哈，复杂度不对果然过不了。。\n然后发现 T2 TLE 了一个点，也有点怪。\n检查之后意识到 T3 可以线性求逆元，复杂度就不会挂。。。啊，我真是傻逼。\n又意识到 T2 的初试矩阵我是暴力求的，于是复杂度从 $k^3\\log n$ 变成了 $k^4$，而 $k\\leq100$，我就挂了。。。**啊，我真是傻逼。**明明利用这个矩阵的一些奇妙性质就能优化，甚至打个表也行啊！！（考虑到没时间了也确实没啥办法）\n然后发现 T3 由于出题人的疏忽，导致 shr 用暴力水过去了！貌似出题人没想到这种暴力。。。\n苏大佬太强了！！！！！\n总结 首先意识到我代码能力太差了，写代码慢，调试也慢，思考也慢。。。\nshr 大佬睡一个小时觉都比我高qwq\n然后就是，对于 T1 这种简单的暴力，一定要拿满。。。\n也要检查复杂度，要是有把握的题，复杂度必须要控制好，不能挂。\n接下来就是不断的刷题增强代码能力了。\n通项公式依然不会求，不过也许可以靠打表来“大胆猜想，从不求证”。\n同时要注意，小常数 $10^8$ 是能跑过的，不能总是分析渐进复杂度，也要考虑究竟进行了几次计算。\n","permalink":"https://luoyisu.github.io/posts/211005%E5%8D%81%E4%B8%80%E6%A8%A1%E6%8B%9F%E8%B5%9B2/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e今天的题体感好一些，没有太强的无力感。\u003c/p\u003e\n\u003cp\u003e估计 $30+80+65=175$，实际 $30+70+15=115$，真惨。\u003c/p\u003e\n\u003cp\u003e膜拜 shr 大佬爆切 T3，$190pts$​ 并列 $\\text{Rank}1$​！！\u003c/p\u003e\n\u003cp\u003e今天又是被 shr 和 樱雪 吊打的一天qwq\u003c/p\u003e","title":"211005十一模拟赛2"},{"content":"概述 有点凄凉。\n预测 $20+60+40=120$，实际 $20+60+0=80$。被各路神仙吊打了qwq\n赛前 了解到大概会是三道数学/计数/推式子题，于是没打算拿多高的分数，暴力万岁。\n赛时 不知道题目难度，就都看了看。\nT1 完全不会，T2 有 $60$ 分我能写，T3 能写一些暴力分。\n于是开写 T2，写了个数位 DP，$60$ 分到手，去看 T1，还是啥都不会，去做 T3，感觉数据应该不会太强，于是就写个了跑不满的 $O(n^4)$ 做法，应该能拿到 $40$ 分。\n然后去 T1，爆搜了一波， $20$ 到手，没花时间看有没有什么规律。\n这时候还剩两个小时，我有点懒了，不想思考。\nT2 似乎能用矩阵优化，但我从来没搞过，不想推矩阵。。。\nT1 还是没懂，T3 没想出来啥优化的做法。\n感觉这个分数应该还可以了。。。于是就颓了好久。\n赛后 发现大佬们都写了好多分。。。有点后悔颓废了。\n膜拜 shr 大佬，随手写 $200$​ 分，吊打我qwq。\n然后发现 T1 有 $20$ 分就是卡特兰数，我谔谔，没看出来规律。。。。。\n又发现人均会写矩阵，草了，又发现人均 T3 比我高。。。\n然后出分了，发现 T3 爆零了，然后发现自己瞎优化整挂了，数据水，本来能拿到 $60$ 分的。。\n总结 模拟不能躺平！！！有用的知识不能不学！！！\n希望下次能好点qwq\n","permalink":"https://luoyisu.github.io/posts/211003%E5%8D%81%E4%B8%80%E6%A8%A1%E6%8B%9F%E8%B5%9B1/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e有点凄凉。\u003c/p\u003e\n\u003cp\u003e预测 $20+60+40=120$，实际 $20+60+0=80$。被各路神仙吊打了qwq\u003c/p\u003e","title":"211003十一模拟赛1"},{"content":"我愿称之为凄凉。\n第一轮 考前 在本校考试，碰到 xxh 了，非常开心，互相膜拜着就进了考场。\n然后发现好多初中生和小学生，草，似乎要被吊打。\n考时 看到第一题就觉得不对劲，怎么一上来就是考 Linux 命令？\n行吧，接着做。\n选择题做得有点慢，太玄学了。然后我发现有点小难，行吧，硬着头皮蒙完了选择题去做后面的阅读程序。\n第一个阅读程序看了看没懂，后来半蒙着觉得是体积交，然后手算了一波溜了。\n第二个发现是最大子段和，于是乱选了一波溜了。\n第三个阅读程序是个编码，我没懂，盲猜了一波就溜了。\n接着是补全程序，第一个倒是看懂了，不过做着有点犹豫，纠结了一阵子就溜了。\n第二个看不懂，也快没时间了。纯粹在蒙，算了算了算了。\n这不当场退役？\n考后 对了对答案，发现自己到处挂题，选择也挂了，最大子段和也挂了（我不知道我当时怎么想的。。。）\n然后补全程序非常凄凉，我有的不记得选的啥了。\n大概 $60$​​ 分左右？。。。有的题记不住答案了。\n我谔谔，好多不该错的错了。\n大概能过，不过我这水平也太低了。。。。。\nUPD：确实 $60$ 分，行吧，反正辽宁是弱省，分数线似乎已经跌到 $40$ 一下了，那不是随便过。。。\nUPD2：居然压线达到了一等评级，然后辽宁分数线 $28$​ 分，太离谱了。我寻思着随便找个人上去蒙不是都能过吗？？？\n","permalink":"https://luoyisu.github.io/posts/csp2021-s1-s2%E6%B8%B8%E8%AE%B0/","summary":"\u003cp\u003e我愿称之为凄凉。\u003c/p\u003e","title":"CSP2021-S1游记"},{"content":"概述 题好难啊qwq。\n期望 $50+40+60+30=180$，实际 $10+40+30+30=110$，挂了不少。\n不过这次没有爆零的题，是个进步，打暴力分还是比抠正解高\u0026hellip;水平不够啊。\n赛时 没想太多，直接看 T1，感觉我似乎会。乱搞一通，做法假了，想了想不会，溜了。纯暴力 $20$ 分，性价比有点低，接着看下面的题吧。\n于是去看 T2，乍一看以为是个数学题，似乎没啥规律，看了看这题纯暴力才 $20$​ 分，太少了，先看看别的题。\n此时已经过去一个小时。\n看 T3，我会 $60$​ 分，又去看 T4，感觉很难，于是写了个 $30$ 分暴力，回去写 T3 写了一个多小时差不多搞定了，告辞。\n看到 T4 有一个部分分，想到用树状数组维护，结果发现复杂度是 $O(maxa\\log maxa\\times n)$，这会爆。有点疑惑，这思路应该没啥问题啊。\n不管了，回去看 T1、T2，发现我 T1 还是不会，于是写了个 $O(n^2\\log n)$ 的暴力，似乎能过 $50$ 分，但是我总感觉自己做法有点假（\n然后写 T2，写了个全排列的 $20$ 分，然后推了推式子发现可以做到 $O(n^2)$ 递推，写了写调了调过了，然后思考如何优化，没思考出来。\n还剩半个小时，去推了推 T1，无果，在最后十分钟意识到 T4 没有修改操作，直接用前缀和维护就行了，我怕是个傻子。\n然后疯狂写，结果还是挂了，好吧不亏。\n赛后 发现自己 T1 挂成 $10$​ 分，明明思路是对的，就是枚举公差然后判断，不过挂也是意料之中，然后发现根本看不懂题解。T3 挂了 $30$​​ 分，有点懵。\n然后发现 T2 的正解和那个递推完全没关系，行吧。T4 是个数据结构题，看不懂.jpg。\n发现大家似乎都不是很会正解的样子\u0026hellip;好吧，暴力实在是太爽了。\n发现 T3 的那 $30$​ 分似乎没有人过了，于是开始对拍 T3 找错，拍出来之后发现是 std 挂了？？？？？后来发现题解似乎也有问题、、、\n我谔谔，请给全机房加上 $30$ 分。\n发现范神居然切了一题，太强了。（据他说是打的暴力，数据水所以过了，但还是太强了）\n然后去调 T4 了，未果。\n总结 暴力永远的神。\n发现自己不管是从码力还是思维上还是远远不足，写暴力都得调半天。\n可能还是需要积累。模拟赛不就是为这个目标服务的吗？\n这场比赛还是打得挺开心的，没有特别强的无力感，拿到暴力分就挺满足的了（\n关于暴力的具体做法可以看 某大佬的博客，思路和我都差不多。\n","permalink":"https://luoyisu.github.io/posts/210912noip%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e题好难啊qwq。\u003c/p\u003e\n\u003cp\u003e期望 $50+40+60+30=180$，实际 $10+40+30+30=110$，挂了不少。\u003c/p\u003e\n\u003cp\u003e不过这次没有爆零的题，是个进步，打暴力分还是比抠正解高\u0026hellip;水平不够啊。\u003c/p\u003e","title":"210912NOIP模拟赛"},{"content":"概述 首先看到三道名字是乱码的题，一道叫“Extra”的构造题，又一看叫“信心赛”，又看到“题目较简单。AK选手不要大声喧哗”，再仔细一看，“题目不按照难度顺序排序”，我就知道来者不善。我直呼好家伙！\n教练让我们多写暴力拿分，在前十分钟我还是想贯彻这个思想的，结果后来有点上头。\n预计 $0+0+10+100=110$，实际 $0+0+0+60=60$​，信心十足. jpg。\n以上都是借口，题不是特别难，我实力不足罢了。\n赛时 随缘开题，先看了 T1，理解题意搞了半天，于是感觉似乎不是很难，然后写的时候发现我不会写，复杂度似乎也不太对。想了半天毛都没写，溜了溜了。\n又看 T2，行吧，暴力能搞 $30$ 分，但似乎也不是特别难（后来发现是错觉）。\n又去看 T3，感觉自己似乎能拿到 $50$ 分，后来先写了个 $10$ 分，然后发现有 $20$ 分似乎拿不到，有发现 $20$ 分暴力似乎也不是那么好写，溜了溜了。\n接着去看 T4，似乎有 $40$ 分随手就能拿，于是写了，然后就溜了。\n这时候已经过去两个多小时了（我效率为啥这么低）。\n想了想，似乎 T123 的暴力都不咋好写，于是我爬了，感觉 T1 似乎能写，于是开始写。\n然后写着写着发现不会写，于是去看了 T4，把所有情况都给写了，顺便修了个 bug。但是我一个都不会证，就当我切了吧233。\n于是滚回去写 T1，写着写着就到点了，心情平静。\n赛后 忽然发现我 T3 CE了，问号。\n又发现 T4 有两个做法似乎是假的，不要紧（\n总结 还是水平太低。\nT1 想到了正解的部分思路，但没完全想到，思维水平不够。也许这个能力只能靠多做题多研究题解了。\nT2 完全不会，是转化成染色。。不过没打暴力确实是个错误。\nT3 也不懂，好难啊，不过确实应该写暴力的。\nT4 有点神仙，不过混了 $60$ 分我很满足了。\n水平不够，而且还是要多打暴力，也要思考思考暴力怎么写快。\n","permalink":"https://luoyisu.github.io/posts/210911noip%E4%BF%A1%E5%BF%83%E8%B5%9B%E9%97%AE%E5%8F%B7%E8%AE%B0/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e首先看到三道名字是乱码的题，一道叫“Extra”的构造题，又一看叫“信心赛”，又看到“题目较简单。AK选手不要大声喧哗”，再仔细一看，“题目不按照难度顺序排序”，我就知道来者不善。我直呼好家伙！\u003c/p\u003e\n\u003cp\u003e教练让我们多写暴力拿分，在前十分钟我还是想贯彻这个思想的，结果后来有点上头。\u003c/p\u003e\n\u003cp\u003e预计 $0+0+10+100=110$，实际 $0+0+0+60=60$​，信心十足. jpg。\u003c/p\u003e\n\u003cp\u003e以上都是借口，题不是特别难，我实力不足罢了。\u003c/p\u003e","title":"210911NOIP信心赛问号记"},{"content":"Description 给定三条线段，判断能否构成 A，即是否满足以下条件：\n有两条线段有公共点（下称“第一、二条线段”，另一条线段称“第三条线段”）；\n第三条线段的两个端点分别在第一、二条线段上；\n第一、二条线段夹角大于 $0$，小于 $\\dfrac{\\pi}{2}$；\n第三条线段分别将第一、二条线段截成两段，较短的线段与较长的线段的长度比不小于 $\\dfrac14$。\nSolution 这是道计算几何的水题。想水黑题的快来\n其实只需要暴力模拟即可，每组数据时间复杂度 $O(1)$，总时间复杂度 $O(T)$。\n我用的纯计算几何的做法，用向量进行计算。因此把向量封装了，代码还算简单。\n第一个要求直接暴力枚举，找有没有相同的点即可。\n第二个要求也是计算几何基本操作：先用向量叉积是否为 $0$ 判断三点是否共线，再看点是否在以线段为对角线的矩形内部。\n第三个要求本来想用叉积的几何意义配合反三角函数搞，但我不知道为啥一直挂，后来意识到是因为这个做法没法判断钝角。于是用余弦定理，就过了。\n第四个要求很简单，就用向量做减法然后算一下验证就行。\n感觉比起解析几何要省点脑子。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using std::max; using std::min; const double pi = 3.141592653589793; const double eps = 1e-10; class Vector // 向量（也用来存点） { public: long long x, y; Vector() { x = y = 0; } Vector(long long a, long long b) { x = a, y = b; } bool operator==(const Vector \u0026amp;b) const { return x == b.x \u0026amp;\u0026amp; y == b.y; } Vector operator+(const Vector \u0026amp;b) const { return Vector(x + b.x, y + b.y); } Vector operator-(const Vector \u0026amp;b) const { return Vector(x - b.x, y - b.y); } long long operator*(const Vector \u0026amp;b) const { return x * b.x + y * b.y; } long long operator\u0026amp;(const Vector \u0026amp;b) const { return x * b.y - b.x * y; } // 向量叉积 Vector operator=(const Vector \u0026amp;b) { x = b.x, y = b.y; return *this; } long long dis_pow() { return (long long)x * x + y * y; } double dis() { return sqrt((double)x * x + y * y); } } p[7]; bool in_seg(Vector a, Vector b, Vector x) // 判断点 x 是否在 线段ab 上 { if (((x - a) \u0026amp; (a - b)) != 0) // 叉乘为 0 return false; return min(a.x, b.x) \u0026lt;= x.x \u0026amp;\u0026amp; x.x \u0026lt;= max(a.x, b.x) \u0026amp;\u0026amp; min(a.y, b.y) \u0026lt;= x.y \u0026amp;\u0026amp; x.y \u0026lt;= max(a.y, b.y); } int main() { int T; std::cin \u0026gt;\u0026gt; T; while (T--) { Vector s; for (int i = 1; i \u0026lt;= 6; i++) std::cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; int a = -1, b = -1, c = -1; // 第一、二条线段为 a、b，第三条线段为 c for (int i = 1; i \u0026lt;= 5; i++) for (int j = i + 1; j \u0026lt;= 6; j++) if (p[i] == p[j]) // 找到三条线段 { a = (i - 1) / 2 + 1; b = (j - 1) / 2 + 1; c = 6 - a - b; s = p[i]; // s 为相同的端点 break; } if (a == -1) // 没有相同的点 { puts(\u0026#34;NO\u0026#34;); continue; } Vector a1 = p[a * 2 - 1], a2 = p[a * 2], b1 = p[b * 2 - 1], b2 = p[b * 2], c1 = p[c * 2 - 1], c2 = p[c * 2]; // 6 个点分别用向量表示 Vector _d1, _d2, _d3, _d4; // 第三条线段端点到到其所在线段两个端点的向量 // 分两种情况：第三条线段一个端点在 a 上，另一个在 b 上，或者相反 if (in_seg(a1, a2, c1) \u0026amp;\u0026amp; in_seg(b1, b2, c2)) _d1 = c1 - a1, _d2 = c1 - a2, _d3 = c2 - b1, _d4 = c2 - b2; else if (in_seg(a1, a2, c2) \u0026amp;\u0026amp; in_seg(b1, b2, c1)) _d1 = c2 - a1, _d2 = c2 - a2, _d3 = c1 - b1, _d4 = c1 - b2; else { puts(\u0026#34;NO\u0026#34;); continue; } Vector _a = a1 - s + a2 - s, _b = b1 - s + b2 - s; // 第一、二条线段的向量，这里的写法避免了分类讨论 Vector a_b = _a - _b; // a、b线段组成三角形的另一条边 if (_a.dis_pow() + _b.dis_pow() \u0026lt; a_b.dis_pow()) // 余弦定理判断夹角 { puts(\u0026#34;NO\u0026#34;); continue; } double d1 = _d1.dis(), d2 = _d2.dis(), d3 = _d3.dis(), d4 = _d4.dis(); if (d1 \u0026gt; d2) std::swap(d1, d2); if (d3 \u0026gt; d4) std::swap(d3, d4); // 这题似乎不卡精度，我就直接用 double 比较了，其实最好用距离的平方之比与 16 比较 if (d2 / d1 - 4 \u0026lt;= eps \u0026amp;\u0026amp; d4 / d3 - 4 \u0026lt;= eps) puts(\u0026#34;YES\u0026#34;); else puts(\u0026#34;NO\u0026#34;); } } ","permalink":"https://luoyisu.github.io/posts/cf13b/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e给定三条线段，判断能否构成 A，即是否满足以下条件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e有两条线段有公共点（下称“第一、二条线段”，另一条线段称“第三条线段”）；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e第三条线段的两个端点分别在第一、二条线段上；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e第一、二条线段夹角大于 $0$，小于 $\\dfrac{\\pi}{2}$；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e第三条线段分别将第一、二条线段截成两段，较短的线段与较长的线段的长度比不小于 $\\dfrac14$。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"CF13B"},{"content":"Description 生日演唱会采用一男一女合唱的形式，每个男生和女生都有一个演唱水平值，两个水平值分别为 $a$ 和 $b$ 的同学演唱将会给大家带来 $a\\times b$ 的愉悦度。演唱会开始时，$a$ 名男生和 $b$​ 名女生各排成一列。\n我将会从两列的第一位同学开始，分别挑选一名男生和一名女生。如果觉得某位同学不适合登台，我就会请他回到座位，直到挑选到一位满意的同学为止。若最后有一位男生或女生找不到搭档，我只好请剩下的所有人(包括那名同学)回到座位。如果连续的一些女生或者男生没有登台演唱会损失她(他)们水平值之和的平方的愉悦度。请求出大家能获得最大的愉悦值。（回去了就不能再上来）。\n$n\\leq 300$\nSolution 很显然是个 DP，看到数据范围大概需要 $O(n^3)$ 的算法，于是想到区间DP~~（其实这就是区间DP板块里的题）~~\n然后我不会设计状态了，本来考虑的是 $f_{i,j}$ 表示考虑在区间 $[i,j]$ 里的男女的最大值，后来发现不太对，因为男女未必全都能匹配，如果有剩余的人，状态就出现了后效性。接着就瞎加维，然后也没啥用。\n我又想男女分开考虑，也无果。\n然后我就又被 DP 蹂躏了\u0026hellip;\u0026hellip;\n后来看了看题解知道了状态设计：$f_{i,j}$ 表示考虑前 $i$ 个男生，前 $j$ 个女生，况且这两个人都要选的最大价值。\n那转移方程就很好想了：\n对当前状态，可以由不选一部分男生、不选一部分女生的两种状态转移而来，分别枚举断点 $k$​，转移即可。下面的两个方程分别是不选一部分男生和不选一部分女生的方程。 $$ f_{i,j}=\\max\\limits_{1\\leq k\\leq i-1}\\{f_{k,j-1}+a_i\\times b_j+(\\sum\\limits_{s=k+1}^{i-1}a_s)^2\\} $$\n$$ f_{i,j}=\\max\\limits_{1\\leq k\\leq j-1}\\{f_{i-1,k}+a_i\\times b_j+(\\sum\\limits_{s=k+1}^{j-1}b_s)^2\\} $$\n还有个有趣的问题：怎么快速统计答案？\n有个很妙的思路，在男女最后各加入一个愉悦值为 $0$ 的人，这样答案就是 $f_{n+1,n+1}$。\n初始状态是男/女有一个是第一个人，然后可以推全状态。\nCode #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using std::max; const int maxn = 310; int a[maxn], b[maxn], n; int sa[maxn], sb[maxn]; long long f[maxn][maxn]; // 前 i 个男生和前 j 个女生的最大价值 //i j 必须同时选 inline long long p_2(int x) { return (long long)x * x; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]), sa[i] = a[i] + sa[i - 1]; sa[n + 1] = sa[n]; for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]), sb[i] = b[i] + sb[i - 1]; sb[n + 1] = sb[n]; for (int i = 1; i \u0026lt;= n + 1; i++) { f[1][i] = a[1] * b[i] - p_2(sb[i - 1] - sb[0]); f[i][1] = a[i] * b[1] - p_2(sa[i - 1] - sa[0]); } for (int i = 2; i \u0026lt;= n + 1; i++) for (int j = 2; j \u0026lt;= n + 1; j++) { for (int k = 1; k \u0026lt; i; k++) f[i][j] = max(f[i][j], f[k][j - 1] + a[i] * b[j] - p_2(sa[i - 1] - sa[k])); for (int k = 1; k \u0026lt; j; k++) f[i][j] = max(f[i][j], f[i - 1][k] + a[i] * b[j] - p_2(sb[j - 1] - sb[k])); } std::cout \u0026lt;\u0026lt; f[n + 1][n + 1] \u0026lt;\u0026lt; std::endl; return 0; } 总结 打开思路，考虑不同方向去设计状态，避免后效性。\n","permalink":"https://luoyisu.github.io/posts/ybtoj-%E7%94%9F%E6%97%A5%E6%AC%A2%E5%94%B1/","summary":"\u003ch2 id=\"description\"\u003eDescription\u003c/h2\u003e\n\u003cp\u003e生日演唱会采用一男一女合唱的形式，每个男生和女生都有一个演唱水平值，两个水平值分别为 $a$ 和 $b$ 的同学演唱将会给大家带来 $a\\times b$ 的愉悦度。演唱会开始时，$a$ 名男生和 $b$​ 名女生各排成一列。\u003c/p\u003e\n\u003cp\u003e我将会从两列的第一位同学开始，分别挑选一名男生和一名女生。如果觉得某位同学不适合登台，我就会请他回到座位，直到挑选到一位满意的同学为止。若最后有一位男生或女生找不到搭档，我只好请剩下的所有人(包括那名同学)回到座位。如果连续的一些女生或者男生没有登台演唱会损失她(他)们水平值之和的平方的愉悦度。请求出大家能获得最大的愉悦值。（回去了就不能再上来）。\u003c/p\u003e\n\u003cp\u003e$n\\leq 300$\u003c/p\u003e","title":"YbtOJ 生日欢唱"},{"content":"概述 今天是构造，题似乎不是很难，然而我挂的很惨。\n期望：$100+30+60+100=290$​，实际 $0+20+0+5=25$​。大家都挂的很惨，于是我 RK13/23。。。\n前言 实际上我从来没有做过构造题，唯一的是前一天听同学口胡的一道 CF $1000+$​ 分的题，于是今天十分没底。\n赛时 看到保证 T1 是最简单的题，我立马定好策略：切掉 T1 再说。（T1：CF1439A2）\n于是开始想，大概想了十分钟吧，思路就已经成型了：枚举每个 $2\\times 2$​​ 正方形左上角的点，从第一行扫到倒数第三行，扫的时候保证该行所有 $1$ 都已经变成 $0$，其他随意。接着横着扫倒数第二行，一直扫到倒数第三列。这个时候除了右下角 $2\\times2$ 的四个数，所有数都已经变为 $0$ 了。而对于最后四个数，可能的剩余未熄灭灯数只有 $5$​​ 种。直接用打表/分类讨论之类的方法搞出来就行。\n{% spoiler Code %}\n#include\u0026lt;bits/stdc++.h\u0026gt; #define mm(x) memset(x, 0, sizeof(x)) using namespace std; int T, n, m, a[110][110]; struct node { int x, y; }; vector\u0026lt;node\u0026gt; p; void upd(int x, int y, int \u0026amp;q) { p.push_back((node){x, y}); a[x][y] = a[x][y] == 1 ? 0 : 1; q--; } int b[4][4];\tvoid solve_1() {\tint cnt = 3; for (int i = 0; i \u0026lt; 2; i++) for (int j = 0; j \u0026lt; 2; j++) if (a[n - i][m - j] == 1) upd(n - i, m - j, cnt); } void solve_2() { mm(b); int cnt = 3; for (int i = 0; i \u0026lt; 2; i++) for (int j = 0; j \u0026lt; 2; j++) if (a[n - i][m - j] == 0) upd(n - i, m - j, cnt), b[i][j] = 1; for (int i = 0; i \u0026lt; 2; i++) for (int j = 0; j \u0026lt; 2; j++) if (!b[i][j]) upd(n - i, m - j, cnt); solve_1(); } void solve_3() { mm(b); int cnt = 3; for (int i = 0; i \u0026lt; 2; i++) for (int j = 0; j \u0026lt; 2; j++) if (a[n - i][m - j] == 1) upd(n - i, m - j, cnt), b[i][j] = 1; for (int i = 0; i \u0026lt; 2; i++) for (int j = 0; j \u0026lt; 2; j++) if (!b[i][j]) upd(n - i, m - j, cnt), b[i][j] = 1; solve_2(); } void solve_0() { int cnt = 3; upd(n, m, cnt); upd(n, m - 1, cnt); upd(n - 1, m, cnt); solve_3(); } void out_put() { cout \u0026lt;\u0026lt; p.size() / 3; for (int i = 0; i \u0026lt; p.size(); i++) { if (i % 3 == 0) cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; p[i].x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p[i].y \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { freopen(\u0026#34;bulb.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;bulb.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; p.clear(); char ch; int ans = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; ch, a[i][j] = ch == \u0026#39;0\u0026#39; ? 0 : 1; for (int i = 1; i \u0026lt; n - 1; i++) for (int j = 1; j \u0026lt; m; j++) { int cnt = 3; if (a[i][j] == 1) upd(i, j, cnt); if (a[i][j + 1] == 1) upd(i, j + 1, cnt); if (cnt == 3) continue; if (cnt) upd(i + 1, j, cnt); if (cnt) upd(i + 1, j + 1, cnt); } for (int j = 1; j \u0026lt; m - 1; j++) { int cnt = 3; if (a[n - 1][j] == 1) upd(n - 1, j, cnt); if (a[n][j] == 1) upd(n, j, cnt); if (cnt == 3) continue; if (cnt) upd(n - 1, j + 1, cnt); if (cnt) upd(n, j + 1, cnt); } int tot = 0; for (int i = 0; i \u0026lt; 2; i++) for (int j = 0; j \u0026lt; 2; j++) { tot += a[n - i][m - j]; } tot = 4 - tot; if (tot == 0) solve_0(); else if (tot == 1) solve_1(); else if (tot == 2) solve_2(); else if (tot == 3) solve_3(); out_put(); } return 0; } {% endspoiler %}\n写完 T1，按传统规矩自然是 DEBUG 了好久，确定无误之后已经过去一个半小时了，感觉自己得了 $100$ 分，一阵狂喜，赶快开下面的题。\n接着看后面的题，决定先打暴力。\n首先打了个 T3 的 $60$ 分暴力，一阵狂喜，然后去写 T4，分析了一下发现我似乎能切。于是开始写，但是调到心态爆炸，于是在剩余 $20\\text{min}$​​ 的时候勉强调完了。\nT2 急的一笔，快速打了个暴力，希望能得 $30$ 分。不过也没测试，草草收场了。\n然后快结束的时候有人告诉我 T1 的文件名写错了，我：？？？\n结果还真写错了，我连忙改文件名和 freopen 里的文件名。\n时间到了，我一看，我 freopen 里的文件名没改上，我：？？？发生什么事了？？？\n行吧， $100$ 分没了。\n赛后 我一看分数就傻眼了。\n再一看：T3 File Error：“未找到选手输出文件”\n哦，仔细一看，我把一个 freopen 的文件名写错了，好家伙，这又少了 $60$ 分。\nT4 果然挂了，不出所料，不过我和 Solution 的思路是差不多的，但是实现似乎有点问题。\n又在 OJ 上交了一发，好家伙，T1 直接 AC 了，T3 $60$ 分了。\n忽然意识到，我因为 freopen 痛失了 $100+60=160$ 分。太伤了，加上这些分我似乎能进 Rank 5。\n题目都不是很难，T2 其实是个分类讨论题，感觉再来点时间也能想出来，倒是 T3 似乎思维难度最大，有点类似染色（\n总结 狂喜把自己狂喜没了，这次在做题上还算是比较完美的，不过下一次必须认真比对文件名之后（或者直接复制）再去搞下一道题。\n这次太着急了，所以出了一堆错误。\nT1 明明几分钟就想出来正解了，结果后面又否定自己，最后又发现自己是对的，也浪费了大量时间。\n代码实现的时候也浪费了时间。\n只能说码力还是不够，正解和暴力都写得太慢了，结果没有时间支持我深入思考每道题，相信随着刷题数的增多我这个能力能增强的。\n","permalink":"https://luoyisu.github.io/posts/210818%E6%9E%84%E9%80%A0%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%8C%82%E5%88%86%E8%AE%B0/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e今天是构造，题似乎不是很难，然而我挂的很惨。\u003c/p\u003e\n\u003cp\u003e期望：$100+30+60+100=290$​，实际 $0+20+0+5=25$​。大家都挂的很惨，于是我 RK13/23。。。\u003c/p\u003e","title":"210818构造模拟赛挂分记"},{"content":"概述 今天是数学，本来以为会还行，结果 $0+0+30+5=35$​，接近垫底了（\n再次被机房男女老少暴打qwq。\n赛时 四道题都看了看，发现 T1是个推式子，推着推着心态爆炸，瞎打了个式子就溜了。\nT2 暴力大概会写，但不想写，感觉不太可做。\nT3 是个博弈论，感觉不可做。\nT4 是个思维题，觉得能拿一些部分分，于是开始写。\n写完之后把 T2 的 $20$ 分打了，T3 找了一波规律就溜了。\n赛后 发现 T1 是个卡特兰数？？？\n好家伙我完全不记得这是啥了。。。行吧，死的不冤。\nT2 不是很难\u0026hellip;暴力+算斜率+数据结构优化即可。但是为什么我把 freopen 注释了？？？？？？？$20$ 分没了。。。\nT3 我想太简单了，确实是找规律，但没有那么简单，我傻了。\nT4 是个数论题，有点难 qwq\u0026hellip; Link\n大概是通过一些性质算出多项式的常数项，然后降次，递归求解。挺神奇的\u0026hellip;写了一遍\u0026hellip;\n总结 总之自己对数学各种奇怪的数完全不了解，发现自己推式子的能力还是不强——所以我 DP 也不行。\n明明想到第二题暴力，第三题多想想也许就能对，但是却没时间推了。\n也许，只能通过多做题提升自己码力？\n顺便，感觉自己确实实力不足，也许是题做少了\u0026hellip;\n多总结，加大做题量\u0026hellip;\n把 freopen 注释掉这个错误我不会再犯了\n","permalink":"https://luoyisu.github.io/posts/210817%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%88%86%E9%9B%B6%E8%AE%B0/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e今天是数学，本来以为会还行，结果 $0+0+30+5=35$​，接近垫底了（\u003c/p\u003e\n\u003cp\u003e再次被机房男女老少暴打qwq。\u003c/p\u003e","title":"210817数学模拟赛爆零记"},{"content":"前言 最近字符串模拟赛中遇到了一道诡异的题，std 的方法是启发式合并 Trie 树，但我写了个更简单（？）的 BFS＋Trie树+LCA 做法。\n后来得知是 CF 的题，就上来交一波，结果确实 AC 了。\n这做法大概是对的，但是似乎有点慢（还难写）\u0026hellip;\n题意 有一棵以结点 $1$ 为根的树，每个结点上都有一个小写字母，对于以每个结点，从该结点出发向其子树中走，路上经过的点能形成一个字符串。求以每个结点为根的子树中能用此方法走出的不同的字符串数量。\n链接\nCF上原题还有一些奇怪的操作就不说了，对上述答案做一下简单的处理就行了。\nSolution 显然这道题和 Trie 树有关。\n对每个点 $i$ 记录一个 $mus[i]$，表示以 $i$ 为根的子树中有多少个重复的字符串。（mus的意思大概是minus，即“减”）\n考虑 BFS 原树，将遍历到的点插入到 Trie 树中，BFS 时候记录一下 Trie 树上每个点对应的在原树上的点数组 $trie$，如果插入的时候发现这个字符串已经被插入到 Trie 树中，说明有一个重复的字符串，将这个点和 Trie 树上的点对应在原树上点的 LCA 的 $mus$ 数组 $+1$，更新上面的 $trie$ 数组。\n最后跑一遍 DFS 统计答案即可。\n值得一提的是可以发现如果字符串相同，那么他们在原树上深度必定相同，所以所以求 LCA 的时候不用跳到深度相同了。\n至于为什么在 LCA 上打标记，大概是因为打标记的时候要走到两个结点相同的，最早出现有至少两个儿子的字符相同的结点，在这里打标记，才会不重不漏。可以画画图理解。\n时间复杂度 $O(n\\log n)$，足以通过本题。\nCode 我这代码常数贼大，别人最慢也跑 $30s$，我直接干到 $50s$。\n还好这题时限开得也大（\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 300010; int ch[maxn][28], tot = 1, trie[maxn]; // ch 是 Trie 树 // trie[i] 代表在 Trie 树上编号为 i 的结点对应在原树上的结点编号。 vector\u0026lt;int\u0026gt; e[maxn]; void add(int x, int y) { e[x].push_back(y), e[y].push_back(x); } string s; int mus[maxn], siz[maxn], ans[maxn], v[maxn], a[maxn], n; int f[maxn][32]; struct node // BFS 用结构体 { int fa, x, tfa; // fa，x 代表在原树中该结点父亲、该结点编号。 // tfa 代表在 Trie 树上该结点的父亲 }; void dfs_lca(int x, int fa) { f[x][0] = fa; for (int i = 1; i \u0026lt;= 31; i++) f[x][i] = f[f[x][i - 1]][i - 1]; for (int i = 0; i \u0026lt; e[x].size(); i++) if (e[x][i] != fa) dfs_lca(e[x][i], x); } int LCA(int x, int y) { if (x == y) return x; for (int i = 31; i \u0026gt;= 0; i--) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; } void init() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; cin \u0026gt;\u0026gt; s; s = \u0026#34; \u0026#34; + s; int x, y; for (int i = 0; i \u0026lt; n - 1; i++) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y), add(x, y); dfs_lca(1, 0); } void bfs() { queue\u0026lt;node\u0026gt; q; q.push((node){0, 1, 1}); while (!q.empty()) { node now = q.front(); q.pop(); //now.P(); if (v[now.x]) continue; v[now.x] = 1; int c = s[now.x] - \u0026#39;a\u0026#39;; if (ch[now.tfa][c]) // 如果当前结点对应字符串已经被插入到 Trie 树中 mus[LCA(now.x, trie[ch[now.tfa][c]])]++, trie[ch[now.tfa][c]] = now.x; // 在两点 LCA 上打标记，并将 Trie 树上该点对应原树上结点更新 else ch[now.tfa][c] = ++tot, trie[ch[now.tfa][c]] = now.x; // 没被插入就新开个点，并更新 trie 数组 for (int i = 0; i \u0026lt; e[now.x].size(); i++) q.push((node){now.x, e[now.x][i], ch[now.tfa][c]}); } } void dfs(int x, int fa) // DFS 统计答案 { siz[x] = 1; for (int i = 0; i \u0026lt; e[x].size(); i++) { if (e[x][i] != fa) { dfs(e[x][i], x); siz[x] += siz[e[x][i]]; mus[x] += mus[e[x][i]]; } } ans[x] = siz[x] - mus[x]; } void out_put() { int mx = -1, cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { if (mx == ans[i] + a[i]) cnt++; else if (ans[i] + a[i] \u0026gt; mx) mx = ans[i] + a[i], cnt = 1; } cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } void solve() { bfs(); memset(v, 0, sizeof(v)); dfs(1, 0); } int main() { init(); solve(); out_put(); return 0; } ","permalink":"https://luoyisu.github.io/posts/cf601d-%E4%B8%80%E9%81%93%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E7%9A%84%E8%AF%A1%E5%BC%82%E8%A7%A3%E6%B3%95/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e最近字符串模拟赛中遇到了一道诡异的题，std 的方法是启发式合并 Trie 树，但我写了个更简单（？）的 BFS＋Trie树+LCA 做法。\u003c/p\u003e\n\u003cp\u003e后来得知是 CF 的题，就上来交一波，结果确实 AC 了。\u003c/p\u003e\n\u003cp\u003e这做法大概是对的，但是似乎有点慢（还难写）\u0026hellip;\u003c/p\u003e","title":"CF601D \u0026 一道字符串模拟赛题的诡异解法"},{"content":"概述 因为打疫苗只打了将近两个小时。期望 $0+20+30+0=50$，实际 $0+0+60+0=60$。\n还行吧，今天题是真的难。\n赛时 因为回来晚了就不想着暴力了，试图切题，然后发现四道题都难的一逼。\n一直想到剩余一小时，然后发现爆零太难看了，于是开始写暴力。\nT1、4 完全没思路，暴力似乎也不是特别好写，于是就打了 T2、3 的暴力，不知道能搞多少分。\n就这样，没啥好说的。。。\n赛后 看了 Solution，发现是四道思维题，甚至基环树？\u0026hellip;\u0026hellip;\n好家伙我直呼好家伙\n最后 T2 挂了，不知道为什么，但 T3 倒是得了 $60$ 分，大概是常数小吧，我那个做法可以被卡到 $O(n^3)$ 的。\n总结 然后我忽然意识到了，是不是应该先打暴力？\n先打暴力再推正解\u0026hellip;\n很难说，也许比赛确实应该先打暴力\u0026hellip;？\n","permalink":"https://luoyisu.github.io/posts/210816%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98%E6%A8%A1%E6%8B%9F%E8%B5%9B/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e因为打疫苗只打了将近两个小时。期望 $0+20+30+0=50$，实际 $0+0+60+0=60$。\u003c/p\u003e\n\u003cp\u003e还行吧，今天题是真的难。\u003c/p\u003e","title":"210816树上问题模拟赛"},{"content":"概述 今天是图论，我本来以为会考最小生成树、tarjan 之类，结果没考，考了一些稍生僻（其实就是我不会）的算法以及思维题，所以我挺悲惨的。\n期望：$0+0+60+100=160$，实际 $0+0+30+90=120$。大家都爆零了所以我名次还行\u0026hellip;\n赛时 一看到题目顺序不定，我就开始随缘开题了。\n首先看 T1，感觉是个字符串，似乎是瞎搞搞连边然后折腾，但我不会，心态良好，先去看 T2 了。\n再看 T2，感觉和 NOIP 有一道分监狱的题类似，用并查集维护和某个人不在同一个集合的人的集合，能判断有没有解，但具体怎么分我不知道。。。不知道和图论有什么关系。行。瞎搞了一波过了样例就溜了。\n看 T3、T4，其实 T3 有点思路，像这种与时间有关的询问都可以考虑离线，但我觉得搞不出来，先放着了。\n又去看 T4，看到一堆符号就溜了。\n滚回去写 T1，用 map 瞎搞了一波，过了样例但跑得贼慢，后来觉得我这个做法有点假，我也就不期望得分了。\n滚回去调 T2，再次瞎搞，做法好像也是假的，希望能骗到分。\n由于我现在已经写完两题了，现在心态十分良好，T3 也有暴力的思路了。\n先看了一波 T4，稍微推了一下，这TM不是大水题吗，删一些点跑最短路就完事了，20min 写完，过了样例。\n这时候还剩 40min，回去写 T3 的暴力，还剩 10min 的时候写完。大概能过 $60$ 分。然后开始摸鱼。\n赛后 发现 T1、2都挂了，意料之中吧，T3 的 test $4 \\sim 6$ WA 了，我也不知道怎么挂的，不应该啊。\nT4 发现我考虑的有点少了，做法有点假，应该把无向边转成有向再跑最短路或 BFS，不过出题人说他没想卡直接跑最短路的假做法，只卡了 $10$​​ 分，谢出题人不杀之恩！\nT1 是个欧拉路题，我不会，有人知道但不会写因此心态爆炸，然而我心态良好，因为我根本就不知道这玩意（\nT2 是个补图+二分图染色，有点意思。\nT3 确实是离线，然后用类似 Floyd 的方法做，有思维难度但似乎不是特别大。\n总结 首先心态不错确实是今天一大优点（虽然爆零了两道题）\n图论有些知识点不能忽略，得抓紧时间补一补了。\n当一道题假了，是应该放弃，去做别的题，还是应该接着尝试搞？这确实是需要反复尝试，找出最优解的。\n明天树上问题 RP++。\n早上复习一下 LCA、直径、重心、树上DP吧。\n","permalink":"https://luoyisu.github.io/posts/210815%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%8B%9F%E8%B5%9B%E5%BF%83%E6%80%81%E8%89%AF%E5%A5%BD%E8%AE%B0/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e今天是图论，我本来以为会考最小生成树、tarjan 之类，结果没考，考了一些稍生僻（其实就是我不会）的算法以及思维题，所以我挺悲惨的。\u003c/p\u003e\n\u003cp\u003e期望：$0+0+60+100=160$，实际 $0+0+30+90=120$。大家都爆零了所以我名次还行\u0026hellip;\u003c/p\u003e","title":"210815图论模拟赛心态良好记"},{"content":"概述 今天是字符串，然而字符串有关算法我基本就会 Trie 树和 Hash，KMP 到现在都不太会。。。\n期望 $100+20+100+0=220$，实际 $0+50+30+0=80$，rank 14/23\nOrz KH AK！！！\n赛时 按顺序开题，发现 T1 是个 trie 树题，我一阵狂喜，这玩意我会啊，搞正反插 trie 树就成。\n结果写了半天没搞出来，调来调去心态爆炸，过了样例之后就扔了。\nT2是个 KMP，我会口胡但不会写，先放着。\nT3感觉是个 Trie 树，想了一个诡异的做法，看着挺对，就写了，调了调过样例了，感觉自己切了。\nT4没时间想了，没写。\n回去写 T2 暴力，写了个最暴力的 $O(n^3)$ 算法，然后就溜了。\n赛后 发现我T1、3都挂了，都是意料之中，我虽然觉得能切但写挂了也很可能。\nT3我做法疑似是假的，怀疑人生。\nT2居然多卡过去了 $30$ 分，太神奇了，看来我这个暴力常数贼小。\n总结 KMP 不会是硬伤，而且我对字符串所有算法都不熟练，包括 Hash 等等，KMP还是得弄懂。\n感觉今天策略没啥问题，就是 T1 写太久了，最后还挂了。导致没时间调试T1、3。还是不熟练的问题，题做的太少了。\n","permalink":"https://luoyisu.github.io/posts/210814%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%8C%82%E5%88%86%E8%AE%B0/","summary":"\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003cp\u003e今天是字符串，然而字符串有关算法我基本就会 Trie 树和 Hash，KMP 到现在都不太会。。。\u003c/p\u003e\n\u003cp\u003e期望 $100+20+100+0=220$，实际 $0+50+30+0=80$，rank 14/23\u003c/p\u003e\n\u003cp\u003eOrz KH AK！！！\u003c/p\u003e","title":"210814字符串模拟赛挂分记"},{"content":"友链，似乎有点冷清，所以欢迎互换！\n同年级 KH 神\nshr大佬\n","permalink":"https://luoyisu.github.io/friends/","summary":"友链，似乎有点冷清，所以欢迎互换！\n同年级 KH 神\nshr大佬","title":"友链"},{"content":"我是 _slb，一个来自 LN-DL 的 OIer。\n曾用名：Touma_Kazusa\n平时会在这里发点题解、总结之类，也有可能发点别的？\n我太菜了，不要假我了。。\nNote1： 我以前的博客在 博客园，之前的博客就不搬过来了。以后那个博客随缘更新了，以这个为主。\n有些文章上了锁，密码可以找我要，不过毕竟这是个静态博客，是防君子不防小人的。\n博客还有很多不完善的地方，我会陆续修的，有什么建议都可以告诉我啊~\nqq：2104607469\n","permalink":"https://luoyisu.github.io/about/","summary":"我是 _slb，一个来自 LN-DL 的 OIer。\n曾用名：Touma_Kazusa\n平时会在这里发点题解、总结之类，也有可能发点别的？\n我太菜了，不要假我了。。\nNote1： 我以前的博客在 博客园，之前的博客就不搬过来了。以后那个博客随缘更新了，以这个为主。\n有些文章上了锁，密码可以找我要，不过毕竟这是个静态博客，是防君子不防小人的。\n博客还有很多不完善的地方，我会陆续修的，有什么建议都可以告诉我啊~\nqq：2104607469","title":"about"},{"content":"概述 期望 $100+30+70+20=220$，实际 $100+0+10+10=120$，rk6，有点神奇，不过机房神仙们连切三题太神了！\n赛时 首先看到今天是个杂项：分治二分倍增快速幂，又看到难度是递增的，尝试多拿分、切题。\n首先看到T1，就差把分治写脸上了，快速打了个大框然后写分治的递归函数。\n打完之后一阵狂喜，然后测样例的时候发现我做法假了，把这题想太简单了。\n一阵思考发现情况太多了。。。\n本来打算列出所有情况打表进行分治的，结果写一半发现实在是太难了，遂放弃，尝试之前旋转的思路（我之前没证明，不是很敢写）。\n这时候一个多小时已经过去了，我一分没拿，属实心态爆炸。\n稍微看了看T234，感觉全都不大能做，还是滚回来写T1。\n这次用旋转的规律做了一波，样例过了，自己测了几组数据没问题，就过了。\n这个时候已经两个多小时了，我至少切了一题，心态有所好转。\n接下来看后面的题，首先发现T4除了前 $20$ 分我都不会，赶快打了个暴力放弃T4了。\n回来看T2、3，感觉T2有点二分的意思，不过没怎么推出来，只能瞎搞了个 $30$ 分暴力，我当时也没细想，觉得能过前面的数据。。。\n还剩半个多小时，看了看T3，写了个 DFS 爆搜，样例过了，瞎造了一组数据也过了，感觉 $70$ 分应该可以了。\n赛后 结果T1 AC只有 $7$ 人，老师也说这低于他预期，我觉得T1确实有毒。。。\nT234全挂了，后来发现挂的不冤，还是太着急了，暴力也没认真写。\n看了 Solution，发现T4是个矩阵快速幂的优化递推，好家伙，我连矩阵怎么算都快忘了。。。\nT2确实是二分，有点神仙，T3是个倍增，考试时候有点感觉，但没时间也没能力写\u0026hellip;\n还是要很扎实地掌握基础知识点和基础题，才能熟练运用啊。。。\n明天字符串，我要裂开了。。。\n","permalink":"https://luoyisu.github.io/posts/210813%E6%9D%82%E9%A1%B9%E6%A8%A1%E6%8B%9F%E8%B5%9B%E4%B9%B1%E6%94%B9%E8%AE%B0/","summary":"概述 期望 $100+30+70+20=220$，实际 $100+0+10+10=120$，rk6，有点神奇，不过机房神仙们连切三题太神了！\n赛时 首先看到今天是个杂项：分治二分倍增快速幂，又看到难度是递增的，尝试多拿分、切题。\n首先看到T1，就差把分治写脸上了，快速打了个大框然后写分治的递归函数。\n打完之后一阵狂喜，然后测样例的时候发现我做法假了，把这题想太简单了。\n一阵思考发现情况太多了。。。\n本来打算列出所有情况打表进行分治的，结果写一半发现实在是太难了，遂放弃，尝试之前旋转的思路（我之前没证明，不是很敢写）。\n这时候一个多小时已经过去了，我一分没拿，属实心态爆炸。\n稍微看了看T234，感觉全都不大能做，还是滚回来写T1。\n这次用旋转的规律做了一波，样例过了，自己测了几组数据没问题，就过了。\n这个时候已经两个多小时了，我至少切了一题，心态有所好转。\n接下来看后面的题，首先发现T4除了前 $20$ 分我都不会，赶快打了个暴力放弃T4了。\n回来看T2、3，感觉T2有点二分的意思，不过没怎么推出来，只能瞎搞了个 $30$ 分暴力，我当时也没细想，觉得能过前面的数据。。。\n还剩半个多小时，看了看T3，写了个 DFS 爆搜，样例过了，瞎造了一组数据也过了，感觉 $70$ 分应该可以了。\n赛后 结果T1 AC只有 $7$ 人，老师也说这低于他预期，我觉得T1确实有毒。。。\nT234全挂了，后来发现挂的不冤，还是太着急了，暴力也没认真写。\n看了 Solution，发现T4是个矩阵快速幂的优化递推，好家伙，我连矩阵怎么算都快忘了。。。\nT2确实是二分，有点神仙，T3是个倍增，考试时候有点感觉，但没时间也没能力写\u0026hellip;\n还是要很扎实地掌握基础知识点和基础题，才能熟练运用啊。。。\n明天字符串，我要裂开了。。。","title":"210813杂项模拟赛乱改记"},{"content":"虽然不是刚考完写的，但就当我是那个时候写的吧。\n上句话似乎也不对（毕竟那个时候还有很多事情（如成绩）不知道），不过这算是我忽然想写的一个小总结。\n未完结，总结待填\n概述 总成绩：$136.5+146+88+70+135+45+50=670.5$​，分别为语文/数学/物理/化学/英语/等级科目/体育，满分分别为 $150,150,90,70,140,45,50$​。这成绩大概是全市 $20$​​ 名出头吧。考试前一个月突击得不错。\nDay -？？？？ 好多科目（包括 $1000$ 米）不考了，好耶，练实心球ing。\nDay -？？？ 体育过了，等级考试过了，好耶。\nDay -？？ 一模炸了，数学甚至刚好优秀（25 不会做、26 算错了），化学 $63$ 也是低得离谱。\n年级 $36$，这 TM 要考不上了啊。\n失落了一段时间，但我相信我的聪明才智。\n毕竟以前都没怎么做题，现在开始稍微做一点应该就没啥问题了。\n于是每天多花一点时间（也就 $20\\text{min}$ 左右）做一做几何题和物理。化学弃疗了，我相信我们老师.jpg\n语文 数学 英语 物理 化学 总分 分数 $135.5$ $135$ $130$ $87$ $63$ $550.5$ 校名次 $40$ $130$ $64$ $11$ $40$ $36$ 区名次 $110$ $467$ $164$ $46$ $147$ $94$ Day -？ 八区联考，考完感觉还行，数学有点拉，不过能到 $140$。其他没啥问题。感觉状态回来了。\n于是发现考了区第一，好神奇。又定睛一看我语文 $136.5$，让人疑惑，然后发现自己作文 $65.5$，看来作文没白背。（我就是个文化沙漠）\n于是发现自己阅读其实平平，只拿到了简单分。行吧。\n又发现自己语文和化学都是区 $\\text{rk}2$​，好耶，对化学重新燃起自信.jpg\n这次考试从大家的分数上来看比上次难一些，虽说我体感没觉得难，但我似乎是几乎没有的成绩正增长的人之一（\n语文 数学 英语 物理 化学 总分 分数 $136.5$ $142$ $133$ $87.5$ $68.5$ $567.5$ 校名次 $1$ $15$ $31$ $16$ $2$ $1$ 区名次 $2$ $44$ $92$ $50$ $2$ $1$ 于是接下来半摸鱼，大概额外做了 $10$ 道几何题（\n不过似乎很少有人能连续两次考试发挥良好，害怕.jpg，感觉我中考要炸了。\nDay -1 并不紧张，十点多就睡着了。\nDay 1 考前和大家聊得很愉快。膜拜 xwj 神！！！\n语文 记叙文有点懵逼，其他没啥。\n作文随便迁移了一篇上去。\n总得来说一般，但我非常满足了。是个好的开始。\n物理 \u0026amp; 化学 物理感觉都是水题，多选瞎推了推就搞定了。\n后面的题没怎么多想，快速写完就溜了。\n求稳，物理做得有点慢，去搞化学了。\n化学真就传统艺能，简答题让我想吐。全在蒙，希望能对。\n尤其是一个很怪的“多孔玻璃球泡”，苦思冥想写了个看上去挺对的结果。\n出来之后发现大家哀嚎遍野，说物理难，但我觉得化学更难啊？？？\n没敢对答案，快速回家。\nDay 2 数学 太水了，全都是水题，我还以为数学会很难呢。\n几何题就差把辅助线告诉你了（\n然后发现最后一题的最后一问有一个情况不知道为啥算不出来，算了算了，弃疗。\n考完试对答案之后发现那个题确实错了，痛失 $150$。。。。\n苦思冥想之后发现是我把一个符号搞错了。。。\n不亏，现在考试已经相当于结束了，英语大家都一样。我已经提前锁定胜局。\n英语 好家伙，这英语太让人纠结了。\n选题目——“Be Well and Have Well”，实在不知道选啥，瞪着这个选项看了好久，忽然意识到是“好人好报”的意思。于是就选了。\n回答问题一阵瞎答，作文也瞎写，然后就交卷了，感觉稳的一逼。\n对答案之后发现那道选题目大家的答案都不一样，我坚信我是对的（（（（（\nDay 2？ 于是去知乎上写了个回答，当时估自己是在 $660$ 左右，看大家都说物理难，我就有点懵。\n去知乎上一一反驳物理多选选其他答案的人，似乎还和 KH 神聊了几句（\n都是缘分啊~~~~\nDay ？ 查分了，发现自己上了 $670$，似乎还是全校第一。不过因为语文数学有点低，在全市就不是非常高了。\n一阵狂喜，物理化学 $158$，靠这个碾压了不少人。（大家这两科普遍低）\n语文 数学 英语 物理 化学 体育 等级科目 总分 分数 $136.5$ $146$ $135$ $88$ $70$ $50$ $45$ $670.5$ 很开心，最后一个月突击效果不错。\n数学看样子是被扣过程分了，算了算了，也还行。\nDay ？+ 2 去了二十四中见信竞教练，于是第二天就开始和同样是新高一的大佬们集训了。这速度让人感觉上了艘贼船\n然后就开始了被吊打的生活，快乐又充实（（（（（（（（\nDay ？？ 查录取了，毫无悬念地统招二十四，初中生活就这么结束了。\n总结 未完工。\n给我的初中生活做点总结吧。\n非学习方面 首先我肯定不算现充，和人沟通的能力很差，没事干的时候也喜欢待在家里。\n运动也很讨厌，有人说我长的挺帅，但我毫无实感。。。\n平时爱好就是打打游戏看看小说、动画、也写点很简单的代码（不过初中实际上没怎么写）。\n非学习方面就这么简单，实在是有点单调到无聊。。。\n学习方面 首先我肯定不算特别聪明，但可能比学校大部分人还是聪明一些。\n我没法快速算数学题，也没办法一眼秒杀数学难题，但我理解力绝对不低，记忆力也不差，按照自己的节奏慢慢思考也很难碰到完全不会做的题。\n因此在七上发现考试随便考考就能混个 $20$ 名之后我也就不思进取了，上课认真听一听，每天认真写完作业之后（除了语文其实并不认真）开始娱乐然后直接睡觉，啥都不学（（（\n反正这么样一直持续到了九下。期间虽然也有时候对自己的数学不满意（主要是几何不会做，水题也会错），但因为名次都还凑活也没怎么在意。一直混在年级 $10$ 名左右，不过到了八下、九上数学实在是越来越拉了。\n在印象中七年级到八上基本成绩平均在 $10$​ 名以内，七下考了个第一。八下九上有点拉，不过好像也没掉出 $20$？（似乎九上期末掉了一回），九上好像是又考了一次年级第一，挺怪的。反正挺图一乐的。\n九上期末考试应该是挺拉的，不过毕竟要中考了，九下还是认真了一点——\n其实完全就没认真，数学直接躺平，几何做不出来拉倒。\n反正就这么摆烂，第一次双基考试几何不会做直接又掉到 $20$​​ 开外，第二次校内小考试倒是数学挺简单，几何做出来了，差一点就满分了，这次考得倒是还行，混了个前十。\n接着就是市模、八区联考、中考。\n上文似乎没有很完整写心理波动，其实我发现市模那么拉的时候还是很难受的。八区联考算是一个定心丸，中考就是稳定发挥了。\n实际上有信心和实力之后之后中考就像是一个水到渠成的事情。\n关于各个学科 语文 怎么说呢，我的语文偏向于吃小学的老本，阅读题就是纯粹乱答。\n阅读能力还是有的，但是我实在不喜欢积累（指看各种书来培养文学素养），因此我的作文是真的拉，记叙文不知道写啥，议论文也写的很差更没例子。\n文言文就是把书上的熟练掌握，课外靠蒙。\n默写没啥说的，背就完事了，我也没啥技巧。\n数学 最让人一言难尽的学科。\n首先我肯定是很喜欢的，但自己实在不是特别擅长这个学科——指做不出来几何题。\n其实未必是不擅长吧，就是解几何题需要大量训练，但我花在上面时间并不是很多。\n这个学科还是需要大量训练的，除非你强到能秒杀所有题目，还能保证快速算对。\n技巧也没太多，就是总结方法。\n英语 班主任是英语老师，我就跟着她的步调走。\n实际上我其实不喜欢英语这个学科，感觉这个学科除了背东西以外什么都不剩了。\n当然了，当你会了单词，再做大量的阅读练习，英语这个学科就无比简单了。\n阅读随便答，作文随便写。\n平日英语积累到位了考试时候根本就不带怕的。\n物理 我算是提前在网上跟着一个录播课把整个初中物理给顺了一遍，当时也碰到了很多奇怪的计算题，李永乐老师也确实是名师，反正我算是摸索出来了物理题的解题方法——列很多等式然后往你想要的东西上瞎折腾。\n我物理一直也就处于一个就那样的状态，主要是因为一些简答题和实验题太不对胃口了。\n感觉提前学还是有点用的，但也不必要。\n化学 这个学科我完全没学，这个时候就能看出我们化学老师的水平了（）\n反正她确实教的好，我也喜欢这个老师。\n自己也没找课外的练习册做，就是把学校的任务完成了，凭着阅读理解能力和乱蒙算是在这个学科上出类拔萃了。\n不过初中这点知识相比高中还是有点小儿科了。\n生物 开卷考试，没怎么花功夫学，就是上课听听课，把作业写完。\n实际上这个学科还是很简单的，我后期基本不需要书。\n地理 学的过程和生物一样，但我就是会莫名其妙错很多题导致分数比生物低一些。\n可能我不适合学这个吧。\n历史 开卷考试，图一乐，毫无难度。上课认真听一听就行，写写作业。\n面对一个题我还是能分析出来应该回答什么的，但是没花时间去记，于是只能看书。\n实在是记不住。。。。。\n政治 开卷考试，图一乐，毫无难度。上课认真听一听就行，写写作业。\n面对一个题我很能分析出来应该回答什么的，但是没花时间去记，于是只能看书。\n实在是记不住。。。。。\n如果能开卷，我在这个学科上应该还算挺强的，但实在记不住啊啊啊。。\n","permalink":"https://luoyisu.github.io/posts/2021%E5%A4%A7%E8%BF%9E%E4%B8%AD%E8%80%83/","summary":"\u003cp\u003e虽然不是刚考完写的，但就当我是那个时候写的吧。\u003c/p\u003e\n\u003cp\u003e上句话似乎也不对（毕竟那个时候还有很多事情（如成绩）不知道），不过这算是我忽然想写的一个小总结。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e未完结，总结待填\u003c/strong\u003e\u003c/p\u003e","title":"2021大连中考"}]